/* processed by `supro/_ExtJS4_tools.sh`
This file is part of Ext JS 4.2
Copyright (c) 2011-2013 Sencha Inc
GNU General Public License Usage
If you are unsure which license is appropriate for your use, please contact the sales department
at http://www.sencha.com/contact.
Source: ext-all-debug.js (16fe8da2b314463258625ddd6c77379040d34b45)
*/
var Ext = Ext || {};
Ext._startTime = new Date().getTime();
(function() {
var global = this,
objectPrototype = Object.prototype,
toString = objectPrototype.toString,
enumerables = true,
enumerablesTest = {toString: 1},
emptyFn = function () {},
callOverrideParent = function () {
var method = callOverrideParent.caller.caller; 
return method.$owner.prototype[method.$name].apply(this, arguments);
},
i,
ExtApp,
iterableRe = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/;
Ext.global = global;
for (i in enumerablesTest) {
enumerables = null;
}
if (enumerables) {
enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable',
'toLocaleString', 'toString', 'constructor'];
}
Ext.enumerables = enumerables;
Ext.apply = function(object, config, defaults) {
if (defaults) {
Ext.apply(object, defaults);
}
if (object && config && typeof config === 'object') {
var i, j, k;
for (i in config) {
object[i] = config[i];
}
if (enumerables) {
for (j = enumerables.length; j--;) {
k = enumerables[j];
if (config.hasOwnProperty(k)) {
object[k] = config[k];
}
}
}
}
return object;
};
Ext.buildSettings = Ext.apply({
baseCSSPrefix: 'x-'
}, Ext.buildSettings || {});
Ext.apply(Ext, {
name: Ext.sandboxName || 'Ext',
emptyFn: emptyFn,
identityFn: function(o) {
return o;
},
emptyString: new String(),
baseCSSPrefix: Ext.buildSettings.baseCSSPrefix,
applyIf: function(object, config) {
var property;
if (object) {
for (property in config) {
if (object[property] === undefined) {
object[property] = config[property];
}
}
}
return object;
},
iterate: function(object, fn, scope) {
if (Ext.isEmpty(object)) {
return;
}
if (scope === undefined) {
scope = object;
}
if (Ext.isIterable(object)) {
Ext.Array.each.call(Ext.Array, object, fn, scope);
}
else {
Ext.Object.each.call(Ext.Object, object, fn, scope);
}
}
});
Ext.apply(Ext, {
extend: (function() {
var objectConstructor = objectPrototype.constructor,
inlineOverrides = function(o) {
for (var m in o) {
if (!o.hasOwnProperty(m)) {
continue;
}
this[m] = o[m];
}
};
return function(subclass, superclass, overrides) {
if (Ext.isObject(superclass)) {
overrides = superclass;
superclass = subclass;
subclass = overrides.constructor !== objectConstructor ? overrides.constructor : function() {
superclass.apply(this, arguments);
};
}
var F = function() {},
subclassProto, superclassProto = superclass.prototype;
F.prototype = superclassProto;
subclassProto = subclass.prototype = new F();
subclassProto.constructor = subclass;
subclass.superclass = superclassProto;
if (superclassProto.constructor === objectConstructor) {
superclassProto.constructor = superclass;
}
subclass.override = function(overrides) {
Ext.override(subclass, overrides);
};
subclassProto.override = inlineOverrides;
subclassProto.proto = subclassProto;
subclass.override(overrides);
subclass.extend = function(o) {
return Ext.extend(subclass, o);
};
return subclass;
};
}()),
override: function (target, overrides) {
if (target.$isClass) {
target.override(overrides);
} else if (typeof target == 'function') {
Ext.apply(target.prototype, overrides);
} else {
var owner = target.self,
name, value;
if (owner && owner.$isClass) { 
for (name in overrides) {
if (overrides.hasOwnProperty(name)) {
value = overrides[name];
if (typeof value == 'function') {
value.$name = name;
value.$owner = owner;
value.$previous = target.hasOwnProperty(name)
? target[name] 
: callOverrideParent; 
}
target[name] = value;
}
}
} else {
Ext.apply(target, overrides);
}
}
return target;
}
});
Ext.apply(Ext, {
valueFrom: function(value, defaultValue, allowBlank){
return Ext.isEmpty(value, allowBlank) ? defaultValue : value;
},
typeOf: function(value) {
var type,
typeToString;
if (value === null) {
return 'null';
}
type = typeof value;
if (type === 'undefined' || type === 'string' || type === 'number' || type === 'boolean') {
return type;
}
typeToString = toString.call(value);
switch(typeToString) {
case '[object Array]':
return 'array';
case '[object Date]':
return 'date';
case '[object Boolean]':
return 'boolean';
case '[object Number]':
return 'number';
case '[object RegExp]':
return 'regexp';
}
if (type === 'function') {
return 'function';
}
if (type === 'object') {
if (value.nodeType !== undefined) {
if (value.nodeType === 3) {
return /\S/.test(value.nodeValue) ? 'textnode' : 'whitespace';
}
else {
return 'element';
}
}
return 'object';
}
},
coerce: function(from, to) {
var fromType = Ext.typeOf(from),
toType = Ext.typeOf(to),
isString = typeof from === 'string';
if (fromType !== toType) {
switch (toType) {
case 'string':
return String(from);
case 'number':
return Number(from);
case 'boolean':
return isString && (!from || from === 'false') ? false : Boolean(from);
case 'null':
return isString && (!from || from === 'null') ? null : from;
case 'undefined':
return isString && (!from || from === 'undefined') ? undefined : from;
case 'date':
return isString && isNaN(from) ? Ext.Date.parse(from, Ext.Date.defaultFormat) : Date(Number(from));
}
}
return from;
},
isEmpty: function(value, allowEmptyString) {
return (value === null) || (value === undefined) || (!allowEmptyString ? value === '' : false) || (Ext.isArray(value) && value.length === 0);
},
isArray: ('isArray' in Array) ? Array.isArray : function(value) {
return toString.call(value) === '[object Array]';
},
isDate: function(value) {
return toString.call(value) === '[object Date]';
},
isObject: (toString.call(null) === '[object Object]') ?
function(value) {
return value !== null && value !== undefined && toString.call(value) === '[object Object]' && value.ownerDocument === undefined;
} :
function(value) {
return toString.call(value) === '[object Object]';
},
isSimpleObject: function(value) {
return value instanceof Object && value.constructor === Object;
},
isPrimitive: function(value) {
var type = typeof value;
return type === 'string' || type === 'number' || type === 'boolean';
},
isFunction:
(typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') ? function(value) {
return !!value && toString.call(value) === '[object Function]';
} : function(value) {
return !!value && typeof value === 'function';
},
isNumber: function(value) {
return typeof value === 'number' && isFinite(value);
},
isNumeric: function(value) {
return !isNaN(parseFloat(value)) && isFinite(value);
},
isString: function(value) {
return typeof value === 'string';
},
isBoolean: function(value) {
return typeof value === 'boolean';
},
isElement: function(value) {
return value ? value.nodeType === 1 : false;
},
isTextNode: function(value) {
return value ? value.nodeName === "#text" : false;
},
isDefined: function(value) {
return typeof value !== 'undefined';
},
isIterable: function(value) {
if (!value || typeof value.length !== 'number' || typeof value === 'string' || Ext.isFunction(value)) {
return false;
}
if (!value.propertyIsEnumerable) {
return !!value.item;
}
if (value.hasOwnProperty('length') && !value.propertyIsEnumerable('length')) {
return true;
}
return iterableRe.test(toString.call(value));
}
});
Ext.apply(Ext, {
clone: function(item) {
var type,
i,
j,
k,
clone,
key;
if (item === null || item === undefined) {
return item;
}
if (item.nodeType && item.cloneNode) {
return item.cloneNode(true);
}
type = toString.call(item);
if (type === '[object Date]') {
return new Date(item.getTime());
}
if (type === '[object Array]') {
i = item.length;
clone = [];
while (i--) {
clone[i] = Ext.clone(item[i]);
}
}
else if (type === '[object Object]' && item.constructor === Object) {
clone = {};
for (key in item) {
clone[key] = Ext.clone(item[key]);
}
if (enumerables) {
for (j = enumerables.length; j--;) {
k = enumerables[j];
if (item.hasOwnProperty(k)) {
clone[k] = item[k];
}
}
}
}
return clone || item;
},
getUniqueGlobalNamespace: function() {
var uniqueGlobalNamespace = this.uniqueGlobalNamespace,
i;
if (uniqueGlobalNamespace === undefined) {
i = 0;
do {
uniqueGlobalNamespace = 'ExtBox' + (++i);
} while (Ext.global[uniqueGlobalNamespace] !== undefined);
Ext.global[uniqueGlobalNamespace] = Ext;
this.uniqueGlobalNamespace = uniqueGlobalNamespace;
}
return uniqueGlobalNamespace;
},
functionFactoryCache: {},
cacheableFunctionFactory: function() {
var me = this,
args = Array.prototype.slice.call(arguments),
cache = me.functionFactoryCache,
idx, fn, ln;
if (Ext.isSandboxed) {
ln = args.length;
if (ln > 0) {
ln--;
args[ln] = 'var Ext=window.' + Ext.name + ';' + args[ln];
}
}
idx = args.join('');
fn = cache[idx];
if (!fn) {
fn = Function.prototype.constructor.apply(Function.prototype, args);
cache[idx] = fn;
}
return fn;
},
functionFactory: function() {
var me = this,
args = Array.prototype.slice.call(arguments),
ln;
if (Ext.isSandboxed) {
ln = args.length;
if (ln > 0) {
ln--;
args[ln] = 'var Ext=window.' + Ext.name + ';' + args[ln];
}
}
return Function.prototype.constructor.apply(Function.prototype, args);
},
Logger: {
verbose: emptyFn,
log: emptyFn,
info: emptyFn,
warn: emptyFn,
error: function(message) {
throw new Error(message);
},
deprecate: emptyFn
}
});
Ext.type = Ext.typeOf;
ExtApp = Ext.app;
if (!ExtApp) {
ExtApp = Ext.app = {};
}
Ext.apply(ExtApp, {
namespaces: {},
collectNamespaces: function(paths) {
var namespaces = Ext.app.namespaces,
path;
for (path in paths) {
if (paths.hasOwnProperty(path)) {
namespaces[path] = true;
}
}
},
addNamespaces: function(ns) {
var namespaces = Ext.app.namespaces,
i, l;
if (!Ext.isArray(ns)) {
ns = [ns];
}
for (i = 0, l = ns.length; i < l; i++) {
namespaces[ns[i]] = true;
}
},
clearNamespaces: function() {
Ext.app.namespaces = {};
},
getNamespace: function(className) {
var namespaces    = Ext.app.namespaces,
deepestPrefix = '',
prefix;
for (prefix in namespaces) {
if (namespaces.hasOwnProperty(prefix)    &&
prefix.length > deepestPrefix.length &&
(prefix + '.' === className.substring(0, prefix.length + 1))) {
deepestPrefix = prefix;
}
}
return deepestPrefix === '' ? undefined : deepestPrefix;
}
});
}());
Ext.globalEval = Ext.global.execScript
? function(code) {
execScript(code);
}
: function($$code) {
(function(){
var Ext = this.Ext;
eval($$code);
}());
};
(function() {
var version = '4.2.2.1144',
checkVerTemp = [''],
endOfVersionRe = /([^\d\.])/,
notDigitsRe = /[^\d]/g,
plusMinusRe = /[\-+]/g,
stripRe = /\s/g,
underscoreRe = /_/g,
Version;
Ext.Version = Version = Ext.extend(Object, {
isVersion: true,
padModes: {
'~': NaN,
'^': Infinity
},
release: '',
constructor: function (version, defaultMode) {
var me = this,
padModes = me.padModes,
ch, i, pad, parts, release, releaseStartIndex, ver;
if (version.isVersion) {
return version;
}
me.version = ver = String(version).toLowerCase().
replace(underscoreRe, '.').replace(plusMinusRe, '');
ch = ver.charAt(0);
if (ch in padModes) {
ver = ver.substring(1);
pad = padModes[ch];
} else {
pad = defaultMode ? padModes[defaultMode] : 0; 
}
me.pad = pad;
releaseStartIndex = ver.search(endOfVersionRe);
me.shortVersion = ver;
if (releaseStartIndex !== -1) {
me.release = release = ver.substr(releaseStartIndex, version.length);
me.shortVersion = ver.substr(0, releaseStartIndex);
release = Version.releaseValueMap[release] || release;
}
me.releaseValue = release || pad;
me.shortVersion = me.shortVersion.replace(notDigitsRe, '');
me.parts = parts = ver.split('.');
for (i = parts.length; i--; ) {
parts[i] = parseInt(parts[i], 10);
}
if (pad === Infinity) {
parts.push(pad);
}
me.major = parts[0] || pad;
me.minor = parts[1] || pad;
me.patch = parts[2] || pad;
me.build = parts[3] || pad;
return me;
},
compareTo: function (other) {
var me = this,
lhsPad = me.pad,
lhsParts = me.parts,
lhsLength = lhsParts.length,
rhsVersion = other.isVersion ? other : new Version(other),
rhsPad = rhsVersion.pad,
rhsParts = rhsVersion.parts,
rhsLength = rhsParts.length,
length = Math.max(lhsLength, rhsLength),
i, lhs, rhs;
for (i = 0; i < length; i++) {
lhs = (i < lhsLength) ? lhsParts[i] : lhsPad;
rhs = (i < rhsLength) ? rhsParts[i] : rhsPad;
if (lhs < rhs) {
return -1;
}
if (lhs > rhs) {
return 1;
}
}
lhs = me.releaseValue;
rhs = rhsVersion.releaseValue;
if (lhs < rhs) {
return -1;
}
if (lhs > rhs) {
return 1;
}
return 0;
},
toString: function() {
return this.version;
},
valueOf: function() {
return this.version;
},
getMajor: function() {
return this.major;
},
getMinor: function() {
return this.minor;
},
getPatch: function() {
return this.patch;
},
getBuild: function() {
return this.build;
},
getRelease: function() {
return this.release;
},
getReleaseValue: function() {
return this.releaseValue;
},
isGreaterThan: function(target) {
return this.compareTo(target) > 0;
},
isGreaterThanOrEqual: function(target) {
return this.compareTo(target) >= 0;
},
isLessThan: function(target) {
return this.compareTo(target) < 0;
},
isLessThanOrEqual: function(target) {
return this.compareTo(target) <= 0;
},
equals: function(target) {
return this.compareTo(target) === 0;
},
match: function(target) {
target = String(target);
return this.version.substr(0, target.length) === target;
},
toArray: function() {
var me = this;
return [me.getMajor(), me.getMinor(), me.getPatch(), me.getBuild(), me.getRelease()];
},
getShortVersion: function() {
return this.shortVersion;
},
gt: function (target) {
return this.compareTo(target) > 0;
},
lt: function (target) {
return this.compareTo(target) < 0;
},
gtEq: function (target) {
return this.compareTo(target) >= 0;
},
ltEq: function (target) {
return this.compareTo(target) <= 0;
}
});
Ext.apply(Version, {
releaseValueMap: {
dev:   -6,
alpha: -5,
a:     -5,
beta:  -4,
b:     -4,
rc:    -3,
'#':   -2,
p:     -1,
pl:    -1
},
getComponentValue: function(value) {
return !value ? 0 : (isNaN(value) ? this.releaseValueMap[value] || value : parseInt(value, 10));
},
compare: function (current, target) {
var ver = current.isVersion ? current : new Version(current);
return ver.compareTo(target);
}
});
Ext.apply(Ext, {
versions: {},
lastRegisteredVersion: null,
setVersion: function(packageName, version) {
Ext.lastRegisteredVersion = Ext.versions[packageName] = new Version(version);
return this;
},
getVersion: function(packageName) {
if (packageName === undefined) {
return Ext.lastRegisteredVersion;
}
return Ext.versions[packageName];
},
checkVersion: function (specs, matchAll) {
var isArray = Ext.isArray(specs),
compat = isArray ? specs : checkVerTemp,
length = compat.length,
versions = Ext.versions,
frameworkVer = versions.ext || versions.touch,
i, index, matches, minVer, maxVer, spec, range, ver;
if (!isArray) {
checkVerTemp[0] = specs;
}
for (i = 0; i < length; ++i) {
if (!Ext.isString(spec = compat[i])) {
matches = Ext.checkVersion(spec.and || spec.or, !spec.or);
if (spec.not) {
matches = !matches;
}
} else {
if (spec.indexOf(' ') >= 0) {
spec = spec.replace(stripRe, '');
}
index = spec.indexOf('@');
if (index < 0) {
range = spec;
ver = frameworkVer;
} else {
if (!(ver = versions[spec.substring(0, index)])) {
if (matchAll) {
return false;
}
continue;
}
range = spec.substring(index+1);
}
index = range.indexOf('-');
if (index < 0) {
if (range.charAt(index = range.length - 1) === '+') {
minVer = range.substring(0, index);
maxVer = null;
} else {
minVer = maxVer = range;
}
} else if (index > 0) {
minVer = range.substring(0, index);
maxVer = range.substring(index+1); 
} else {
minVer = null;
maxVer = range.substring(index+1);
}
matches = true;
if (minVer) {
minVer = new Version(minVer, '~'); 
matches = minVer.ltEq(ver);
}
if (matches && maxVer) {
maxVer = new Version(maxVer, '~'); 
matches = maxVer.gtEq(ver);
}
} 
if (matches) {
if (!matchAll) {
return true;
}
} else if (matchAll) {
return false;
}
}
return !!matchAll;
},
deprecate: function(packageName, since, closure, scope) {
if (Version.compare(Ext.getVersion(packageName), since) < 1) {
closure.call(scope);
}
}
}); 
Ext.setVersion('core', version);
}());
Ext.String = (function() {
var trimRegex     = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g,
escapeRe      = /('|\\)/g,
formatRe      = /\{(\d+)\}/g,
escapeRegexRe = /([-.*+?\^${}()|\[\]\/\\])/g,
basicTrimRe   = /^\s+|\s+$/g,
whitespaceRe  = /\s+/,
varReplace    = /(^[^a-z]*|[^\w])/gi,
charToEntity,
entityToChar,
charToEntityRegex,
entityToCharRegex,
htmlEncodeReplaceFn = function(match, capture) {
return charToEntity[capture];
},
htmlDecodeReplaceFn = function(match, capture) {
return (capture in entityToChar) ? entityToChar[capture] : String.fromCharCode(parseInt(capture.substr(2), 10));
},
boundsCheck = function(s, other){
if (s === null || s === undefined || other === null || other === undefined) {
return false;
}
return other.length <= s.length; 
};
return {
insert: function(s, value, index) {
if (!s) {
return value;
}
if (!value) {
return s;
}
var len = s.length;
if (!index && index !== 0) {
index = len;
}
if (index < 0) {
index *= -1;
if (index >= len) {
index = 0;
} else {
index = len - index;
}
}
if (index === 0) {
s = value + s;
} else if (index >= s.length) {
s += value;
} else {
s = s.substr(0, index) + value + s.substr(index);
}
return s;
},
startsWith: function(s, start, ignoreCase){
var result = boundsCheck(s, start);
if (result) {
if (ignoreCase) {
s = s.toLowerCase();
start = start.toLowerCase();
}
result = s.lastIndexOf(start, 0) === 0;
}
return result;
},
endsWith: function(s, end, ignoreCase){
var result = boundsCheck(s, end);
if (result) {
if (ignoreCase) {
s = s.toLowerCase();
end = end.toLowerCase();
}
result = s.indexOf(end, s.length - end.length) !== -1;
}
return result;
},
createVarName: function(s) {
return s.replace(varReplace, '');
},
htmlEncode: function(value) {
return (!value) ? value : String(value).replace(charToEntityRegex, htmlEncodeReplaceFn);
},
htmlDecode: function(value) {
return (!value) ? value : String(value).replace(entityToCharRegex, htmlDecodeReplaceFn);
},
hasHtmlCharacters: function(s) {
return charToEntityRegex.test(s);
},
addCharacterEntities: function(newEntities) {
var charKeys = [],
entityKeys = [],
key, echar;
for (key in newEntities) {
echar = newEntities[key];
entityToChar[key] = echar;
charToEntity[echar] = key;
charKeys.push(echar);
entityKeys.push(key);
}
charToEntityRegex = new RegExp('(' + charKeys.join('|') + ')', 'g');
entityToCharRegex = new RegExp('(' + entityKeys.join('|') + '|&#[0-9]{1,5};' + ')', 'g');
},
resetCharacterEntities: function() {
charToEntity = {};
entityToChar = {};
this.addCharacterEntities({
'&amp;'     :   '&',
'&gt;'      :   '>',
'&lt;'      :   '<',
'&quot;'    :   '"',
'&#39;'     :   "'"
});
},
urlAppend : function(url, string) {
if (!Ext.isEmpty(string)) {
return url + (url.indexOf('?') === -1 ? '?' : '&') + string;
}
return url;
},
trim: function(string) {
return string.replace(trimRegex, "");
},
capitalize: function(string) {
return string.charAt(0).toUpperCase() + string.substr(1);
},
uncapitalize: function(string) {
return string.charAt(0).toLowerCase() + string.substr(1);
},
ellipsis: function(value, len, word) {
if (value && value.length > len) {
if (word) {
var vs = value.substr(0, len - 2),
index = Math.max(vs.lastIndexOf(' '), vs.lastIndexOf('.'), vs.lastIndexOf('!'), vs.lastIndexOf('?'));
if (index !== -1 && index >= (len - 15)) {
return vs.substr(0, index) + "...";
}
}
return value.substr(0, len - 3) + "...";
}
return value;
},
escapeRegex: function(string) {
return string.replace(escapeRegexRe, "\\$1");
},
escape: function(string) {
return string.replace(escapeRe, "\\$1");
},
toggle: function(string, value, other) {
return string === value ? other : value;
},
leftPad: function(string, size, character) {
var result = String(string);
character = character || " ";
while (result.length < size) {
result = character + result;
}
return result;
},
format: function(format) {
var args = Ext.Array.toArray(arguments, 1);
return format.replace(formatRe, function(m, i) {
return args[i];
});
},
repeat: function(pattern, count, sep) {
if (count < 1) {
count = 0;
}
for (var buf = [], i = count; i--; ) {
buf.push(pattern);
}
return buf.join(sep || '');
},
splitWords: function (words) {
if (words && typeof words == 'string') {
return words.replace(basicTrimRe, '').split(whitespaceRe);
}
return words || [];
}
};
}());
Ext.String.resetCharacterEntities();
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend;
Ext.Number = new function() {
var me = this,
isToFixedBroken = (0.9).toFixed() !== '1',
math = Math;
Ext.apply(this, {
constrain: function(number, min, max) {
var x = parseFloat(number);
return (x < min) ? min : ((x > max) ? max : x);
},
snap : function(value, increment, minValue, maxValue) {
var m;
if (value === undefined || value < minValue) {
return minValue || 0;
}
if (increment) {
m = value % increment;
if (m !== 0) {
value -= m;
if (m * 2 >= increment) {
value += increment;
} else if (m * 2 < -increment) {
value -= increment;
}
}
}
return me.constrain(value, minValue,  maxValue);
},
snapInRange : function(value, increment, minValue, maxValue) {
var tween;
minValue = (minValue || 0);
if (value === undefined || value < minValue) {
return minValue;
}
if (increment && (tween = ((value - minValue) % increment))) {
value -= tween;
tween *= 2;
if (tween >= increment) {
value += increment;
}
}
if (maxValue !== undefined) {
if (value > (maxValue = me.snapInRange(maxValue, increment, minValue))) {
value = maxValue;
}
}
return value;
},
toFixed: isToFixedBroken ? function(value, precision) {
precision = precision || 0;
var pow = math.pow(10, precision);
return (math.round(value * pow) / pow).toFixed(precision);
} : function(value, precision) {
return value.toFixed(precision);
},
from: function(value, defaultValue) {
if (isFinite(value)) {
value = parseFloat(value);
}
return !isNaN(value) ? value : defaultValue;
},
randomInt: function (from, to) {
return math.floor(math.random() * (to - from + 1) + from);
},
correctFloat: function(n) {
return parseFloat(n.toPrecision(14));
}
});
Ext.num = function() {
return me.from.apply(this, arguments);
};
};
(function() {
var arrayPrototype = Array.prototype,
slice = arrayPrototype.slice,
supportsSplice = (function () {
var array = [],
lengthBefore,
j = 20;
if (!array.splice) {
return false;
}
while (j--) {
array.push("A");
}
array.splice(15, 0, "F", "F", "F", "F", "F","F","F","F","F","F","F","F","F","F","F","F","F","F","F","F","F");
lengthBefore = array.length; 
array.splice(13, 0, "XXX"); 
if (lengthBefore+1 != array.length) {
return false;
}
return true;
}()),
supportsForEach = 'forEach' in arrayPrototype,
supportsMap = 'map' in arrayPrototype,
supportsIndexOf = 'indexOf' in arrayPrototype,
supportsEvery = 'every' in arrayPrototype,
supportsSome = 'some' in arrayPrototype,
supportsFilter = 'filter' in arrayPrototype,
supportsSort = (function() {
var a = [1,2,3,4,5].sort(function(){ return 0; });
return a[0] === 1 && a[1] === 2 && a[2] === 3 && a[3] === 4 && a[4] === 5;
}()),
supportsSliceOnNodeList = true,
ExtArray,
erase,
replace,
splice;
try {
if (typeof document !== 'undefined') {
slice.call(document.getElementsByTagName('body'));
}
} catch (e) {
supportsSliceOnNodeList = false;
}
function fixArrayIndex (array, index) {
return (index < 0) ? Math.max(0, array.length + index)
: Math.min(array.length, index);
}
function replaceSim (array, index, removeCount, insert) {
var add = insert ? insert.length : 0,
length = array.length,
pos = fixArrayIndex(array, index),
remove,
tailOldPos,
tailNewPos,
tailCount,
lengthAfterRemove,
i;
if (pos === length) {
if (add) {
array.push.apply(array, insert);
}
} else {
remove = Math.min(removeCount, length - pos);
tailOldPos = pos + remove;
tailNewPos = tailOldPos + add - remove;
tailCount = length - tailOldPos;
lengthAfterRemove = length - remove;
if (tailNewPos < tailOldPos) { 
for (i = 0; i < tailCount; ++i) {
array[tailNewPos+i] = array[tailOldPos+i];
}
} else if (tailNewPos > tailOldPos) { 
for (i = tailCount; i--; ) {
array[tailNewPos+i] = array[tailOldPos+i];
}
} 
if (add && pos === lengthAfterRemove) {
array.length = lengthAfterRemove; 
array.push.apply(array, insert);
} else {
array.length = lengthAfterRemove + add; 
for (i = 0; i < add; ++i) {
array[pos+i] = insert[i];
}
}
}
return array;
}
function replaceNative (array, index, removeCount, insert) {
if (insert && insert.length) {
if (index === 0 && !removeCount) {
array.unshift.apply(array, insert);
}
else if (index < array.length) {
array.splice.apply(array, [index, removeCount].concat(insert));
}
else {
array.push.apply(array, insert);
}
} else {
array.splice(index, removeCount);
}
return array;
}
function eraseSim (array, index, removeCount) {
return replaceSim(array, index, removeCount);
}
function eraseNative (array, index, removeCount) {
array.splice(index, removeCount);
return array;
}
function spliceSim (array, index, removeCount) {
var pos = fixArrayIndex(array, index),
removed = array.slice(index, fixArrayIndex(array, pos+removeCount));
if (arguments.length < 4) {
replaceSim(array, pos, removeCount);
} else {
replaceSim(array, pos, removeCount, slice.call(arguments, 3));
}
return removed;
}
function spliceNative (array) {
return array.splice.apply(array, slice.call(arguments, 1));
}
erase = supportsSplice ? eraseNative : eraseSim;
replace = supportsSplice ? replaceNative : replaceSim;
splice = supportsSplice ? spliceNative : spliceSim;
ExtArray = Ext.Array = {
each: function(array, fn, scope, reverse) {
array = ExtArray.from(array);
var i,
ln = array.length;
if (reverse !== true) {
for (i = 0; i < ln; i++) {
if (fn.call(scope || array[i], array[i], i, array) === false) {
return i;
}
}
}
else {
for (i = ln - 1; i > -1; i--) {
if (fn.call(scope || array[i], array[i], i, array) === false) {
return i;
}
}
}
return true;
},
forEach: supportsForEach ? function(array, fn, scope) {
array.forEach(fn, scope);
} : function(array, fn, scope) {
var i = 0,
ln = array.length;
for (; i < ln; i++) {
fn.call(scope, array[i], i, array);
}
},
indexOf: supportsIndexOf ? function(array, item, from) {
return arrayPrototype.indexOf.call(array, item, from);
} : function(array, item, from) {
var i, length = array.length;
for (i = (from < 0) ? Math.max(0, length + from) : from || 0; i < length; i++) {
if (array[i] === item) {
return i;
}
}
return -1;
},
contains: supportsIndexOf ? function(array, item) {
return arrayPrototype.indexOf.call(array, item) !== -1;
} : function(array, item) {
var i, ln;
for (i = 0, ln = array.length; i < ln; i++) {
if (array[i] === item) {
return true;
}
}
return false;
},
toArray: function(iterable, start, end){
if (!iterable || !iterable.length) {
return [];
}
if (typeof iterable === 'string') {
iterable = iterable.split('');
}
if (supportsSliceOnNodeList) {
return slice.call(iterable, start || 0, end || iterable.length);
}
var array = [],
i;
start = start || 0;
end = end ? ((end < 0) ? iterable.length + end : end) : iterable.length;
for (i = start; i < end; i++) {
array.push(iterable[i]);
}
return array;
},
pluck: function(array, propertyName) {
var ret = [],
i, ln, item;
for (i = 0, ln = array.length; i < ln; i++) {
item = array[i];
ret.push(item[propertyName]);
}
return ret;
},
map: supportsMap ? function(array, fn, scope) {
return array.map(fn, scope);
} : function(array, fn, scope) {
var results = [],
i = 0,
len = array.length;
for (; i < len; i++) {
results[i] = fn.call(scope, array[i], i, array);
}
return results;
},
every: supportsEvery ? function(array, fn, scope) {
return array.every(fn, scope);
} : function(array, fn, scope) {
var i = 0,
ln = array.length;
for (; i < ln; ++i) {
if (!fn.call(scope, array[i], i, array)) {
return false;
}
}
return true;
},
some: supportsSome ? function(array, fn, scope) {
return array.some(fn, scope);
} : function(array, fn, scope) {
var i = 0,
ln = array.length;
for (; i < ln; ++i) {
if (fn.call(scope, array[i], i, array)) {
return true;
}
}
return false;
},
equals: function(array1, array2) {
var len1 = array1.length,
len2 = array2.length,
i;
if (array1 === array2) {
return true;
}
if (len1 !== len2) {
return false;
}
for (i = 0; i < len1; ++i) {
if (array1[i] !== array2[i]) {
return false;
}
}
return true;
},
clean: function(array) {
var results = [],
i = 0,
ln = array.length,
item;
for (; i < ln; i++) {
item = array[i];
if (!Ext.isEmpty(item)) {
results.push(item);
}
}
return results;
},
unique: function(array) {
var clone = [],
i = 0,
ln = array.length,
item;
for (; i < ln; i++) {
item = array[i];
if (ExtArray.indexOf(clone, item) === -1) {
clone.push(item);
}
}
return clone;
},
filter: supportsFilter ? function(array, fn, scope) {
return array.filter(fn, scope);
} : function(array, fn, scope) {
var results = [],
i = 0,
ln = array.length;
for (; i < ln; i++) {
if (fn.call(scope, array[i], i, array)) {
results.push(array[i]);
}
}
return results;
},
findBy : function(array, fn, scope) {
var i = 0,
len = array.length;
for (; i < len; i++) {
if (fn.call(scope || array, array[i], i)) {
return array[i];
}
}
return null;
},
from: function(value, newReference) {
if (value === undefined || value === null) {
return [];
}
if (Ext.isArray(value)) {
return (newReference) ? slice.call(value) : value;
}
var type = typeof value;
if (value && value.length !== undefined && type !== 'string' && (type !== 'function' || !value.apply)) {
return ExtArray.toArray(value);
}
return [value];
},
remove: function(array, item) {
var index = ExtArray.indexOf(array, item);
if (index !== -1) {
erase(array, index, 1);
}
return array;
},
include: function(array, item) {
if (!ExtArray.contains(array, item)) {
array.push(item);
}
},
clone: function(array) {
return slice.call(array);
},
merge: function() {
var args = slice.call(arguments),
array = [],
i, ln;
for (i = 0, ln = args.length; i < ln; i++) {
array = array.concat(args[i]);
}
return ExtArray.unique(array);
},
intersect: function() {
var intersection = [],
arrays = slice.call(arguments),
arraysLength,
array,
arrayLength,
minArray,
minArrayIndex,
minArrayCandidate,
minArrayLength,
element,
elementCandidate,
elementCount,
i, j, k;
if (!arrays.length) {
return intersection;
}
arraysLength = arrays.length;
for (i = minArrayIndex = 0; i < arraysLength; i++) {
minArrayCandidate = arrays[i];
if (!minArray || minArrayCandidate.length < minArray.length) {
minArray = minArrayCandidate;
minArrayIndex = i;
}
}
minArray = ExtArray.unique(minArray);
erase(arrays, minArrayIndex, 1);
minArrayLength = minArray.length;
arraysLength = arrays.length;
for (i = 0; i < minArrayLength; i++) {
element = minArray[i];
elementCount = 0;
for (j = 0; j < arraysLength; j++) {
array = arrays[j];
arrayLength = array.length;
for (k = 0; k < arrayLength; k++) {
elementCandidate = array[k];
if (element === elementCandidate) {
elementCount++;
break;
}
}
}
if (elementCount === arraysLength) {
intersection.push(element);
}
}
return intersection;
},
difference: function(arrayA, arrayB) {
var clone = slice.call(arrayA),
ln = clone.length,
i, j, lnB;
for (i = 0,lnB = arrayB.length; i < lnB; i++) {
for (j = 0; j < ln; j++) {
if (clone[j] === arrayB[i]) {
erase(clone, j, 1);
j--;
ln--;
}
}
}
return clone;
},
slice: ([1,2].slice(1, undefined).length ?
function (array, begin, end) {
return slice.call(array, begin, end);
} :
function (array, begin, end) {
if (typeof begin === 'undefined') {
return slice.call(array);
}
if (typeof end === 'undefined') {
return slice.call(array, begin);
}
return slice.call(array, begin, end);
}
),
sort: supportsSort ? function(array, sortFn) {
if (sortFn) {
return array.sort(sortFn);
} else {
return array.sort();
}
} : function(array, sortFn) {
var length = array.length,
i = 0,
comparison,
j, min, tmp;
for (; i < length; i++) {
min = i;
for (j = i + 1; j < length; j++) {
if (sortFn) {
comparison = sortFn(array[j], array[min]);
if (comparison < 0) {
min = j;
}
} else if (array[j] < array[min]) {
min = j;
}
}
if (min !== i) {
tmp = array[i];
array[i] = array[min];
array[min] = tmp;
}
}
return array;
},
flatten: function(array) {
var worker = [];
function rFlatten(a) {
var i, ln, v;
for (i = 0, ln = a.length; i < ln; i++) {
v = a[i];
if (Ext.isArray(v)) {
rFlatten(v);
} else {
worker.push(v);
}
}
return worker;
}
return rFlatten(array);
},
min: function(array, comparisonFn) {
var min = array[0],
i, ln, item;
for (i = 0, ln = array.length; i < ln; i++) {
item = array[i];
if (comparisonFn) {
if (comparisonFn(min, item) === 1) {
min = item;
}
}
else {
if (item < min) {
min = item;
}
}
}
return min;
},
max: function(array, comparisonFn) {
var max = array[0],
i, ln, item;
for (i = 0, ln = array.length; i < ln; i++) {
item = array[i];
if (comparisonFn) {
if (comparisonFn(max, item) === -1) {
max = item;
}
}
else {
if (item > max) {
max = item;
}
}
}
return max;
},
mean: function(array) {
return array.length > 0 ? ExtArray.sum(array) / array.length : undefined;
},
sum: function(array) {
var sum = 0,
i, ln, item;
for (i = 0,ln = array.length; i < ln; i++) {
item = array[i];
sum += item;
}
return sum;
},
toMap: function(array, getKey, scope) {
var map = {},
i = array.length;
if (!getKey) {
while (i--) {
map[array[i]] = i+1;
}
} else if (typeof getKey == 'string') {
while (i--) {
map[array[i][getKey]] = i+1;
}
} else {
while (i--) {
map[getKey.call(scope, array[i])] = i+1;
}
}
return map;
},
toValueMap: function(array, getKey, scope) {
var map = {},
i = array.length;
if (!getKey) {
while (i--) {
map[array[i]] = array[i];
}
} else if (typeof getKey == 'string') {
while (i--) {
map[array[i][getKey]] = array[i];
}
} else {
while (i--) {
map[getKey.call(scope, array[i])] = array[i];
}
}
return map;
},
erase: erase,
insert: function (array, index, items) {
return replace(array, index, 0, items);
},
replace: replace,
splice: splice,
push: function(array) {
var len = arguments.length,
i = 1,
newItem;
if (array === undefined) {
array = [];
} else if (!Ext.isArray(array)) {
array = [array];
}
for (; i < len; i++) {
newItem = arguments[i];
Array.prototype.push[Ext.isIterable(newItem) ? 'apply' : 'call'](array, newItem);
}
return array;
}
};
Ext.each = ExtArray.each;
ExtArray.union = ExtArray.merge;
Ext.min = ExtArray.min;
Ext.max = ExtArray.max;
Ext.sum = ExtArray.sum;
Ext.mean = ExtArray.mean;
Ext.flatten = ExtArray.flatten;
Ext.clean = ExtArray.clean;
Ext.unique = ExtArray.unique;
Ext.pluck = ExtArray.pluck;
Ext.toArray = function() {
return ExtArray.toArray.apply(ExtArray, arguments);
};
}());
Ext.Function = {
flexSetter: function(fn) {
return function(a, b) {
var k, i;
if (a === null) {
return this;
}
if (typeof a !== 'string') {
for (k in a) {
if (a.hasOwnProperty(k)) {
fn.call(this, k, a[k]);
}
}
if (Ext.enumerables) {
for (i = Ext.enumerables.length; i--;) {
k = Ext.enumerables[i];
if (a.hasOwnProperty(k)) {
fn.call(this, k, a[k]);
}
}
}
} else {
fn.call(this, a, b);
}
return this;
};
},
bind: function(fn, scope, args, appendArgs) {
if (arguments.length === 2) {
return function() {
return fn.apply(scope, arguments);
};
}
var method = fn,
slice = Array.prototype.slice;
return function() {
var callArgs = args || arguments;
if (appendArgs === true) {
callArgs = slice.call(arguments, 0);
callArgs = callArgs.concat(args);
}
else if (typeof appendArgs == 'number') {
callArgs = slice.call(arguments, 0); 
Ext.Array.insert(callArgs, appendArgs, args);
}
return method.apply(scope || Ext.global, callArgs);
};
},
pass: function(fn, args, scope) {
if (!Ext.isArray(args)) {
if (Ext.isIterable(args)) {
args = Ext.Array.clone(args);
} else {
args = args !== undefined ? [args] : [];
}
}
return function() {
var fnArgs = [].concat(args);
fnArgs.push.apply(fnArgs, arguments);
return fn.apply(scope || this, fnArgs);
};
},
alias: function(object, methodName) {
return function() {
return object[methodName].apply(object, arguments);
};
},
clone: function(method) {
return function() {
return method.apply(this, arguments);
};
},
createInterceptor: function(origFn, newFn, scope, returnValue) {
var method = origFn;
if (!Ext.isFunction(newFn)) {
return origFn;
} else {
returnValue = Ext.isDefined(returnValue) ? returnValue : null;
return function() {
var me = this,
args = arguments;
newFn.target = me;
newFn.method = origFn;
return (newFn.apply(scope || me || Ext.global, args) !== false) ? origFn.apply(me || Ext.global, args) : returnValue;
};
}
},
createDelayed: function(fn, delay, scope, args, appendArgs) {
if (scope || args) {
fn = Ext.Function.bind(fn, scope, args, appendArgs);
}
return function() {
var me = this,
args = Array.prototype.slice.call(arguments);
setTimeout(function() {
fn.apply(me, args);
}, delay);
};
},
defer: function(fn, millis, scope, args, appendArgs) {
fn = Ext.Function.bind(fn, scope, args, appendArgs);
if (millis > 0) {
return setTimeout(Ext.supports.TimeoutActualLateness ? function () {
fn();
} : fn, millis);
}
fn();
return 0;
},
createSequence: function(originalFn, newFn, scope) {
if (!newFn) {
return originalFn;
}
else {
return function() {
var result = originalFn.apply(this, arguments);
newFn.apply(scope || this, arguments);
return result;
};
}
},
createBuffered: function(fn, buffer, scope, args) {
var timerId;
return function() {
var callArgs = args || Array.prototype.slice.call(arguments, 0),
me = scope || this;
if (timerId) {
clearTimeout(timerId);
}
timerId = setTimeout(function(){
fn.apply(me, callArgs);
}, buffer);
};
},
createThrottled: function(fn, interval, scope) {
var lastCallTime, elapsed, lastArgs, timer, execute = function() {
fn.apply(scope || this, lastArgs);
lastCallTime = Ext.Date.now();
};
return function() {
elapsed = Ext.Date.now() - lastCallTime;
lastArgs = arguments;
clearTimeout(timer);
if (!lastCallTime || (elapsed >= interval)) {
execute();
} else {
timer = setTimeout(execute, interval - elapsed);
}
};
},
interceptBefore: function(object, methodName, fn, scope) {
var method = object[methodName] || Ext.emptyFn;
return (object[methodName] = function() {
var ret = fn.apply(scope || this, arguments);
method.apply(this, arguments);
return ret;
});
},
interceptAfter: function(object, methodName, fn, scope) {
var method = object[methodName] || Ext.emptyFn;
return (object[methodName] = function() {
method.apply(this, arguments);
return fn.apply(scope || this, arguments);
});
}
};
Ext.defer = Ext.Function.alias(Ext.Function, 'defer');
Ext.pass = Ext.Function.alias(Ext.Function, 'pass');
Ext.bind = Ext.Function.alias(Ext.Function, 'bind');
(function() {
var TemplateClass = function(){},
ExtObject = Ext.Object = {
chain: Object.create || function (object) {
TemplateClass.prototype = object;
var result = new TemplateClass();
TemplateClass.prototype = null;
return result;
},
clear: function (object) {
var keys = ExtObject.getKeys(object),
n = keys.length;
while (n--) {
delete object[keys[n]];
}
return object;
},
toQueryObjects: function(name, value, recursive) {
var self = ExtObject.toQueryObjects,
objects = [],
i, ln;
if (Ext.isArray(value)) {
for (i = 0, ln = value.length; i < ln; i++) {
if (recursive) {
objects = objects.concat(self(name + '[' + i + ']', value[i], true));
}
else {
objects.push({
name: name,
value: value[i]
});
}
}
}
else if (Ext.isObject(value)) {
for (i in value) {
if (value.hasOwnProperty(i)) {
if (recursive) {
objects = objects.concat(self(name + '[' + i + ']', value[i], true));
}
else {
objects.push({
name: name,
value: value[i]
});
}
}
}
}
else {
objects.push({
name: name,
value: value
});
}
return objects;
},
toQueryString: function(object, recursive) {
var paramObjects = [],
params = [],
i, j, ln, paramObject, value;
for (i in object) {
if (object.hasOwnProperty(i)) {
paramObjects = paramObjects.concat(ExtObject.toQueryObjects(i, object[i], recursive));
}
}
for (j = 0, ln = paramObjects.length; j < ln; j++) {
paramObject = paramObjects[j];
value = paramObject.value;
if (Ext.isEmpty(value)) {
value = '';
} else if (Ext.isDate(value)) {
value = Ext.Date.toString(value);
}
params.push(encodeURIComponent(paramObject.name) + '=' + encodeURIComponent(String(value)));
}
return params.join('&');
},
fromQueryString: function(queryString, recursive) {
var parts = queryString.replace(/^\?/, '').split('&'),
object = {},
temp, components, name, value, i, ln,
part, j, subLn, matchedKeys, matchedName,
keys, key, nextKey;
for (i = 0, ln = parts.length; i < ln; i++) {
part = parts[i];
if (part.length > 0) {
components = part.split('=');
name = decodeURIComponent(components[0]);
value = (components[1] !== undefined) ? decodeURIComponent(components[1]) : '';
if (!recursive) {
if (object.hasOwnProperty(name)) {
if (!Ext.isArray(object[name])) {
object[name] = [object[name]];
}
object[name].push(value);
}
else {
object[name] = value;
}
}
else {
matchedKeys = name.match(/(\[):?([^\]]*)\]/g);
matchedName = name.match(/^([^\[]+)/);
name = matchedName[0];
keys = [];
if (matchedKeys === null) {
object[name] = value;
continue;
}
for (j = 0, subLn = matchedKeys.length; j < subLn; j++) {
key = matchedKeys[j];
key = (key.length === 2) ? '' : key.substring(1, key.length - 1);
keys.push(key);
}
keys.unshift(name);
temp = object;
for (j = 0, subLn = keys.length; j < subLn; j++) {
key = keys[j];
if (j === subLn - 1) {
if (Ext.isArray(temp) && key === '') {
temp.push(value);
}
else {
temp[key] = value;
}
}
else {
if (temp[key] === undefined || typeof temp[key] === 'string') {
nextKey = keys[j+1];
temp[key] = (Ext.isNumeric(nextKey) || nextKey === '') ? [] : {};
}
temp = temp[key];
}
}
}
}
}
return object;
},
each: function(object, fn, scope) {
for (var property in object) {
if (object.hasOwnProperty(property)) {
if (fn.call(scope || object, property, object[property], object) === false) {
return;
}
}
}
},
merge: function(destination) {
var i = 1,
ln = arguments.length,
mergeFn = ExtObject.merge,
cloneFn = Ext.clone,
object, key, value, sourceKey;
for (; i < ln; i++) {
object = arguments[i];
for (key in object) {
value = object[key];
if (value && value.constructor === Object) {
sourceKey = destination[key];
if (sourceKey && sourceKey.constructor === Object) {
mergeFn(sourceKey, value);
}
else {
destination[key] = cloneFn(value);
}
}
else {
destination[key] = value;
}
}
}
return destination;
},
mergeIf: function(destination) {
var i = 1,
ln = arguments.length,
cloneFn = Ext.clone,
object, key, value;
for (; i < ln; i++) {
object = arguments[i];
for (key in object) {
if (!(key in destination)) {
value = object[key];
if (value && value.constructor === Object) {
destination[key] = cloneFn(value);
}
else {
destination[key] = value;
}
}
}
}
return destination;
},
getKey: function(object, value) {
for (var property in object) {
if (object.hasOwnProperty(property) && object[property] === value) {
return property;
}
}
return null;
},
getValues: function(object) {
var values = [],
property;
for (property in object) {
if (object.hasOwnProperty(property)) {
values.push(object[property]);
}
}
return values;
},
getKeys: (typeof Object.keys == 'function')
? function(object){
if (!object) {
return [];
}
return Object.keys(object);
}
: function(object) {
var keys = [],
property;
for (property in object) {
if (object.hasOwnProperty(property)) {
keys.push(property);
}
}
return keys;
},
getSize: function(object) {
var size = 0,
property;
for (property in object) {
if (object.hasOwnProperty(property)) {
size++;
}
}
return size;
},
isEmpty: function(object){
for (var key in object) {
if (object.hasOwnProperty(key)) {
return false;
}
}
return true;    
},
equals: (function() {
var check = function(o1, o2) {
var key;
for (key in o1) {
if (o1.hasOwnProperty(key)) {
if (o1[key] !== o2[key]) {
return false;
}    
}
}    
return true;
};
return function(object1, object2) {
if (object1 === object2) {
return true;
} if (object1 && object2) {
return check(object1, object2) && check(object2, object1);  
} else if (!object1 && !object2) {
return object1 === object2;
} else {
return false;
}
};
})(),
classify: function(object) {
var prototype = object,
objectProperties = [],
propertyClassesMap = {},
objectClass = function() {
var i = 0,
ln = objectProperties.length,
property;
for (; i < ln; i++) {
property = objectProperties[i];
this[property] = new propertyClassesMap[property]();
}
},
key, value;
for (key in object) {
if (object.hasOwnProperty(key)) {
value = object[key];
if (value && value.constructor === Object) {
objectProperties.push(key);
propertyClassesMap[key] = ExtObject.classify(value);
}
}
}
objectClass.prototype = prototype;
return objectClass;
}
};
Ext.merge = Ext.Object.merge;
Ext.mergeIf = Ext.Object.mergeIf;
Ext.urlEncode = function() {
var args = Ext.Array.from(arguments),
prefix = '';
if ((typeof args[1] === 'string')) {
prefix = args[1] + '&';
args[1] = false;
}
return prefix + ExtObject.toQueryString.apply(ExtObject, args);
};
Ext.urlDecode = function() {
return ExtObject.fromQueryString.apply(ExtObject, arguments);
};
}());
Ext.Date = new function() {
var utilDate = this,
stripEscapeRe = /(\\.)/g,
hourInfoRe = /([gGhHisucUOPZ]|MS)/,
dateInfoRe = /([djzmnYycU]|MS)/,
slashRe = /\\/gi,
numberTokenRe = /\{(\d+)\}/g,
MSFormatRe = new RegExp('\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/'),
code = [
"var me = this, dt, y, m, d, h, i, s, ms, o, O, z, zz, u, v, W, year, jan4, week1monday, daysInMonth, dayMatched,",
"def = me.defaults,",
"from = Ext.Number.from,",
"results = String(input).match(me.parseRegexes[{0}]);", 
"if(results){",
"{1}",
"if(u != null){", 
"v = new Date(u * 1000);", 
"}else{",
"dt = me.clearTime(new Date);",
"y = from(y, from(def.y, dt.getFullYear()));",
"m = from(m, from(def.m - 1, dt.getMonth()));",
"dayMatched = d !== undefined;",
"d = from(d, from(def.d, dt.getDate()));",
"if (!dayMatched) {", 
"dt.setDate(1);",
"dt.setMonth(m);",
"dt.setFullYear(y);",
"daysInMonth = me.getDaysInMonth(dt);",
"if (d > daysInMonth) {",
"d = daysInMonth;",
"}",
"}",
"h  = from(h, from(def.h, dt.getHours()));",
"i  = from(i, from(def.i, dt.getMinutes()));",
"s  = from(s, from(def.s, dt.getSeconds()));",
"ms = from(ms, from(def.ms, dt.getMilliseconds()));",
"if(z >= 0 && y >= 0){",
"v = me.add(new Date(y < 100 ? 100 : y, 0, 1, h, i, s, ms), me.YEAR, y < 100 ? y - 100 : 0);",
"v = !strict? v : (strict === true && (z <= 364 || (me.isLeapYear(v) && z <= 365))? me.add(v, me.DAY, z) : null);",
"}else if(strict === true && !me.isValid(y, m + 1, d, h, i, s, ms)){", 
"v = null;", 
"}else{",
"if (W) {", 
"year = y || (new Date()).getFullYear(),",
"jan4 = new Date(year, 0, 4, 0, 0, 0),",
"week1monday = new Date(jan4.getTime() - ((jan4.getDay() - 1) * 86400000));",
"v = Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000)));",
"} else {",
"v = me.add(new Date(y < 100 ? 100 : y, m, d, h, i, s, ms), me.YEAR, y < 100 ? y - 100 : 0);",
"}",
"}",
"}",
"}",
"if(v){",
"if(zz != null){",
"v = me.add(v, me.SECOND, -v.getTimezoneOffset() * 60 - zz);",
"}else if(o){",
"v = me.add(v, me.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));",
"}",
"}",
"return v;"
].join('\n');
function xf(format) {
var args = Array.prototype.slice.call(arguments, 1);
return format.replace(numberTokenRe, function(m, i) {
return args[i];
});
}
Ext.apply(utilDate, {
now: Date.now || function() {
return +new Date();
},
toString: function(date) {
var pad = Ext.String.leftPad;
return date.getFullYear() + "-"
+ pad(date.getMonth() + 1, 2, '0') + "-"
+ pad(date.getDate(), 2, '0') + "T"
+ pad(date.getHours(), 2, '0') + ":"
+ pad(date.getMinutes(), 2, '0') + ":"
+ pad(date.getSeconds(), 2, '0');
},
getElapsed: function(dateA, dateB) {
return Math.abs(dateA - (dateB || utilDate.now()));
},
useStrict: false,
formatCodeToRegex: function(character, currentGroup) {
var p = utilDate.parseCodes[character];
if (p) {
p = typeof p == 'function'? p() : p;
utilDate.parseCodes[character] = p; 
}
return p ? Ext.applyIf({
c: p.c ? xf(p.c, currentGroup || "{0}") : p.c
}, p) : {
g: 0,
c: null,
s: Ext.String.escapeRegex(character) 
};
},
parseFunctions: {
"MS": function(input, strict) {
var r = (input || '').match(MSFormatRe);
return r ? new Date(((r[1] || '') + r[2]) * 1) : null;
},
"time": function(input, strict) {
var num = parseInt(input, 10);
if (num || num === 0) {
return new Date(num);
}
return null;
},
"timestamp": function(input, strict) {
var num = parseInt(input, 10);
if (num || num === 0) {
return new Date(num * 1000);
}
return null;
}
},
parseRegexes: [],
formatFunctions: {
"MS": function() {
return '\\/Date(' + this.getTime() + ')\\/';
},
"time": function(){
return this.getTime().toString();
},
"timestamp": function(){
return utilDate.format(this, 'U');
}
},
y2kYear : 50,
MILLI : "ms",
SECOND : "s",
MINUTE : "mi",
HOUR : "h",
DAY : "d",
MONTH : "mo",
YEAR : "y",
defaults: {},
dayNames : [
"Sunday",
"Monday",
"Tuesday",
"Wednesday",
"Thursday",
"Friday",
"Saturday"
],
monthNames : [
"January",
"February",
"March",
"April",
"May",
"June",
"July",
"August",
"September",
"October",
"November",
"December"
],
monthNumbers : {
January: 0,
Jan: 0,
February: 1,
Feb: 1,
March: 2,
Mar: 2,
April: 3,
Apr: 3,
May: 4,
June: 5,
Jun: 5,
July: 6,
Jul: 6,
August: 7,
Aug: 7,
September: 8,
Sep: 8,
October: 9,
Oct: 9,
November: 10,
Nov: 10,
December: 11,
Dec: 11
},
defaultFormat : "m/d/Y",
getShortMonthName : function(month) {
return Ext.Date.monthNames[month].substring(0, 3);
},
getShortDayName : function(day) {
return Ext.Date.dayNames[day].substring(0, 3);
},
getMonthNumber : function(name) {
return Ext.Date.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
},
formatContainsHourInfo : function(format){
return hourInfoRe.test(format.replace(stripEscapeRe, ''));
},
formatContainsDateInfo : function(format){
return dateInfoRe.test(format.replace(stripEscapeRe, ''));
},
unescapeFormat: function(format) {
return format.replace(slashRe, '');
},
formatCodes : {
d: "Ext.String.leftPad(this.getDate(), 2, '0')",
D: "Ext.Date.getShortDayName(this.getDay())", 
j: "this.getDate()",
l: "Ext.Date.dayNames[this.getDay()]",
N: "(this.getDay() ? this.getDay() : 7)",
S: "Ext.Date.getSuffix(this)",
w: "this.getDay()",
z: "Ext.Date.getDayOfYear(this)",
W: "Ext.String.leftPad(Ext.Date.getWeekOfYear(this), 2, '0')",
F: "Ext.Date.monthNames[this.getMonth()]",
m: "Ext.String.leftPad(this.getMonth() + 1, 2, '0')",
M: "Ext.Date.getShortMonthName(this.getMonth())", 
n: "(this.getMonth() + 1)",
t: "Ext.Date.getDaysInMonth(this)",
L: "(Ext.Date.isLeapYear(this) ? 1 : 0)",
o: "(this.getFullYear() + (Ext.Date.getWeekOfYear(this) == 1 && this.getMonth() > 0 ? +1 : (Ext.Date.getWeekOfYear(this) >= 52 && this.getMonth() < 11 ? -1 : 0)))",
Y: "Ext.String.leftPad(this.getFullYear(), 4, '0')",
y: "('' + this.getFullYear()).substring(2, 4)",
a: "(this.getHours() < 12 ? 'am' : 'pm')",
A: "(this.getHours() < 12 ? 'AM' : 'PM')",
g: "((this.getHours() % 12) ? this.getHours() % 12 : 12)",
G: "this.getHours()",
h: "Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')",
H: "Ext.String.leftPad(this.getHours(), 2, '0')",
i: "Ext.String.leftPad(this.getMinutes(), 2, '0')",
s: "Ext.String.leftPad(this.getSeconds(), 2, '0')",
u: "Ext.String.leftPad(this.getMilliseconds(), 3, '0')",
O: "Ext.Date.getGMTOffset(this)",
P: "Ext.Date.getGMTOffset(this, true)",
T: "Ext.Date.getTimezone(this)",
Z: "(this.getTimezoneOffset() * -60)",
c: function() { 
var c, code, i, l, e;
for (c = "Y-m-dTH:i:sP", code = [], i = 0, l = c.length; i < l; ++i) {
e = c.charAt(i);
code.push(e == "T" ? "'T'" : utilDate.getFormatCode(e)); 
}
return code.join(" + ");
},
U: "Math.round(this.getTime() / 1000)"
},
isValid : function(y, m, d, h, i, s, ms) {
h = h || 0;
i = i || 0;
s = s || 0;
ms = ms || 0;
var dt = utilDate.add(new Date(y < 100 ? 100 : y, m - 1, d, h, i, s, ms), utilDate.YEAR, y < 100 ? y - 100 : 0);
return y == dt.getFullYear() &&
m == dt.getMonth() + 1 &&
d == dt.getDate() &&
h == dt.getHours() &&
i == dt.getMinutes() &&
s == dt.getSeconds() &&
ms == dt.getMilliseconds();
},
parse : function(input, format, strict) {
var p = utilDate.parseFunctions;
if (p[format] == null) {
utilDate.createParser(format);
}
return p[format].call(utilDate, input, Ext.isDefined(strict) ? strict : utilDate.useStrict);
},
parseDate: function(input, format, strict){
return utilDate.parse(input, format, strict);
},
getFormatCode : function(character) {
var f = utilDate.formatCodes[character];
if (f) {
f = typeof f == 'function'? f() : f;
utilDate.formatCodes[character] = f; 
}
return f || ("'" + Ext.String.escape(character) + "'");
},
createFormat : function(format) {
var code = [],
special = false,
ch = '',
i;
for (i = 0; i < format.length; ++i) {
ch = format.charAt(i);
if (!special && ch == "\\") {
special = true;
} else if (special) {
special = false;
code.push("'" + Ext.String.escape(ch) + "'");
} else {
code.push(utilDate.getFormatCode(ch));
}
}
utilDate.formatFunctions[format] = Ext.functionFactory("return " + code.join('+'));
},
createParser : function(format) {
var regexNum = utilDate.parseRegexes.length,
currentGroup = 1,
calc = [],
regex = [],
special = false,
ch = "",
i = 0,
len = format.length,
atEnd = [],
obj;
for (; i < len; ++i) {
ch = format.charAt(i);
if (!special && ch == "\\") {
special = true;
} else if (special) {
special = false;
regex.push(Ext.String.escape(ch));
} else {
obj = utilDate.formatCodeToRegex(ch, currentGroup);
currentGroup += obj.g;
regex.push(obj.s);
if (obj.g && obj.c) {
if (obj.calcAtEnd) {
atEnd.push(obj.c);
} else {
calc.push(obj.c);
}
}
}
}
calc = calc.concat(atEnd);
utilDate.parseRegexes[regexNum] = new RegExp("^" + regex.join('') + "$", 'i');
utilDate.parseFunctions[format] = Ext.functionFactory("input", "strict", xf(code, regexNum, calc.join('')));
},
parseCodes : {
d: {
g:1,
c:"d = parseInt(results[{0}], 10);\n",
s:"(3[0-1]|[1-2][0-9]|0[1-9])" 
},
j: {
g:1,
c:"d = parseInt(results[{0}], 10);\n",
s:"(3[0-1]|[1-2][0-9]|[1-9])" 
},
D: function() {
for (var a = [], i = 0; i < 7; a.push(utilDate.getShortDayName(i)), ++i); 
return {
g:0,
c:null,
s:"(?:" + a.join("|") +")"
};
},
l: function() {
return {
g:0,
c:null,
s:"(?:" + utilDate.dayNames.join("|") + ")"
};
},
N: {
g:0,
c:null,
s:"[1-7]" 
},
S: {
g:0,
c:null,
s:"(?:st|nd|rd|th)"
},
w: {
g:0,
c:null,
s:"[0-6]" 
},
z: {
g:1,
c:"z = parseInt(results[{0}], 10);\n",
s:"(\\d{1,3})" 
},
W: {
g:1,
c:"W = parseInt(results[{0}], 10);\n",
s:"(\\d{2})" 
},
F: function() {
return {
g:1,
c:"m = parseInt(me.getMonthNumber(results[{0}]), 10);\n", 
s:"(" + utilDate.monthNames.join("|") + ")"
};
},
M: function() {
for (var a = [], i = 0; i < 12; a.push(utilDate.getShortMonthName(i)), ++i); 
return Ext.applyIf({
s:"(" + a.join("|") + ")"
}, utilDate.formatCodeToRegex("F"));
},
m: {
g:1,
c:"m = parseInt(results[{0}], 10) - 1;\n",
s:"(1[0-2]|0[1-9])" 
},
n: {
g:1,
c:"m = parseInt(results[{0}], 10) - 1;\n",
s:"(1[0-2]|[1-9])" 
},
t: {
g:0,
c:null,
s:"(?:\\d{2})" 
},
L: {
g:0,
c:null,
s:"(?:1|0)"
},
o: { 
g: 1,
c: "y = parseInt(results[{0}], 10);\n",
s: "(\\d{4})" 
},
Y: {
g:1,
c:"y = parseInt(results[{0}], 10);\n",
s:"(\\d{4})" 
},
y: {
g:1,
c:"var ty = parseInt(results[{0}], 10);\n"
+ "y = ty > me.y2kYear ? 1900 + ty : 2000 + ty;\n", 
s:"(\\d{1,2})"
},
a: {
g:1,
c:"if (/(am)/i.test(results[{0}])) {\n"
+ "if (!h || h == 12) { h = 0; }\n"
+ "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
s:"(am|pm|AM|PM)",
calcAtEnd: true
},
A: {
g:1,
c:"if (/(am)/i.test(results[{0}])) {\n"
+ "if (!h || h == 12) { h = 0; }\n"
+ "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
s:"(AM|PM|am|pm)",
calcAtEnd: true
},
g: {
g:1,
c:"h = parseInt(results[{0}], 10);\n",
s:"(1[0-2]|[0-9])" 
},
G: {
g:1,
c:"h = parseInt(results[{0}], 10);\n",
s:"(2[0-3]|1[0-9]|[0-9])" 
},
h: {
g:1,
c:"h = parseInt(results[{0}], 10);\n",
s:"(1[0-2]|0[1-9])" 
},
H: {
g:1,
c:"h = parseInt(results[{0}], 10);\n",
s:"(2[0-3]|[0-1][0-9])" 
},
i: {
g:1,
c:"i = parseInt(results[{0}], 10);\n",
s:"([0-5][0-9])" 
},
s: {
g:1,
c:"s = parseInt(results[{0}], 10);\n",
s:"([0-5][0-9])" 
},
u: {
g:1,
c:"ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n",
s:"(\\d+)" 
},
O: {
g:1,
c:[
"o = results[{0}];",
"var sn = o.substring(0,1),", 
"hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),", 
"mn = o.substring(3,5) % 60;", 
"o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n" 
].join("\n"),
s: "([+-]\\d{4})" 
},
P: {
g:1,
c:[
"o = results[{0}];",
"var sn = o.substring(0,1),", 
"hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),", 
"mn = o.substring(4,6) % 60;", 
"o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n" 
].join("\n"),
s: "([+-]\\d{2}:\\d{2})" 
},
T: {
g:0,
c:null,
s:"[A-Z]{1,5}" 
},
Z: {
g:1,
c:"zz = results[{0}] * 1;\n" 
+ "zz = (-43200 <= zz && zz <= 50400)? zz : null;\n",
s:"([+-]?\\d{1,5})" 
},
c: function() {
var calc = [],
arr = [
utilDate.formatCodeToRegex("Y", 1), 
utilDate.formatCodeToRegex("m", 2), 
utilDate.formatCodeToRegex("d", 3), 
utilDate.formatCodeToRegex("H", 4), 
utilDate.formatCodeToRegex("i", 5), 
utilDate.formatCodeToRegex("s", 6), 
{c:"ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"}, 
{c:[ 
"if(results[8]) {", 
"if(results[8] == 'Z'){",
"zz = 0;", 
"}else if (results[8].indexOf(':') > -1){",
utilDate.formatCodeToRegex("P", 8).c, 
"}else{",
utilDate.formatCodeToRegex("O", 8).c, 
"}",
"}"
].join('\n')}
],
i,
l;
for (i = 0, l = arr.length; i < l; ++i) {
calc.push(arr[i].c);
}
return {
g:1,
c:calc.join(""),
s:[
arr[0].s, 
"(?:", "-", arr[1].s, 
"(?:", "-", arr[2].s, 
"(?:",
"(?:T| )?", 
arr[3].s, ":", arr[4].s,  
"(?::", arr[5].s, ")?", 
"(?:(?:\\.|,)(\\d+))?", 
"(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?", 
")?",
")?",
")?"
].join("")
};
},
U: {
g:1,
c:"u = parseInt(results[{0}], 10);\n",
s:"(-?\\d+)" 
}
},
dateFormat: function(date, format) {
return utilDate.format(date, format);
},
isEqual: function(date1, date2) {
if (date1 && date2) {
return (date1.getTime() === date2.getTime());
}
return !(date1 || date2);
},
format: function(date, format) {
var formatFunctions = utilDate.formatFunctions;
if (!Ext.isDate(date)) {
return '';
}
if (formatFunctions[format] == null) {
utilDate.createFormat(format);
}
return formatFunctions[format].call(date) + '';
},
getTimezone : function(date) {
return date.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,5})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, "$1$2").replace(/[^A-Z]/g, "");
},
getGMTOffset : function(date, colon) {
var offset = date.getTimezoneOffset();
return (offset > 0 ? "-" : "+")
+ Ext.String.leftPad(Math.floor(Math.abs(offset) / 60), 2, "0")
+ (colon ? ":" : "")
+ Ext.String.leftPad(Math.abs(offset % 60), 2, "0");
},
getDayOfYear: function(date) {
var num = 0,
d = Ext.Date.clone(date),
m = date.getMonth(),
i;
for (i = 0, d.setDate(1), d.setMonth(0); i < m; d.setMonth(++i)) {
num += utilDate.getDaysInMonth(d);
}
return num + date.getDate() - 1;
},
getWeekOfYear : (function() {
var ms1d = 864e5, 
ms7d = 7 * ms1d; 
return function(date) { 
var DC3 = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate() + 3) / ms1d, 
AWN = Math.floor(DC3 / 7), 
Wyr = new Date(AWN * ms7d).getUTCFullYear();
return AWN - Math.floor(Date.UTC(Wyr, 0, 7) / ms7d) + 1;
};
}()),
isLeapYear : function(date) {
var year = date.getFullYear();
return !!((year & 3) == 0 && (year % 100 || (year % 400 == 0 && year)));
},
getFirstDayOfMonth : function(date) {
var day = (date.getDay() - (date.getDate() - 1)) % 7;
return (day < 0) ? (day + 7) : day;
},
getLastDayOfMonth : function(date) {
return utilDate.getLastDateOfMonth(date).getDay();
},
getFirstDateOfMonth : function(date) {
return new Date(date.getFullYear(), date.getMonth(), 1);
},
getLastDateOfMonth : function(date) {
return new Date(date.getFullYear(), date.getMonth(), utilDate.getDaysInMonth(date));
},
getDaysInMonth: (function() {
var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
return function(date) { 
var m = date.getMonth();
return m == 1 && utilDate.isLeapYear(date) ? 29 : daysInMonth[m];
};
}()),
getSuffix : function(date) {
switch (date.getDate()) {
case 1:
case 21:
case 31:
return "st";
case 2:
case 22:
return "nd";
case 3:
case 23:
return "rd";
default:
return "th";
}
},
clone : function(date) {
return new Date(date.getTime());
},
isDST : function(date) {
return new Date(date.getFullYear(), 0, 1).getTimezoneOffset() != date.getTimezoneOffset();
},
clearTime : function(date, clone) {
if (clone) {
return Ext.Date.clearTime(Ext.Date.clone(date));
}
var d = date.getDate(),
hr,
c;
date.setHours(0);
date.setMinutes(0);
date.setSeconds(0);
date.setMilliseconds(0);
if (date.getDate() != d) { 
for (hr = 1, c = utilDate.add(date, Ext.Date.HOUR, hr); c.getDate() != d; hr++, c = utilDate.add(date, Ext.Date.HOUR, hr));
date.setDate(d);
date.setHours(c.getHours());
}
return date;
},
add : function(date, interval, value) {
var d = Ext.Date.clone(date),
Date = Ext.Date,
day, decimalValue, base = 0;
if (!interval || value === 0) {
return d;
}
decimalValue = value - parseInt(value, 10);
value = parseInt(value, 10);
if (value) {
switch(interval.toLowerCase()) {
case Ext.Date.MILLI:
d.setTime(d.getTime() + value);
break;
case Ext.Date.SECOND:
d.setTime(d.getTime() + value * 1000);
break;
case Ext.Date.MINUTE:
d.setTime(d.getTime() + value * 60 * 1000);
break;
case Ext.Date.HOUR:
d.setTime(d.getTime() + value * 60 * 60 * 1000);
break;
case Ext.Date.DAY:
d.setDate(d.getDate() + value);
break;
case Ext.Date.MONTH:
day = date.getDate();
if (day > 28) {
day = Math.min(day, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(date), Ext.Date.MONTH, value)).getDate());
}
d.setDate(day);
d.setMonth(date.getMonth() + value);
break;
case Ext.Date.YEAR:
day = date.getDate();
if (day > 28) {
day = Math.min(day, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(date), Ext.Date.YEAR, value)).getDate());
}
d.setDate(day);
d.setFullYear(date.getFullYear() + value);
break;
}
}
if (decimalValue) {
switch (interval.toLowerCase()) {
case Ext.Date.MILLI:    base = 1;               break;
case Ext.Date.SECOND:   base = 1000;            break;
case Ext.Date.MINUTE:   base = 1000*60;         break;
case Ext.Date.HOUR:     base = 1000*60*60;      break;
case Ext.Date.DAY:      base = 1000*60*60*24;   break;
case Ext.Date.MONTH:
day = utilDate.getDaysInMonth(d);
base = 1000*60*60*24*day;
break;
case Ext.Date.YEAR:
day = (utilDate.isLeapYear(d) ? 366 : 365);
base = 1000*60*60*24*day;
break;
}
if (base) {
d.setTime(d.getTime() + base * decimalValue); 
}
}
return d;
},
subtract: function(date, interval, value){
return utilDate.add(date, interval, -value);
},
between : function(date, start, end) {
var t = date.getTime();
return start.getTime() <= t && t <= end.getTime();
},
compat: function() {
var nativeDate = window.Date,
p,
statics = ['useStrict', 'formatCodeToRegex', 'parseFunctions', 'parseRegexes', 'formatFunctions', 'y2kYear', 'MILLI', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'MONTH', 'YEAR', 'defaults', 'dayNames', 'monthNames', 'monthNumbers', 'getShortMonthName', 'getShortDayName', 'getMonthNumber', 'formatCodes', 'isValid', 'parseDate', 'getFormatCode', 'createFormat', 'createParser', 'parseCodes'],
proto = ['dateFormat', 'format', 'getTimezone', 'getGMTOffset', 'getDayOfYear', 'getWeekOfYear', 'isLeapYear', 'getFirstDayOfMonth', 'getLastDayOfMonth', 'getDaysInMonth', 'getSuffix', 'clone', 'isDST', 'clearTime', 'add', 'between'],
sLen    = statics.length,
pLen    = proto.length,
stat, prot, s;
for (s = 0; s < sLen; s++) {
stat = statics[s];
nativeDate[stat] = utilDate[stat];
}
for (p = 0; p < pLen; p++) {
prot = proto[p];
nativeDate.prototype[prot] = function() {
var args = Array.prototype.slice.call(arguments);
args.unshift(this);
return utilDate[prot].apply(utilDate, args);
};
}
}
});
};
(function(flexSetter) {
var noArgs = [],
Base = function(){},
hookFunctionFactory = function(hookFunction, underriddenFunction, methodName, owningClass) {
var result = function() {
var result = this.callParent(arguments);
hookFunction.apply(this, arguments);
return result;
};
result.$name = methodName;
result.$owner = owningClass;
if (underriddenFunction) {
result.$previous = underriddenFunction.$previous;
underriddenFunction.$previous = result;
}
return result;
};
Ext.apply(Base, {
$className: 'Ext.Base',
$isClass: true,
create: function() {
return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)));
},
extend: function(parent) {
var parentPrototype = parent.prototype,
basePrototype, prototype, i, ln, name, statics;
prototype = this.prototype = Ext.Object.chain(parentPrototype);
prototype.self = this;
this.superclass = prototype.superclass = parentPrototype;
if (!parent.$isClass) {
basePrototype = Ext.Base.prototype;
for (i in basePrototype) {
if (i in prototype) {
prototype[i] = basePrototype[i];
}
}
}
statics = parentPrototype.$inheritableStatics;
if (statics) {
for (i = 0,ln = statics.length; i < ln; i++) {
name = statics[i];
if (!this.hasOwnProperty(name)) {
this[name] = parent[name];
}
}
}
if (parent.$onExtended) {
this.$onExtended = parent.$onExtended.slice();
}
prototype.config = new prototype.configClass();
prototype.initConfigList = prototype.initConfigList.slice();
prototype.initConfigMap = Ext.clone(prototype.initConfigMap);
prototype.configMap = Ext.Object.chain(prototype.configMap);
},
$onExtended: [],
triggerExtended: function() {
var callbacks = this.$onExtended,
ln = callbacks.length,
i, callback;
if (ln > 0) {
for (i = 0; i < ln; i++) {
callback = callbacks[i];
callback.fn.apply(callback.scope || this, arguments);
}
}
},
onExtended: function(fn, scope) {
this.$onExtended.push({
fn: fn,
scope: scope
});
return this;
},
addConfig: function(config, fullMerge) {
var prototype = this.prototype,
configNameCache = Ext.Class.configNameCache,
hasConfig = prototype.configMap,
initConfigList = prototype.initConfigList,
initConfigMap = prototype.initConfigMap,
defaultConfig = prototype.config,
initializedName, name, value;
for (name in config) {
if (config.hasOwnProperty(name)) {
if (!hasConfig[name]) {
hasConfig[name] = true;
}
value = config[name];
initializedName = configNameCache[name].initialized;
if (!initConfigMap[name] && value !== null && !prototype[initializedName]) {
initConfigMap[name] = true;
initConfigList.push(name);
}
}
}
if (fullMerge) {
Ext.merge(defaultConfig, config);
}
else {
Ext.mergeIf(defaultConfig, config);
}
prototype.configClass = Ext.Object.classify(defaultConfig);
},
addStatics: function(members) {
var member, name;
for (name in members) {
if (members.hasOwnProperty(name)) {
member = members[name];
if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) {
member.$owner = this;
member.$name = name;
}
this[name] = member;
}
}
return this;
},
addInheritableStatics: function(members) {
var inheritableStatics,
hasInheritableStatics,
prototype = this.prototype,
name, member;
inheritableStatics = prototype.$inheritableStatics;
hasInheritableStatics = prototype.$hasInheritableStatics;
if (!inheritableStatics) {
inheritableStatics = prototype.$inheritableStatics = [];
hasInheritableStatics = prototype.$hasInheritableStatics = {};
}
for (name in members) {
if (members.hasOwnProperty(name)) {
member = members[name];
this[name] = member;
if (!hasInheritableStatics[name]) {
hasInheritableStatics[name] = true;
inheritableStatics.push(name);
}
}
}
return this;
},
addMembers: function(members) {
var prototype = this.prototype,
enumerables = Ext.enumerables,
names = [],
i, ln, name, member;
for (name in members) {
names.push(name);
}
if (enumerables) {
names.push.apply(names, enumerables);
}
for (i = 0,ln = names.length; i < ln; i++) {
name = names[i];
if (members.hasOwnProperty(name)) {
member = members[name];
if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) {
member.$owner = this;
member.$name = name;
}
prototype[name] = member;
}
}
return this;
},
addMember: function(name, member) {            
if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) {
member.$owner = this;
member.$name = name;
}
this.prototype[name] = member;
return this;
},
implement: function() {
this.addMembers.apply(this, arguments);
},
borrow: function(fromClass, members) {
var prototype = this.prototype,
fromPrototype = fromClass.prototype,
i, ln, name, fn, toBorrow;
members = Ext.Array.from(members);
for (i = 0,ln = members.length; i < ln; i++) {
name = members[i];
toBorrow = fromPrototype[name];
if (typeof toBorrow == 'function') {
fn = Ext.Function.clone(toBorrow);
fn.$owner = this;
fn.$name = name;
prototype[name] = fn;
}
else {
prototype[name] = toBorrow;
}
}
return this;
},
override: function(members) {
var me = this,
enumerables = Ext.enumerables,
target = me.prototype,
cloneFunction = Ext.Function.clone,
name, index, member, statics, names, previous;
if (arguments.length === 2) {
name = members;
members = {};
members[name] = arguments[1];
enumerables = null;
}
do {
names = []; 
statics = null; 
for (name in members) { 
if (name == 'statics') {
statics = members[name];
} else if (name == 'inheritableStatics'){
me.addInheritableStatics(members[name]);
} else if (name == 'config') {
me.addConfig(members[name], true);
} else {
names.push(name);
}
}
if (enumerables) {
names.push.apply(names, enumerables);
}
for (index = names.length; index--; ) {
name = names[index];
if (members.hasOwnProperty(name)) {
member = members[name];
if (typeof member == 'function' && !member.$className && member !== Ext.emptyFn && member !== Ext.identityFn) {
if (typeof member.$owner != 'undefined') {
member = cloneFunction(member);
}
member.$owner = me;
member.$name = name;
previous = target.hasOwnProperty(name) && target[name];
if (previous) {
member.$previous = previous;
}
}
target[name] = member;
}
}
target = me; 
members = statics; 
} while (members);
return this;
},
callParent: function(args) {
var method;
return (method = this.callParent.caller) && (method.$previous ||
((method = method.$owner ? method : method.caller) &&
method.$owner.superclass.self[method.$name])).apply(this, args || noArgs);
},
callSuper: function(args) {
var method;
return (method = this.callSuper.caller) &&
((method = method.$owner ? method : method.caller) &&
method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
},
mixin: function(name, mixinClass) {
var me = this,
mixin = mixinClass.prototype,
prototype = me.prototype,
key, statics, i, ln, staticName,
mixinValue, hookKey, hookFunction;
if (typeof mixin.onClassMixedIn != 'undefined') {
mixin.onClassMixedIn.call(mixinClass, me);
}
if (!prototype.hasOwnProperty('mixins')) {
if ('mixins' in prototype) {
prototype.mixins = Ext.Object.chain(prototype.mixins);
}
else {
prototype.mixins = {};
}
}
for (key in mixin) {
mixinValue = mixin[key];
if (key === 'mixins') {
Ext.merge(prototype.mixins, mixinValue);
}
else if (key === 'xhooks') {
for (hookKey in mixinValue) {
hookFunction = mixinValue[hookKey];
hookFunction.$previous = Ext.emptyFn;
if (prototype.hasOwnProperty(hookKey)) {
hookFunctionFactory(hookFunction, prototype[hookKey], hookKey, me);
} else {
prototype[hookKey] = hookFunctionFactory(hookFunction, null, hookKey, me);
}
}
}
else if (!(key === 'mixinId' || key === 'config') && (prototype[key] === undefined)) {
prototype[key] = mixinValue;
}
}
statics = mixin.$inheritableStatics;
if (statics) {
for (i = 0, ln = statics.length; i < ln; i++) {
staticName = statics[i];
if (!me.hasOwnProperty(staticName)) {
me[staticName] = mixinClass[staticName];
}
}
}
if ('config' in mixin) {
me.addConfig(mixin.config, false);
}
prototype.mixins[name] = mixin;
return me;
},
getName: function() {
return Ext.getClassName(this);
},
createAlias: flexSetter(function(alias, origin) {
this.override(alias, function() {
return this[origin].apply(this, arguments);
});
}),
addXtype: function(xtype) {
var prototype = this.prototype,
xtypesMap = prototype.xtypesMap,
xtypes = prototype.xtypes,
xtypesChain = prototype.xtypesChain;
if (!prototype.hasOwnProperty('xtypesMap')) {
xtypesMap = prototype.xtypesMap = Ext.merge({}, prototype.xtypesMap || {});
xtypes = prototype.xtypes = prototype.xtypes ? [].concat(prototype.xtypes) : [];
xtypesChain = prototype.xtypesChain = prototype.xtypesChain ? [].concat(prototype.xtypesChain) : [];
prototype.xtype = xtype;
}
if (!xtypesMap[xtype]) {
xtypesMap[xtype] = true;
xtypes.push(xtype);
xtypesChain.push(xtype);
Ext.ClassManager.setAlias(this, 'widget.' + xtype);
}
return this;
}
});
Base.implement({
isInstance: true,
$className: 'Ext.Base',
configClass: Ext.emptyFn,
initConfigList: [],
configMap: {},
initConfigMap: {},
statics: function() {
var method = this.statics.caller,
self = this.self;
if (!method) {
return self;
}
return method.$owner;
},
callParent: function(args) {
var method,
superMethod = (method = this.callParent.caller) && (method.$previous ||
((method = method.$owner ? method : method.caller) &&
method.$owner.superclass[method.$name]));
return superMethod.apply(this, args || noArgs);
},
callSuper: function(args) {
var method,
superMethod = (method = this.callSuper.caller) &&
((method = method.$owner ? method : method.caller) &&
method.$owner.superclass[method.$name]);
return superMethod.apply(this, args || noArgs);
},
self: Base,
constructor: function() {
return this;
},
initConfig: function(config) {
var instanceConfig = config,
configNameCache = Ext.Class.configNameCache,
defaultConfig = new this.configClass(),
defaultConfigList = this.initConfigList,
hasConfig = this.configMap,
nameMap, i, ln, name, initializedName;
this.initConfig = Ext.emptyFn;
this.initialConfig = instanceConfig || {};
this.config = config = (instanceConfig) ? Ext.merge(defaultConfig, config) : defaultConfig;
if (instanceConfig) {
defaultConfigList = defaultConfigList.slice();
for (name in instanceConfig) {
if (hasConfig[name]) {
if (instanceConfig[name] !== null) {
defaultConfigList.push(name);
this[configNameCache[name].initialized] = false;
}
}
}
}
for (i = 0,ln = defaultConfigList.length; i < ln; i++) {
name = defaultConfigList[i];
nameMap = configNameCache[name];
initializedName = nameMap.initialized;
if (!this[initializedName]) {
this[initializedName] = true;
this[nameMap.set].call(this, config[name]);
}
}
return this;
},
hasConfig: function(name) {
return Boolean(this.configMap[name]);
},
setConfig: function(config, applyIfNotSet) {
if (!config) {
return this;
}
var configNameCache = Ext.Class.configNameCache,
currentConfig = this.config,
hasConfig = this.configMap,
initialConfig = this.initialConfig,
name, value;
applyIfNotSet = Boolean(applyIfNotSet);
for (name in config) {
if (applyIfNotSet && initialConfig.hasOwnProperty(name)) {
continue;
}
value = config[name];
currentConfig[name] = value;
if (hasConfig[name]) {
this[configNameCache[name].set](value);
}
}
return this;
},
getConfig: function(name) {
var configNameCache = Ext.Class.configNameCache;
return this[configNameCache[name].get]();
},
getInitialConfig: function(name) {
var config = this.config;
if (!name) {
return config;
}
else {
return config[name];
}
},
onConfigUpdate: function(names, callback, scope) {
var self = this.self,
i, ln, name,
updaterName, updater, newUpdater;
names = Ext.Array.from(names);
scope = scope || this;
for (i = 0,ln = names.length; i < ln; i++) {
name = names[i];
updaterName = 'update' + Ext.String.capitalize(name);
updater = this[updaterName] || Ext.emptyFn;
newUpdater = function() {
updater.apply(this, arguments);
scope[callback].apply(scope, arguments);
};
newUpdater.$name = updaterName;
newUpdater.$owner = self;
this[updaterName] = newUpdater;
}
},
destroy: function() {
this.destroy = Ext.emptyFn;
}
});
Base.prototype.callOverridden = Base.prototype.callParent;
Ext.Base = Base;
}(Ext.Function.flexSetter));
(function() {
var ExtClass,
Base = Ext.Base,
baseStaticMembers = [],
baseStaticMember, baseStaticMemberLength;
for (baseStaticMember in Base) {
if (Base.hasOwnProperty(baseStaticMember)) {
baseStaticMembers.push(baseStaticMember);
}
}
baseStaticMemberLength = baseStaticMembers.length;
function makeCtor (className) {
function constructor () {
return this.constructor.apply(this, arguments) || null;
}
return constructor;
}
Ext.Class = ExtClass = function(Class, data, onCreated) {
if (typeof Class != 'function') {
onCreated = data;
data = Class;
Class = null;
}
if (!data) {
data = {};
}
Class = ExtClass.create(Class, data);
ExtClass.process(Class, data, onCreated);
return Class;
};
Ext.apply(ExtClass, {
onBeforeCreated: function(Class, data, hooks) {
Class.addMembers(data);
hooks.onCreated.call(Class, Class);
},
create: function(Class, data) {
var name, i;
if (!Class) {
Class = makeCtor(
);
}
for (i = 0; i < baseStaticMemberLength; i++) {
name = baseStaticMembers[i];
Class[name] = Base[name];
}
return Class;
},
process: function(Class, data, onCreated) {
var preprocessorStack = data.preprocessors || ExtClass.defaultPreprocessors,
registeredPreprocessors = this.preprocessors,
hooks = {
onBeforeCreated: this.onBeforeCreated
},
preprocessors = [],
preprocessor, preprocessorsProperties,
i, ln, j, subLn, preprocessorProperty;
delete data.preprocessors;
for (i = 0,ln = preprocessorStack.length; i < ln; i++) {
preprocessor = preprocessorStack[i];
if (typeof preprocessor == 'string') {
preprocessor = registeredPreprocessors[preprocessor];
preprocessorsProperties = preprocessor.properties;
if (preprocessorsProperties === true) {
preprocessors.push(preprocessor.fn);
}
else if (preprocessorsProperties) {
for (j = 0,subLn = preprocessorsProperties.length; j < subLn; j++) {
preprocessorProperty = preprocessorsProperties[j];
if (data.hasOwnProperty(preprocessorProperty)) {
preprocessors.push(preprocessor.fn);
break;
}
}
}
}
else {
preprocessors.push(preprocessor);
}
}
hooks.onCreated = onCreated ? onCreated : Ext.emptyFn;
hooks.preprocessors = preprocessors;
this.doProcess(Class, data, hooks);
},
doProcess: function(Class, data, hooks) {
var me = this,
preprocessors = hooks.preprocessors,
preprocessor = preprocessors.shift(),
doProcess = me.doProcess;
for ( ; preprocessor ; preprocessor = preprocessors.shift()) {
if (preprocessor.call(me, Class, data, hooks, doProcess) === false) {
return;
}
}
hooks.onBeforeCreated.apply(me, arguments);
},
preprocessors: {},
registerPreprocessor: function(name, fn, properties, position, relativeTo) {
if (!position) {
position = 'last';
}
if (!properties) {
properties = [name];
}
this.preprocessors[name] = {
name: name,
properties: properties || false,
fn: fn
};
this.setDefaultPreprocessorPosition(name, position, relativeTo);
return this;
},
getPreprocessor: function(name) {
return this.preprocessors[name];
},
getPreprocessors: function() {
return this.preprocessors;
},
defaultPreprocessors: [],
getDefaultPreprocessors: function() {
return this.defaultPreprocessors;
},
setDefaultPreprocessors: function(preprocessors) {
this.defaultPreprocessors = Ext.Array.from(preprocessors);
return this;
},
setDefaultPreprocessorPosition: function(name, offset, relativeName) {
var defaultPreprocessors = this.defaultPreprocessors,
index;
if (typeof offset == 'string') {
if (offset === 'first') {
defaultPreprocessors.unshift(name);
return this;
}
else if (offset === 'last') {
defaultPreprocessors.push(name);
return this;
}
offset = (offset === 'after') ? 1 : -1;
}
index = Ext.Array.indexOf(defaultPreprocessors, relativeName);
if (index !== -1) {
Ext.Array.splice(defaultPreprocessors, Math.max(0, index + offset), 0, name);
}
return this;
},
configNameCache: {},
getConfigNameMap: function(name) {
var cache = this.configNameCache,
map = cache[name],
capitalizedName;
if (!map) {
capitalizedName = name.charAt(0).toUpperCase() + name.substr(1);
map = cache[name] = {
internal: name,
initialized: '_is' + capitalizedName + 'Initialized',
apply: 'apply' + capitalizedName,
update: 'update' + capitalizedName,
'set': 'set' + capitalizedName,
'get': 'get' + capitalizedName,
doSet : 'doSet' + capitalizedName,
changeEvent: name.toLowerCase() + 'change'
};
}
return map;
}
});
ExtClass.registerPreprocessor('extend', function(Class, data, hooks) {
var Base = Ext.Base,
basePrototype = Base.prototype,
extend = data.extend,
Parent, parentPrototype, i;
delete data.extend;
if (extend && extend !== Object) {
Parent = extend;
}
else {
Parent = Base;
}
parentPrototype = Parent.prototype;
if (!Parent.$isClass) {
for (i in basePrototype) {
if (!parentPrototype[i]) {
parentPrototype[i] = basePrototype[i];
}
}
}
Class.extend(Parent);
Class.triggerExtended.apply(Class, arguments);
if (data.onClassExtended) {
Class.onExtended(data.onClassExtended, Class);
delete data.onClassExtended;
}
}, true);
ExtClass.registerPreprocessor('statics', function(Class, data) {
Class.addStatics(data.statics);
delete data.statics;
});
ExtClass.registerPreprocessor('inheritableStatics', function(Class, data) {
Class.addInheritableStatics(data.inheritableStatics);
delete data.inheritableStatics;
});
ExtClass.registerPreprocessor('config', function(Class, data) {
var config = data.config,
prototype = Class.prototype;
delete data.config;
Ext.Object.each(config, function(name, value) {
var nameMap = ExtClass.getConfigNameMap(name),
internalName = nameMap.internal,
initializedName = nameMap.initialized,
applyName = nameMap.apply,
updateName = nameMap.update,
setName = nameMap.set,
getName = nameMap.get,
hasOwnSetter = (setName in prototype) || data.hasOwnProperty(setName),
hasOwnApplier = (applyName in prototype) || data.hasOwnProperty(applyName),
hasOwnUpdater = (updateName in prototype) || data.hasOwnProperty(updateName),
optimizedGetter, customGetter;
if (value === null || (!hasOwnSetter && !hasOwnApplier && !hasOwnUpdater)) {
prototype[internalName] = value;
prototype[initializedName] = true;
}
else {
prototype[initializedName] = false;
}
if (!hasOwnSetter) {
data[setName] = function(value) {
var oldValue = this[internalName],
applier = this[applyName],
updater = this[updateName];
if (!this[initializedName]) {
this[initializedName] = true;
}
if (applier) {
value = applier.call(this, value, oldValue);
}
if (typeof value != 'undefined') {
this[internalName] = value;
if (updater && value !== oldValue) {
updater.call(this, value, oldValue);
}
}
return this;
};
}
if (!(getName in prototype) || data.hasOwnProperty(getName)) {
customGetter = data[getName] || false;
if (customGetter) {
optimizedGetter = function() {
return customGetter.apply(this, arguments);
};
}
else {
optimizedGetter = function() {
return this[internalName];
};
}
data[getName] = function() {
var currentGetter;
if (!this[initializedName]) {
this[initializedName] = true;
this[setName](this.config[name]);
}
currentGetter = this[getName];
if ('$previous' in currentGetter) {
currentGetter.$previous = optimizedGetter;
}
else {
this[getName] = optimizedGetter;
}
return optimizedGetter.apply(this, arguments);
};
}
});
Class.addConfig(config, true);
});
ExtClass.registerPreprocessor('mixins', function(Class, data, hooks) {
var mixins = data.mixins,
name, mixin, i, ln;
delete data.mixins;
Ext.Function.interceptBefore(hooks, 'onCreated', function() {
if (mixins instanceof Array) {
for (i = 0,ln = mixins.length; i < ln; i++) {
mixin = mixins[i];
name = mixin.prototype.mixinId || mixin.$className;
Class.mixin(name, mixin);
}
}
else {
for (var mixinName in mixins) {
if (mixins.hasOwnProperty(mixinName)) {
Class.mixin(mixinName, mixins[mixinName]);
}
}
}
});
});
Ext.extend = function(Class, Parent, members) {
if (arguments.length === 2 && Ext.isObject(Parent)) {
members = Parent;
Parent = Class;
Class = null;
}
var cls;
if (!Parent) {
throw new Error("[Ext.extend] Attempting to extend from a class which has not been loaded on the page.");
}
members.extend = Parent;
members.preprocessors = [
'extend'
,'statics'
,'inheritableStatics'
,'mixins'
,'config'
];
if (Class) {
cls = new ExtClass(Class, members);
cls.prototype.constructor = Class;
} else {
cls = new ExtClass(members);
}
cls.prototype.override = function(o) {
for (var m in o) {
if (o.hasOwnProperty(m)) {
this[m] = o[m];
}
}
};
return cls;
};
}());
(function(Class, alias, arraySlice, arrayFrom, global) {
function makeCtor () {
function constructor () {
return this.constructor.apply(this, arguments) || null;
}
return constructor;
}
var Manager = Ext.ClassManager = {
classes: {},
existCache: {},
namespaceRewrites: [{
from: 'Ext.',
to: Ext
}],
maps: {
alternateToName: {},
aliasToName: {},
nameToAliases: {},
nameToAlternates: {}
},
enableNamespaceParseCache: true,
namespaceParseCache: {},
instantiators: [],
isCreated: function(className) {
var existCache = this.existCache,
i, ln, part, root, parts;
if (this.classes[className] || existCache[className]) {
return true;
}
root = global;
parts = this.parseNamespace(className);
for (i = 0, ln = parts.length; i < ln; i++) {
part = parts[i];
if (typeof part != 'string') {
root = part;
} else {
if (!root || !root[part]) {
return false;
}
root = root[part];
}
}
existCache[className] = true;
this.triggerCreated(className);
return true;
},
createdListeners: [],
nameCreatedListeners: {},
triggerCreated: function(className) {
var listeners = this.createdListeners,
nameListeners = this.nameCreatedListeners,
alternateNames = this.maps.nameToAlternates[className],
names = [className],
i, ln, j, subLn, listener, name;
for (i = 0,ln = listeners.length; i < ln; i++) {
listener = listeners[i];
listener.fn.call(listener.scope, className);
}
if (alternateNames) {
names.push.apply(names, alternateNames);
}
for (i = 0,ln = names.length; i < ln; i++) {
name = names[i];
listeners = nameListeners[name];
if (listeners) {
for (j = 0,subLn = listeners.length; j < subLn; j++) {
listener = listeners[j];
listener.fn.call(listener.scope, name);
}
delete nameListeners[name];
}
}
},
onCreated: function(fn, scope, className) {
var listeners = this.createdListeners,
nameListeners = this.nameCreatedListeners,
listener = {
fn: fn,
scope: scope
};
if (className) {
if (this.isCreated(className)) {
fn.call(scope, className);
return;
}
if (!nameListeners[className]) {
nameListeners[className] = [];
}
nameListeners[className].push(listener);
}
else {
listeners.push(listener);
}
},
parseNamespace: function(namespace) {
var cache = this.namespaceParseCache,
parts,
rewrites,
root,
name,
rewrite, from, to, i, ln;
if (this.enableNamespaceParseCache) {
if (cache.hasOwnProperty(namespace)) {
return cache[namespace];
}
}
parts = [];
rewrites = this.namespaceRewrites;
root = global;
name = namespace;
for (i = 0, ln = rewrites.length; i < ln; i++) {
rewrite = rewrites[i];
from = rewrite.from;
to = rewrite.to;
if(!name) throw new Error(
'`namespace` is undefined see console for "xtype"'
)
if (name === from || name.substring(0, from.length) === from) {
name = name.substring(from.length);
if (typeof to != 'string') {
root = to;
} else {
parts = parts.concat(to.split('.'));
}
break;
}
}
parts.push(root);
parts = parts.concat(name.split('.'));
if (this.enableNamespaceParseCache) {
cache[namespace] = parts;
}
return parts;
},
setNamespace: function(name, value) {
var root = global,
parts = this.parseNamespace(name),
ln = parts.length - 1,
leaf = parts[ln],
i, part;
for (i = 0; i < ln; i++) {
part = parts[i];
if (typeof part != 'string') {
root = part;
} else {
if (!root[part]) {
root[part] = {};
}
root = root[part];
}
}
root[leaf] = value;
return root[leaf];
},
createNamespaces: function() {
var root = global,
parts, part, i, j, ln, subLn;
for (i = 0, ln = arguments.length; i < ln; i++) {
parts = this.parseNamespace(arguments[i]);
for (j = 0, subLn = parts.length; j < subLn; j++) {
part = parts[j];
if (typeof part != 'string') {
root = part;
} else {
if (!root[part]) {
root[part] = {};
}
root = root[part];
}
}
}
return root;
},
set: function(name, value) {
var me = this,
maps = me.maps,
nameToAlternates = maps.nameToAlternates,
targetName = me.getName(value),
alternates;
me.classes[name] = me.setNamespace(name, value);
if (targetName && targetName !== name) {
maps.alternateToName[name] = targetName;
alternates = nameToAlternates[targetName] || (nameToAlternates[targetName] = []);
alternates.push(name);
}
return this;
},
get: function(name) {
var classes = this.classes,
root,
parts,
part, i, ln;
if (classes[name]) {
return classes[name];
}
root = global;
parts = this.parseNamespace(name);
for (i = 0, ln = parts.length; i < ln; i++) {
part = parts[i];
if (typeof part != 'string') {
root = part;
} else {
if (!root || !root[part]) {
return null;
}
root = root[part];
}
}
return root;
},
setAlias: function(cls, alias) {
var aliasToNameMap = this.maps.aliasToName,
nameToAliasesMap = this.maps.nameToAliases,
className;
if (typeof cls == 'string') {
className = cls;
} else {
className = this.getName(cls);
}
if (alias && aliasToNameMap[alias] !== className) {
aliasToNameMap[alias] = className;
}
if (!nameToAliasesMap[className]) {
nameToAliasesMap[className] = [];
}
if (alias) {
Ext.Array.include(nameToAliasesMap[className], alias);
}
return this;
},
addNameAliasMappings: function(aliases){
var aliasToNameMap = this.maps.aliasToName,
nameToAliasesMap = this.maps.nameToAliases,
className, aliasList, alias, i;
for (className in aliases) {
aliasList = nameToAliasesMap[className] ||
(nameToAliasesMap[className] = []);
for (i = 0; i < aliases[className].length; i++) {
alias = aliases[className][i];
if (!aliasToNameMap[alias]) {
aliasToNameMap[alias] = className;
aliasList.push(alias);
}
}
}
return this;
},
addNameAlternateMappings: function(alternates) {
var alternateToName = this.maps.alternateToName,
nameToAlternates = this.maps.nameToAlternates,
className, aliasList, alternate, i;
for (className in alternates) {
aliasList = nameToAlternates[className] ||
(nameToAlternates[className] = []);
for (i  = 0; i < alternates[className].length; i++) {
alternate = alternates[className][i];
if (!alternateToName[alternate]) {
alternateToName[alternate] = className;
aliasList.push(alternate);
}
}
}
return this;
},
getByAlias: function(alias) {
return this.get(this.getNameByAlias(alias));
},
getNameByAlias: function(alias) {
return this.maps.aliasToName[alias] || '';
},
getNameByAlternate: function(alternate) {
return this.maps.alternateToName[alternate] || '';
},
getAliasesByName: function(name) {
return this.maps.nameToAliases[name] || [];
},
getName: function(object) {
return object && object.$className || '';
},
getClass: function(object) {
return object && object.self || null;
},
create: function(className, data, createdFn) {
var ctor = makeCtor();
if (typeof data == 'function') {
data = data(ctor);
}
data.$className = className;
return new Class(ctor, data, function() {
var postprocessorStack = data.postprocessors || Manager.defaultPostprocessors,
registeredPostprocessors = Manager.postprocessors,
postprocessors = [],
postprocessor, i, ln, j, subLn, postprocessorProperties, postprocessorProperty;
delete data.postprocessors;
for (i = 0,ln = postprocessorStack.length; i < ln; i++) {
postprocessor = postprocessorStack[i];
if (typeof postprocessor == 'string') {
postprocessor = registeredPostprocessors[postprocessor];
postprocessorProperties = postprocessor.properties;
if (postprocessorProperties === true) {
postprocessors.push(postprocessor.fn);
}
else if (postprocessorProperties) {
for (j = 0,subLn = postprocessorProperties.length; j < subLn; j++) {
postprocessorProperty = postprocessorProperties[j];
if (data.hasOwnProperty(postprocessorProperty)) {
postprocessors.push(postprocessor.fn);
break;
}
}
}
}
else {
postprocessors.push(postprocessor);
}
}
data.postprocessors = postprocessors;
data.createdFn = createdFn;
Manager.processCreate(className, this, data);
});
},
processCreate: function(className, cls, clsData){
var me = this,
postprocessor = clsData.postprocessors.shift(),
createdFn = clsData.createdFn;
if (!postprocessor) {
if (className) {
me.set(className, cls);
}
if (createdFn) {
createdFn.call(cls, cls);
}
if (className) {
me.triggerCreated(className);
}
return;
}
if (postprocessor.call(me, className, cls, clsData, me.processCreate) !== false) {
me.processCreate(className, cls, clsData);
}
},
createOverride: function (className, data, createdFn) {
var me = this,
overriddenClassName = data.override,
requires = data.requires,
uses = data.uses,
compat = data.compatibility,
classReady = function () {
var cls, temp;
if (requires) {
temp = requires;
requires = null; 
Ext.Loader.require(temp, classReady);
} else {
cls = me.get(overriddenClassName);
delete data.override;
delete data.compatibility;
delete data.requires;
delete data.uses;
Ext.override(cls, data);
me.triggerCreated(className);
if (uses) {
Ext.Loader.addUsedClasses(uses); 
}
if (createdFn) {
createdFn.call(cls); 
}
}
};
me.existCache[className] = true;
if (!compat || Ext.checkVersion(compat)) {
me.onCreated(classReady, me, overriddenClassName);
}
return me;
},
instantiateByAlias: function() {
var alias = arguments[0],
args = arraySlice.call(arguments),
className = this.getNameByAlias(alias);
if (!className) {
className = this.maps.aliasToName[alias];
Ext.syncRequire(className);
}
args[0] = className;
return this.instantiate.apply(this, args);
},
instantiate: function() {
var name = arguments[0],
nameType = typeof name,
args = arraySlice.call(arguments, 1),
alias = name,
possibleName, cls;
if (nameType != 'function') {
if (nameType != 'string' && args.length === 0) {
args = [name];
name = name.xclass;
}
cls = this.get(name);
}
else {
cls = name;
}
if (!cls) {
possibleName = this.getNameByAlias(name);
if (possibleName) {
name = possibleName;
cls = this.get(name);
}
}
if (!cls) {
possibleName = this.getNameByAlternate(name);
if (possibleName) {
name = possibleName;
cls = this.get(name);
}
}
if (!cls) {
Ext.syncRequire(name);
cls = this.get(name);
}
if(!cls){
console.error(
"[Ext.create] Cannot create an instance of unrecognized class name / alias: " +
name+' / '+alias
);
return Ext.Base;
}
return this.getInstantiator(args.length)(cls, args);
},
dynInstantiate: function(name, args) {
args = arrayFrom(args, true);
args.unshift(name);
return this.instantiate.apply(this, args);
},
getInstantiator: function(length) {
var instantiators = this.instantiators,
instantiator,
i,
args;
instantiator = instantiators[length];
if (!instantiator) {
i = length;
args = [];
for (i = 0; i < length; i++) {
args.push('a[' + i + ']');
}
instantiator = instantiators[length] = new Function('c', 'a', 'return new c(' + args.join(',') + ')');
}
return instantiator;
},
postprocessors: {},
defaultPostprocessors: [],
registerPostprocessor: function(name, fn, properties, position, relativeTo) {
if (!position) {
position = 'last';
}
if (!properties) {
properties = [name];
}
this.postprocessors[name] = {
name: name,
properties: properties || false,
fn: fn
};
this.setDefaultPostprocessorPosition(name, position, relativeTo);
return this;
},
setDefaultPostprocessors: function(postprocessors) {
this.defaultPostprocessors = arrayFrom(postprocessors);
return this;
},
setDefaultPostprocessorPosition: function(name, offset, relativeName) {
var defaultPostprocessors = this.defaultPostprocessors,
index;
if (typeof offset == 'string') {
if (offset === 'first') {
defaultPostprocessors.unshift(name);
return this;
}
else if (offset === 'last') {
defaultPostprocessors.push(name);
return this;
}
offset = (offset === 'after') ? 1 : -1;
}
index = Ext.Array.indexOf(defaultPostprocessors, relativeName);
if (index !== -1) {
Ext.Array.splice(defaultPostprocessors, Math.max(0, index + offset), 0, name);
}
return this;
},
getNamesByExpression: function(expression) {
var nameToAliasesMap = this.maps.nameToAliases,
names = [],
name, alias, aliases, possibleName, regex, i, ln;
if (expression.indexOf('*') !== -1) {
expression = expression.replace(/\*/g, '(.*?)');
regex = new RegExp('^' + expression + '$');
for (name in nameToAliasesMap) {
if (nameToAliasesMap.hasOwnProperty(name)) {
aliases = nameToAliasesMap[name];
if (name.search(regex) !== -1) {
names.push(name);
}
else {
for (i = 0, ln = aliases.length; i < ln; i++) {
alias = aliases[i];
if (alias.search(regex) !== -1) {
names.push(name);
break;
}
}
}
}
}
} else {
possibleName = this.getNameByAlias(expression);
if (possibleName) {
names.push(possibleName);
} else {
possibleName = this.getNameByAlternate(expression);
if (possibleName) {
names.push(possibleName);
} else {
names.push(expression);
}
}
}
return names;
}
};
Manager.registerPostprocessor('alias', function(name, cls, data) {
var aliases = data.alias,
i, ln;
for (i = 0,ln = aliases.length; i < ln; i++) {
alias = aliases[i];
this.setAlias(cls, alias);
}
}, ['xtype', 'alias']);
Manager.registerPostprocessor('singleton', function(name, cls, data, fn) {
if (data.singleton) {
fn.call(this, name, new cls(), data);
}
else {
return true;
}
return false;
});
Manager.registerPostprocessor('alternateClassName', function(name, cls, data) {
var alternates = data.alternateClassName,
i, ln, alternate;
if (!(alternates instanceof Array)) {
alternates = [alternates];
}
for (i = 0, ln = alternates.length; i < ln; i++) {
alternate = alternates[i];
this.set(alternate, cls);
}
});
Ext.apply(Ext, {
create: alias(Manager, 'instantiate'),
widget: function(name, config) {
var xtype = name,
alias, className, T, load;
if (typeof xtype != 'string') { 
config = name; 
xtype = config.xtype;
} else {
config = config || {};
}
if (config.isComponent) {
return config;
}
alias = 'widget.' + xtype;
className = Manager.getNameByAlias(alias);
if (!className) {
console.warn('`xtype` is undefined: ' + xtype)
load = true;
}
T = Manager.get(className);
if (load || !T) {
return Manager.instantiateByAlias(alias, config);
}
return new T(config);
},
createByAlias: alias(Manager, 'instantiateByAlias'),
define: function (className, data, createdFn) {
if (!data.override) {
return Manager.create(className, data, createdFn);
}
return Manager.createOverride(className, data, createdFn);
},
undefine: function(className) {
var classes = Manager.classes,
maps = Manager.maps,
aliasToName = maps.aliasToName,
nameToAliases = maps.nameToAliases,
alternateToName = maps.alternateToName,
nameToAlternates = maps.nameToAlternates,
aliases = nameToAliases[className],
alternates = nameToAlternates[className],
parts, partCount, namespace, i;
delete Manager.namespaceParseCache[className];
delete nameToAliases[className];
delete nameToAlternates[className];
delete classes[className];
if (aliases) {
for (i = aliases.length; i--;) {
delete aliasToName[aliases[i]];
}
}
if (alternates) {
for (i = alternates.length; i--; ) {
delete alternateToName[alternates[i]];
}
}
parts  = Manager.parseNamespace(className);
partCount = parts.length - 1;
namespace = parts[0];
for (i = 1; i < partCount; i++) {
namespace = namespace[parts[i]];
if (!namespace) {
return;
}
}
try {
delete namespace[parts[partCount]];
}
catch (e) {
namespace[parts[partCount]] = undefined;
}
},
getClassName: alias(Manager, 'getName'),
getDisplayName: function(object) {
if (object) {
if (object.displayName) {
return object.displayName;
}
if (object.$name && object.$class) {
return Ext.getClassName(object.$class) + '#' + object.$name;
}
if (object.$className) {
return object.$className;
}
}
return 'Anonymous';
},
getClass: alias(Manager, 'getClass'),
namespace: alias(Manager, 'createNamespaces')
});
Ext.createWidget = Ext.widget;
Ext.ns = Ext.namespace;
Class.registerPreprocessor('className', function(cls, data) {
if ('$className' in data) {
cls.$className = data.$className;
}
}, true, 'first');
Class.registerPreprocessor('alias', function(cls, data) {
var prototype = cls.prototype,
xtypes = arrayFrom(data.xtype),
aliases = arrayFrom(data.alias),
widgetPrefix = 'widget.',
widgetPrefixLength = widgetPrefix.length,
xtypesChain = Array.prototype.slice.call(prototype.xtypesChain || []),
xtypesMap = Ext.merge({}, prototype.xtypesMap || {}),
i, ln, alias, xtype;
for (i = 0,ln = aliases.length; i < ln; i++) {
alias = aliases[i];
if (alias.substring(0, widgetPrefixLength) === widgetPrefix) {
xtype = alias.substring(widgetPrefixLength);
Ext.Array.include(xtypes, xtype);
}
}
cls.xtype = data.xtype = xtypes[0];
data.xtypes = xtypes;
for (i = 0,ln = xtypes.length; i < ln; i++) {
xtype = xtypes[i];
if (!xtypesMap[xtype]) {
xtypesMap[xtype] = true;
xtypesChain.push(xtype);
}
}
data.xtypesChain = xtypesChain;
data.xtypesMap = xtypesMap;
Ext.Function.interceptAfter(data, 'onClassCreated', function() {
var mixins = prototype.mixins,
key, mixin;
for (key in mixins) {
if (mixins.hasOwnProperty(key)) {
mixin = mixins[key];
xtypes = mixin.xtypes;
if (xtypes) {
for (i = 0,ln = xtypes.length; i < ln; i++) {
xtype = xtypes[i];
if (!xtypesMap[xtype]) {
xtypesMap[xtype] = true;
xtypesChain.push(xtype);
}
}
}
}
}
});
for (i = 0,ln = xtypes.length; i < ln; i++) {
xtype = xtypes[i];
Ext.Array.include(aliases, widgetPrefix + xtype);
}
data.alias = aliases;
}, ['xtype', 'alias']);
}(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global));
if (Ext._alternatesMetadata) {
Ext.ClassManager.addNameAlternateMappings(Ext._alternatesMetadata);
Ext._alternatesMetadata = null;
}
if (Ext._aliasMetadata) {
Ext.ClassManager.addNameAliasMappings(Ext._aliasMetadata);
Ext._aliasMetadata = null;
}
Ext.Loader = new function() {
var Loader = this,
Manager = Ext.ClassManager,
Class = Ext.Class,
flexSetter = Ext.Function.flexSetter,
alias = Ext.Function.alias,
pass = Ext.Function.pass,
defer = Ext.Function.defer,
arrayErase = Ext.Array.erase,
dependencyProperties = ['extend', 'mixins', 'requires'],
isInHistory = {},
history = [],
slashDotSlashRe = /\/\.\//g,
dotRe = /\./g,
setPathCount = 0;
Ext.apply(Loader, {
isInHistory: isInHistory,
history: history,
config: {
enabled: false,
scriptChainDelay : false,
disableCaching: true,
disableCachingParam: '_dc',
garbageCollect : false,
paths: {
'Ext': '.'
},
preserveScripts : true,
scriptCharset : undefined
},
setConfig: function(name, value) {
if (Ext.isObject(name) && arguments.length === 1) {
Ext.merge(Loader.config, name);
if ('paths' in name) {
Ext.app.collectNamespaces(name.paths);
}
}
else {
Loader.config[name] = (Ext.isObject(value)) ? Ext.merge(Loader.config[name], value) : value;
if (name === 'paths') {
Ext.app.collectNamespaces(value);
}
}
return Loader;
},
getConfig: function(name) {
if (name) {
return Loader.config[name];
}
return Loader.config;
},
setPath: flexSetter(function(name, path) {
Loader.config.paths[name] = path;
Ext.app.namespaces[name] = true;
setPathCount++;
return Loader;
}),
addClassPathMappings: function(paths) {
var name;
if(setPathCount == 0){
Loader.config.paths = paths;
} else {
for(name in paths){
Loader.config.paths[name] = paths[name];
}
}
setPathCount++;
return Loader;
},
getPath: function(className) {
var path = '',
paths = Loader.config.paths,
prefix = Loader.getPrefix(className);
if (prefix.length > 0) {
if (prefix === className) {
return paths[prefix];
}
path = paths[prefix];
className = className.substring(prefix.length + 1);
}
if (path.length > 0) {
path += '/';
}
return path.replace(slashDotSlashRe, '/') + className.replace(dotRe, "/") + '.js';
},
getPrefix: function(className) {
var paths = Loader.config.paths,
prefix, deepestPrefix = '';
if (paths.hasOwnProperty(className)) {
return className;
}
for (prefix in paths) {
if (paths.hasOwnProperty(prefix) && prefix + '.' === className.substring(0, prefix.length + 1)) {
if (prefix.length > deepestPrefix.length) {
deepestPrefix = prefix;
}
}
}
return deepestPrefix;
},
isAClassNameWithAKnownPrefix: function(className) {
var prefix = Loader.getPrefix(className);
return prefix !== '' && prefix !== className;
},
require: function(expressions, fn, scope, excludes) {
if (fn) {
fn.call(scope);
}
},
syncRequire: function() {},
exclude: function(excludes) {
return {
require: function(expressions, fn, scope) {
return Loader.require(expressions, fn, scope, excludes);
},
syncRequire: function(expressions, fn, scope) {
return Loader.syncRequire(expressions, fn, scope, excludes);
}
};
},
onReady: function(fn, scope, withDomReady, options) {
var oldFn;
if (withDomReady !== false && Ext.onDocumentReady) {
oldFn = fn;
fn = function() {
Ext.onDocumentReady(oldFn, scope, options);
};
}
fn.call(scope);
}
});
var queue = [],
isClassFileLoaded = {},
isFileLoaded = {},
classNameToFilePathMap = {},
scriptElements = {},
readyListeners = [],
usedClasses = [],
requiresMap = {},
comparePriority = function(listenerA, listenerB) {
return listenerB.priority - listenerA.priority;
};
Ext.apply(Loader, {
documentHead: typeof document != 'undefined' && (document.head || document.getElementsByTagName('head')[0]),
isLoading: false,
queue: queue,
isClassFileLoaded: isClassFileLoaded,
isFileLoaded: isFileLoaded,
readyListeners: readyListeners,
optionalRequires: usedClasses,
requiresMap: requiresMap,
numPendingFiles: 0,
numLoadedFiles: 0,
hasFileLoadError: false,
classNameToFilePathMap: classNameToFilePathMap,
scriptsLoading: 0,
syncModeEnabled: false,
scriptElements: scriptElements,
refreshQueue: function() {
var ln = queue.length,
i, item, j, requires;
if (!ln && !Loader.scriptsLoading) {
return Loader.triggerReady();
}
for (i = 0; i < ln; i++) {
item = queue[i];
if (item) {
requires = item.requires;
if (requires.length > Loader.numLoadedFiles) {
continue;
}
for (j = 0; j < requires.length; ) {
if (Manager.isCreated(requires[j])) {
arrayErase(requires, j, 1);
}
else {
j++;
}
}
if (item.requires.length === 0) {
arrayErase(queue, i, 1);
item.callback.call(item.scope);
Loader.refreshQueue();
break;
}
}
}
return Loader;
},
injectScriptElement: function(url, onLoad, onError, scope, charset) {
var script = document.createElement('script'),
dispatched = false,
config = Loader.config,
onLoadFn = function() {
if(!dispatched) {
dispatched = true;
script.onload = script.onreadystatechange = script.onerror = null;
if (typeof config.scriptChainDelay == 'number') {
defer(onLoad, config.scriptChainDelay, scope);
} else {
onLoad.call(scope);
}
Loader.cleanupScriptElement(script, config.preserveScripts === false, config.garbageCollect);
}
},
onErrorFn = function(arg) {
defer(onError, 1, scope);   
Loader.cleanupScriptElement(script, config.preserveScripts === false, config.garbageCollect);
};
script.type = 'text/javascript';
script.onerror = onErrorFn;
charset = charset || config.scriptCharset;
if (charset) {
script.charset = charset;
}
if ('addEventListener' in script ) {
script.onload = onLoadFn;
} else if ('readyState' in script) {   
script.onreadystatechange = function() {
if ( this.readyState == 'loaded' || this.readyState == 'complete' ) {
onLoadFn();
}
};
} else {
script.onload = onLoadFn;
}
script.src = url;
(Loader.documentHead || document.getElementsByTagName('head')[0]).appendChild(script);
return script;
},
removeScriptElement: function(url) {
if (scriptElements[url]) {
Loader.cleanupScriptElement(scriptElements[url], true, !!Loader.getConfig('garbageCollect'));
delete scriptElements[url];
}
return Loader;
},
cleanupScriptElement: function(script, remove, collect) {
var prop;
script.onload = script.onreadystatechange = script.onerror = null;
if (remove) {
Ext.removeNode(script);       
if (collect) {
for (prop in script) {
try {
if (prop != 'src') {
script[prop] = null;
}
delete script[prop];      
} catch (cleanEx) {
}
}
}
}
return Loader;
},
loadScript: function (options) {
var config = Loader.getConfig(),
isString = typeof options == 'string',
url = isString ? options : options.url,
onError = !isString && options.onError,
onLoad = !isString && options.onLoad,
scope = !isString && options.scope,
onScriptError = function() {
Loader.numPendingFiles--;
Loader.scriptsLoading--;
if (onError) {
onError.call(scope, "Failed loading '" + url + "', please verify that the file exists");
}
if (Loader.numPendingFiles + Loader.scriptsLoading === 0) {
Loader.refreshQueue();
}
},
onScriptLoad = function () {
Loader.numPendingFiles--;
Loader.scriptsLoading--;
if (onLoad) {
onLoad.call(scope);
}
if (Loader.numPendingFiles + Loader.scriptsLoading === 0) {
Loader.refreshQueue();
}
},
src;
Loader.isLoading = true;
Loader.numPendingFiles++;
Loader.scriptsLoading++;
src = config.disableCaching ?
(url + '?' + config.disableCachingParam + '=' + Ext.Date.now()) : url;
scriptElements[url] = Loader.injectScriptElement(src, onScriptLoad, onScriptError);
},
loadScriptFile: function(url, onLoad, onError, scope, synchronous) {
if (isFileLoaded[url]) {
return Loader;
}
var config = Loader.getConfig(),
noCacheUrl = url + (config.disableCaching ? ('?' + config.disableCachingParam + '=' + Ext.Date.now()) : ''),
isCrossOriginRestricted = false,
xhr, status, onScriptError;
scope = scope || Loader;
Loader.isLoading = true;
if (!synchronous) {
onScriptError = function() {
};
scriptElements[url] = Loader.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);
} else {
if (typeof XMLHttpRequest != 'undefined') {
xhr = new XMLHttpRequest();
} else {
xhr = new ActiveXObject('Microsoft.XMLHTTP');
}
try {
xhr.open('GET', noCacheUrl, false);
xhr.send(null);
} catch (e) {
isCrossOriginRestricted = true;
}
status = (xhr.status === 1223) ? 204 :
(xhr.status === 0 && ((self.location || {}).protocol == 'file:' || (self.location || {}).protocol == 'ionp:')) ? 200 : xhr.status;
isCrossOriginRestricted = isCrossOriginRestricted || (status === 0);
if (isCrossOriginRestricted
) {
}
else if ((status >= 200 && status < 300) || (status === 304)
) {
Ext.globalEval(xhr.responseText);
onLoad.call(scope);
}
else {
onError.call(Loader);
}
xhr = null;
}
},
syncRequire: function() {
var syncModeEnabled = Loader.syncModeEnabled;
if (!syncModeEnabled) {
Loader.syncModeEnabled = true;
}
Loader.require.apply(Loader, arguments);
if (!syncModeEnabled) {
Loader.syncModeEnabled = false;
}
Loader.refreshQueue();
},
require: function(expressions, fn, scope, excludes) {
var excluded = {},
included = {},
excludedClassNames = [],
possibleClassNames = [],
classNames = [],
references = [],
callback,
syncModeEnabled,
filePath, expression, exclude, className,
possibleClassName, i, j, ln, subLn;
if (excludes) {
excludes = (typeof excludes === 'string') ? [ excludes ] : excludes;
for (i = 0,ln = excludes.length; i < ln; i++) {
exclude = excludes[i];
if (typeof exclude == 'string' && exclude.length > 0) {
excludedClassNames = Manager.getNamesByExpression(exclude);
for (j = 0,subLn = excludedClassNames.length; j < subLn; j++) {
excluded[excludedClassNames[j]] = true;
}
}
}
}
expressions = (typeof expressions === 'string') ? [ expressions ] : (expressions ? expressions : []);
if (fn) {
if (fn.length > 0) {
callback = function() {
var classes = [],
i, ln;
for (i = 0,ln = references.length; i < ln; i++) {
classes.push(Manager.get(references[i]));
}
return fn.apply(this, classes);
};
}
else {
callback = fn;
}
}
else {
callback = Ext.emptyFn;
}
scope = scope || Ext.global;
for (i = 0,ln = expressions.length; i < ln; i++) {
expression = expressions[i];
if (typeof expression == 'string' && expression.length > 0) {
possibleClassNames = Manager.getNamesByExpression(expression);
subLn = possibleClassNames.length;
for (j = 0; j < subLn; j++) {
possibleClassName = possibleClassNames[j];
if (excluded[possibleClassName] !== true) {
references.push(possibleClassName);
if (!Manager.isCreated(possibleClassName) && !included[possibleClassName]) {
included[possibleClassName] = true;
classNames.push(possibleClassName);
}
}
}
}
}
if (classNames.length > 0) {
if (!Loader.config.enabled) {
throw new Error("Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. " +
"Missing required class" + ((classNames.length > 1) ? "es" : "") + ": " + classNames.join(', '));
}
}
else {
callback.call(scope);
return Loader;
}
syncModeEnabled = Loader.syncModeEnabled;
if (!syncModeEnabled) {
queue.push({
requires: classNames.slice(), 
callback: callback,
scope: scope
});
}
ln = classNames.length;
for (i = 0; i < ln; i++) {
className = classNames[i];
filePath = Loader.getPath(className);
if (syncModeEnabled && isClassFileLoaded.hasOwnProperty(className)) {
if (!isClassFileLoaded[className]) {
Loader.numPendingFiles--;
Loader.removeScriptElement(filePath);
delete isClassFileLoaded[className];
}
}
if (!isClassFileLoaded.hasOwnProperty(className)) {
isClassFileLoaded[className] = false;
classNameToFilePathMap[className] = filePath;
Loader.numPendingFiles++;
Loader.loadScriptFile(
filePath,
pass(Loader.onFileLoaded, [className, filePath], Loader),
pass(Loader.onFileLoadError, [className, filePath], Loader),
Loader,
syncModeEnabled
);
}
}
if (syncModeEnabled) {
callback.call(scope);
if (ln === 1) {
return Manager.get(className);
}
}
return Loader;
},
onFileLoaded: function(className, filePath) {
var loaded = isClassFileLoaded[className];
Loader.numLoadedFiles++;
isClassFileLoaded[className] = true;
isFileLoaded[filePath] = true;
if (!loaded) {
Loader.numPendingFiles--;
}
if (Loader.numPendingFiles === 0) {
Loader.refreshQueue();
}
if (!Loader.syncModeEnabled && Loader.numPendingFiles === 0 && Loader.isLoading && !Loader.hasFileLoadError) {
var missingClasses = [],
missingPaths = [],
requires,
i, ln, j, subLn, s;
for (i = 0,ln = queue.length; i < ln; i++) {
requires = queue[i].requires;
for (j = 0,subLn = requires.length; j < subLn; j++) {
if (isClassFileLoaded[s = requires[j]]) {
missingClasses.push(s);
delete Ext.Loader.isClassFileLoaded[s]
Ext.Loader.isFileLoaded[Ext.Loader.getPath(s)] = false
Ext.undefine(s)
}
}
}
if (missingClasses.length < 1) {
return;
}
missingClasses = Ext.Array.filter(Ext.Array.unique(missingClasses), function(item) {
return !requiresMap.hasOwnProperty(item);
}, Loader);
if (missingClasses.length < 1) {
return;
}
for (i = 0,ln = missingClasses.length; i < ln; i++) {
missingPaths.push(classNameToFilePathMap[missingClasses[i]]);
}
console.error("The following classes are not declared even if their files have been " +
"loaded: '" + missingClasses.join("', '") + "'. Please check the source code of their " +
"corresponding files for possible typos: '" + missingPaths.join("', '"));
}
},
onFileLoadError: function(className, filePath, errorMessage, isSynchronous) {
Loader.numPendingFiles--;
Loader.hasFileLoadError = true;
},
addUsedClasses: function (classes) {
var cls, i, ln;
if (classes) {
classes = (typeof classes == 'string') ? [classes] : classes;
for (i = 0, ln = classes.length; i < ln; i++) {
cls = classes[i];
if (typeof cls == 'string' && !Ext.Array.contains(usedClasses, cls)) {
usedClasses.push(cls);
}
}
}
return Loader;
},
triggerReady: function() {
var listener,
refClasses = usedClasses;
if (Loader.isLoading) {
Loader.isLoading = false;
if (refClasses.length !== 0) {
refClasses = refClasses.slice();
usedClasses.length = 0;
Loader.require(refClasses, Loader.triggerReady, Loader);
return Loader;
}
}
Ext.Array.sort(readyListeners, comparePriority);
while (readyListeners.length && !Loader.isLoading) {
listener = readyListeners.shift();
listener.fn.call(listener.scope);
}
return Loader;
},
onReady: function(fn, scope, withDomReady, options) {
var oldFn;
if (withDomReady !== false && Ext.onDocumentReady) {
oldFn = fn;
fn = function() {
Ext.onDocumentReady(oldFn, scope, options);
};
}
if (!Loader.isLoading) {
fn.call(scope);
}
else {
readyListeners.push({
fn: fn,
scope: scope,
priority: (options && options.priority) || 0
});
}
},
historyPush: function(className) {
if (className && isClassFileLoaded.hasOwnProperty(className) && !isInHistory[className]) {
isInHistory[className] = true;
history.push(className);
}
return Loader;
}
});
Ext.disableCacheBuster = function (disable, path) {
var date = new Date();
date.setTime(date.getTime() + (disable ? 10*365 : -1) * 24*60*60*1000);
date = date.toGMTString();
document.cookie = 'ext-cache=1; expires=' + date + '; path='+(path || '/');
};
Ext.require = alias(Loader, 'require');
Ext.syncRequire = alias(Loader, 'syncRequire');
Ext.exclude = alias(Loader, 'exclude');
Ext.onReady = function(fn, scope, options) {
Loader.onReady(fn, scope, true, options);
};
Class.registerPreprocessor('loader', function(cls, data, hooks, continueFn) {
var me = this,
dependencies = [],
dependency,
className = Manager.getName(cls),
i, j, ln, subLn, value, propertyName, propertyValue,
requiredMap, requiredDep;
for (i = 0,ln = dependencyProperties.length; i < ln; i++) {
propertyName = dependencyProperties[i];
if (data.hasOwnProperty(propertyName)) {
propertyValue = data[propertyName];
if (typeof propertyValue == 'string') {
dependencies.push(propertyValue);
}
else if (propertyValue instanceof Array) {
for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
value = propertyValue[j];
if (typeof value == 'string') {
dependencies.push(value);
}
}
}
else if (typeof propertyValue != 'function') {
for (j in propertyValue) {
if (propertyValue.hasOwnProperty(j)) {
value = propertyValue[j];
if (typeof value == 'string') {
dependencies.push(value);
}
}
}
}
}
}
if (dependencies.length === 0) {
return;
}
Loader.require(dependencies, function() {
for (i = 0,ln = dependencyProperties.length; i < ln; i++) {
propertyName = dependencyProperties[i];
if (data.hasOwnProperty(propertyName)) {
propertyValue = data[propertyName];
if (typeof propertyValue == 'string') {
data[propertyName] = Manager.get(propertyValue);
}
else if (propertyValue instanceof Array) {
for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
value = propertyValue[j];
if (typeof value == 'string') {
data[propertyName][j] = Manager.get(value);
}
}
}
else if (typeof propertyValue != 'function') {
for (var k in propertyValue) {
if (propertyValue.hasOwnProperty(k)) {
value = propertyValue[k];
if (typeof value == 'string') {
data[propertyName][k] = Manager.get(value);
}
}
}
}
}
}
continueFn.call(me, cls, data, hooks);
});
return false;
}, true, 'after', 'className');
Manager.registerPostprocessor('uses', function(name, cls, data) {
var uses = data.uses;
if (uses) {
Loader.addUsedClasses(uses);
}
});
Manager.onCreated(Loader.historyPush);
};
if (Ext._classPathMetadata) {
Ext.Loader.addClassPathMappings(Ext._classPathMetadata);
Ext._classPathMetadata = null;
}
(function() {
var scripts = document.getElementsByTagName('script'),
currentScript = scripts[scripts.length - 1],
src = currentScript.src,
path = src.substring(0, src.lastIndexOf('/') + 1),
Loader = Ext.Loader;
Loader.setConfig({
enabled: true,
disableCaching:
true,
paths: {
'Ext': path + 'src'
}
});
})();
Ext._endTime = new Date().getTime();
if (Ext._beforereadyhandler){
Ext._beforereadyhandler();
}
Ext.Error = Ext.extend(Error, {
statics: {
ignore: false,
raise: function(err){
err = err || {};
if (Ext.isString(err)) {
err = { msg: err };
}
var method = this.raise.caller,
msg;
if (method) {
if (method.$name) {
err.sourceMethod = method.$name;
}
if (method.$owner) {
err.sourceClass = method.$owner.$className;
}
}
if (Ext.Error.handle(err) !== true) {
msg = Ext.Error.prototype.toString.call(err);
Ext.log({
msg: msg,
level: 'error',
dump: err,
stack: true
});
throw new Ext.Error(err);
}
},
handle: function(){
return Ext.Error.ignore;
}
},
name: 'Ext.Error',
constructor: function(config){
if (Ext.isString(config)) {
config = { msg: config };
}
var me = this;
Ext.apply(me, config);
me.message = me.message || me.msg; 
},
toString: function(){
var me = this,
className = me.sourceClass ? me.sourceClass : '',
methodName = me.sourceMethod ? '.' + me.sourceMethod + '(): ' : '',
msg = me.msg || '(No description provided)';
return className + methodName + msg;
}
});
Ext.deprecated = function (suggestion) {
return Ext.emptyFn;
};
Ext.JSON = (new(function() {
var me = this,
encodingFunction,
decodingFunction,
useNative = null,
useHasOwn = !! {}.hasOwnProperty,
isNative = function() {
if (useNative === null) {
useNative = Ext.USE_NATIVE_JSON && window.JSON && JSON.toString() == '[object JSON]';
}
return useNative;
},
pad = function(n) {
return n < 10 ? "0" + n : n;
},
doDecode = function(json) {
return eval("(" + json + ')');
},
doEncode = function(o, newline) {
if (o === null || o === undefined) {
return "null";
} else if (Ext.isDate(o)) {
return Ext.JSON.encodeDate(o);
} else if (Ext.isString(o)) {
return Ext.JSON.encodeString(o);
} else if (typeof o == "number") {
return isFinite(o) ? String(o) : "null";
} else if (Ext.isBoolean(o)) {
return String(o);
}
else if (o.toJSON) {
return o.toJSON();
} else if (Ext.isArray(o)) {
return encodeArray(o, newline);
} else if (Ext.isObject(o)) {
return encodeObject(o, newline);
} else if (typeof o === "function") {
return "null";
}
return 'undefined';
},
m = {
"\b": '\\b',
"\t": '\\t',
"\n": '\\n',
"\f": '\\f',
"\r": '\\r',
'"': '\\"',
"\\": '\\\\',
'\x0b': '\\u000b' 
},
charToReplace = /[\\\"\x00-\x1f\x7f-\uffff]/g,
encodeString = function(s) {
return '"' + s.replace(charToReplace, function(a) {
var c = m[a];
return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
}) + '"';
},
encodeArray = function(o, newline) {
var a = ["[", ""], 
len = o.length,
i;
for (i = 0; i < len; i += 1) {
a.push(Ext.JSON.encodeValue(o[i]), ',');
}
a[a.length - 1] = ']';
return a.join("");
},
encodeObject = function(o, newline) {
var a = ["{", ""], 
i, val;
for (i in o) {
val = o[i];
if (!useHasOwn || o.hasOwnProperty(i)) {
if (typeof val === 'function' || val === undefined) {
continue;
}
a.push(Ext.JSON.encodeValue(i), ":", Ext.JSON.encodeValue(val), ',');
}
}
a[a.length - 1] = '}';
return a.join("");
};
me.encodeString = encodeString;
me.encodeValue = doEncode;
me.encodeDate = function(o) {
return '"' + o.getFullYear() + "-"
+ pad(o.getMonth() + 1) + "-"
+ pad(o.getDate()) + "T"
+ pad(o.getHours()) + ":"
+ pad(o.getMinutes()) + ":"
+ pad(o.getSeconds()) + '"';
};
me.encode = function(o) {
if (!encodingFunction) {
encodingFunction = isNative() ? JSON.stringify : me.encodeValue;
}
return encodingFunction(o);
};
me.decode = function(json, safe) {
if (!decodingFunction) {
decodingFunction = isNative() ? JSON.parse : doDecode;
}
try {
return decodingFunction(json);
} catch (e) {
if (safe === true) {
return null;
}
Ext.Error.raise({
sourceClass: "Ext.JSON",
sourceMethod: "decode",
msg: "You're trying to decode an invalid JSON String: " + json
});
}
};
})());
Ext.encode = Ext.JSON.encode;
Ext.decode = Ext.JSON.decode;
Ext.apply(Ext, {
userAgent: navigator.userAgent.toLowerCase(),
cache: {},
idSeed: 1000,
windowId: 'ext-window',
documentId: 'ext-document',
isReady: false,
enableGarbageCollector: true,
enableListenerCollection: true,
rootHierarchyState: {},
addCacheEntry: function(id, el, dom) {
dom = dom || el.dom;
var cache = Ext.cache,
key = id || (el && el.id) || dom.id,
entry = cache[key] || (cache[key] = {
data: {},
events: {},
dom: dom,
skipGarbageCollection: !!(dom.getElementById || dom.navigator)
});
if (el) {
el.$cache = entry;
entry.el = el;
}
return entry;
},
updateCacheEntry: function(cacheItem, dom){
cacheItem.dom = dom;
if (cacheItem.el) {
cacheItem.el.dom = dom;
}
return cacheItem;
},
id: function(el, prefix) {
var me = this,
sandboxPrefix = '';
el = Ext.getDom(el, true) || {};
if (el === document) {
el.id = me.documentId;
}
else if (el === window) {
el.id = me.windowId;
}
if (!el.id) {
if (me.isSandboxed) {
sandboxPrefix = Ext.sandboxName.toLowerCase() + '-';
}
el.id = sandboxPrefix + (prefix || "ext-gen") + (++Ext.idSeed);
}
return el.id;
},
escapeId: (function(){
var validIdRe = /^[a-zA-Z_][a-zA-Z0-9_\-]*$/i,
escapeRx = /([\W]{1})/g,
leadingNumRx = /^(\d)/g,
escapeFn = function(match, capture){
return "\\" + capture;
},
numEscapeFn = function(match, capture){
return '\\00' + capture.charCodeAt(0).toString(16) + ' ';
};
return function(id) {
return validIdRe.test(id)
? id
: id.replace(escapeRx, escapeFn)
.replace(leadingNumRx, numEscapeFn);
};
}()),
getBody: (function() {
var body;
return function() {
return body || (body = Ext.get(document.body));
};
}()),
getHead: (function() {
var head;
return function() {
return head || (head = Ext.get(document.getElementsByTagName("head")[0]));
};
}()),
getDoc: (function() {
var doc;
return function() {
return doc || (doc = Ext.get(document));
};
}()),
getOrientation: function() {
return window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
},
destroy: function() {
var ln = arguments.length,
i, arg;
for (i = 0; i < ln; i++) {
arg = arguments[i];
if (arg) {
if (Ext.isArray(arg)) {
this.destroy.apply(this, arg);
} else if (arg.isStore) {
arg.destroyStore();
} else if (Ext.isFunction(arg.destroy)) {
arg.destroy();
} else if (arg.dom) {
arg.remove();
}
}
}
},
callback: function (callback, scope, args, delay) {
var fn, ret;
if (Ext.isFunction(callback)){
fn = callback;
} else if (scope && Ext.isString(callback)) {
fn = scope[callback];
}
if (fn) {
args = args || [];
scope = scope || window;
if (delay) {
Ext.defer(fn, delay, scope, args);
} else {
ret = fn.apply(scope, args);
}
}
return ret;
},
resolveMethod: function(fn, scope) {
if (Ext.isFunction(fn)) {
return fn;
}
return scope[fn];
},
htmlEncode : function(value) {
return Ext.String.htmlEncode(value);
},
htmlDecode : function(value) {
return Ext.String.htmlDecode(value);
},
urlAppend : function(url, s) {
return Ext.String.urlAppend(url, s);
}
});
Ext.ns = Ext.namespace;
window.undefined = window.undefined;
(function(){
var check = function(regex){
return regex.test(Ext.userAgent);
},
isStrict = document.compatMode == "CSS1Compat",
version = function (is, regex) {
var m;
return (is && (m = regex.exec(Ext.userAgent))) ? parseFloat(m[1]) : 0;
},
docMode = document.documentMode,
isOpera = check(/opera/),
isOpera10_5 = isOpera && check(/version\/10\.5/),
isChrome = check(/\bchrome\b/),
isWebKit = check(/webkit/),
isSafari = !isChrome && check(/safari/),
isSafari2 = isSafari && check(/applewebkit\/4/), 
isSafari3 = isSafari && check(/version\/3/),
isSafari4 = isSafari && check(/version\/4/),
isSafari5_0 = isSafari && check(/version\/5\.0/),
isSafari5 = isSafari && check(/version\/5/),
isIE = !isOpera && (check(/msie/) || check(/trident/)),
isIE7 = isIE && ((check(/msie 7/) && docMode != 8 && docMode != 9 && docMode != 10) || docMode == 7),
isIE8 = isIE && ((check(/msie 8/) && docMode != 7 && docMode != 9 && docMode != 10) || docMode == 8),
isIE9 = isIE && ((check(/msie 9/) && docMode != 7 && docMode != 8 && docMode != 10) || docMode == 9),
isIE10 = isIE && ((check(/msie 10/) && docMode != 7 && docMode != 8 && docMode != 9) || docMode == 10),
isIE11 = isIE && ((check(/trident\/7\.0/) && docMode != 7 && docMode != 8 && docMode != 9 && docMode != 10) || docMode == 11),
isIE6 = isIE && check(/msie 6/),
isGecko = !isWebKit && !isIE && check(/gecko/), 
isGecko3 = isGecko && check(/rv:1\.9/),
isGecko4 = isGecko && check(/rv:2\.0/),
isGecko5 = isGecko && check(/rv:5\./),
isGecko10 = isGecko && check(/rv:10\./),
isFF3_0 = isGecko3 && check(/rv:1\.9\.0/),
isFF3_5 = isGecko3 && check(/rv:1\.9\.1/),
isFF3_6 = isGecko3 && check(/rv:1\.9\.2/),
isWindows = check(/windows|win32/),
isMac = check(/macintosh|mac os x/),
isLinux = check(/linux/),
scrollbarSize = null,
chromeVersion = version(true, /\bchrome\/(\d+\.\d+)/),
firefoxVersion = version(true, /\bfirefox\/(\d+\.\d+)/),
ieVersion = version(isIE, /msie (\d+\.\d+)/),
operaVersion = version(isOpera, /version\/(\d+\.\d+)/),
safariVersion = version(isSafari, /version\/(\d+\.\d+)/),
webKitVersion = version(isWebKit, /webkit\/(\d+\.\d+)/),
isSecure = /^https/i.test(window.location.protocol),
nullLog;
try {
document.execCommand("BackgroundImageCache", false, true);
} catch(e) {}
nullLog = function () {};
nullLog.info = nullLog.warn = nullLog.error = Ext.emptyFn;
Ext.setVersion('ext', '4.2.2.1144');
Ext.setVersion('extjs', '4.2.2.1144');
Ext.apply(Ext, {
SSL_SECURE_URL : isSecure && isIE ? 'javascript:\'\'' : 'about:blank',
plainTableCls: Ext.buildSettings.baseCSSPrefix + 'table-plain',
plainListCls: Ext.buildSettings.baseCSSPrefix + 'list-plain',
enableNestedListenerRemoval : false,
USE_NATIVE_JSON : false,
getDom : function(el, strict) {
if (!el || !document) {
return null;
}
if (el.dom) {
return el.dom;
} else {
if (typeof el == 'string') {
var e = Ext.getElementById(el);
if (e && isIE && strict) {
if (el == e.getAttribute('id')) {
return e;
} else {
return null;
}
}
return e;
} else {
return el;
}
}
},
removeNode : isIE6 || isIE7 || isIE8
? (function() {
var d;
return function(n){
if(n && n.tagName.toUpperCase() != 'BODY'){
(Ext.enableNestedListenerRemoval) ? Ext.EventManager.purgeElement(n) : Ext.EventManager.removeAll(n);
var cache = Ext.cache,
id = n.id;
if (cache[id]) {
delete cache[id].dom;
delete cache[id];
}
if (isIE8 && n.parentNode) {
n.parentNode.removeChild(n);
}
d = d || document.createElement('div');
d.appendChild(n);
d.innerHTML = '';
}
};
}())
: function(n) {
if (n && n.parentNode && n.tagName.toUpperCase() != 'BODY') {
(Ext.enableNestedListenerRemoval) ? Ext.EventManager.purgeElement(n) : Ext.EventManager.removeAll(n);
var cache = Ext.cache,
id = n.id;
if (cache[id]) {
delete cache[id].dom;
delete cache[id];
}
n.parentNode.removeChild(n);
}
},
isStrict: isStrict,
isIEQuirks: isIE && (!isStrict && (isIE6 || isIE7 || isIE8 || isIE9)),
isOpera : isOpera,
isOpera10_5 : isOpera10_5,
isWebKit : isWebKit,
isChrome : isChrome,
isSafari : isSafari,
isSafari3 : isSafari3,
isSafari4 : isSafari4,
isSafari5 : isSafari5,
isSafari5_0 : isSafari5_0,
isSafari2 : isSafari2,
isIE : isIE,
isIE6 : isIE6,
isIE7 : isIE7,
isIE7m : isIE6 || isIE7,
isIE7p : isIE && !isIE6,
isIE8 : isIE8,
isIE8m : isIE6 || isIE7 || isIE8,
isIE8p : isIE && !(isIE6 || isIE7),
isIE9 : isIE9,
isIE9m : isIE6 || isIE7 || isIE8 || isIE9,
isIE9p : isIE && !(isIE6 || isIE7 || isIE8),
isIE10 : isIE10,
isIE10m : isIE6 || isIE7 || isIE8 || isIE9 || isIE10,
isIE10p : isIE && !(isIE6 || isIE7 || isIE8 || isIE9),
isIE11: isIE11, 
isIE11m : isIE6 || isIE7 || isIE8 || isIE9 || isIE10 || isIE11,
isIE11p : isIE && !(isIE6 || isIE7 || isIE8 || isIE9 || isIE10),
isGecko : isGecko,
isGecko3 : isGecko3,
isGecko4 : isGecko4,
isGecko5 : isGecko5,
isGecko10 : isGecko10,
isFF3_0 : isFF3_0,
isFF3_5 : isFF3_5,
isFF3_6 : isFF3_6,
isFF4 : 4 <= firefoxVersion && firefoxVersion < 5,
isFF5 : 5 <= firefoxVersion && firefoxVersion < 6,
isFF10 : 10 <= firefoxVersion && firefoxVersion < 11,
isLinux : isLinux,
isWindows : isWindows,
isMac : isMac,
chromeVersion: chromeVersion,
firefoxVersion: firefoxVersion,
ieVersion: ieVersion,
operaVersion: operaVersion,
safariVersion: safariVersion,
webKitVersion: webKitVersion,
isSecure: isSecure,
BLANK_IMAGE_URL : (isIE6 || isIE7) ? '/' + '/www.sencha.com/s.gif' : 'data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==',
value : function(v, defaultValue, allowBlank){
return Ext.isEmpty(v, allowBlank) ? defaultValue : v;
},
escapeRe : function(s) {
return s.replace(/([-.*+?\^${}()|\[\]\/\\])/g, "\\$1");
},
addBehaviors : function(o){
if(!Ext.isReady){
Ext.onReady(function(){
Ext.addBehaviors(o);
});
} else {
var cache = {}, 
parts,
b,
s;
for (b in o) {
if ((parts = b.split('@'))[1]) { 
s = parts[0];
if(!cache[s]){
cache[s] = Ext.select(s);
}
cache[s].on(parts[1], o[b]);
}
}
cache = null;
}
},
getScrollbarSize: function (force) {
if (!Ext.isReady) {
return {};
}
if (force || !scrollbarSize) {
var db = document.body,
div = document.createElement('div');
div.style.width = div.style.height = '100px';
div.style.overflow = 'scroll';
div.style.position = 'absolute';
db.appendChild(div); 
scrollbarSize = {
width: div.offsetWidth - div.clientWidth,
height: div.offsetHeight - div.clientHeight
};
db.removeChild(div);
}
return scrollbarSize;
},
getScrollBarWidth: function(force){
var size = Ext.getScrollbarSize(force);
return size.width + 2; 
},
copyTo : function(dest, source, names, usePrototypeKeys){
if(typeof names == 'string'){
names = names.split(/[,;\s]/);
}
var n,
nLen = names? names.length : 0,
name;
for(n = 0; n < nLen; n++) {
name = names[n];
if(usePrototypeKeys || source.hasOwnProperty(name)){
dest[name] = source[name];
}
}
return dest;
},
destroyMembers : function(o){
for (var i = 1, a = arguments, len = a.length; i < len; i++) {
Ext.destroy(o[a[i]]);
delete o[a[i]];
}
},
log :
nullLog,
partition : function(arr, truth){
var ret = [[],[]],
a, v,
aLen = arr.length;
for (a = 0; a < aLen; a++) {
v = arr[a];
ret[ (truth && truth(v, a, arr)) || (!truth && v) ? 0 : 1].push(v);
}
return ret;
},
invoke : function(arr, methodName){
var ret  = [],
args = Array.prototype.slice.call(arguments, 2),
a, v,
aLen = arr.length;
for (a = 0; a < aLen; a++) {
v = arr[a];
if (v && typeof v[methodName] == 'function') {
ret.push(v[methodName].apply(v, args));
} else {
ret.push(undefined);
}
}
return ret;
},
zip : function(){
var parts = Ext.partition(arguments, function( val ){ return typeof val != 'function'; }),
arrs = parts[0],
fn = parts[1][0],
len = Ext.max(Ext.pluck(arrs, "length")),
ret = [],
i,
j,
aLen;
for (i = 0; i < len; i++) {
ret[i] = [];
if(fn){
ret[i] = fn.apply(fn, Ext.pluck(arrs, i));
}else{
for (j = 0, aLen = arrs.length; j < aLen; j++){
ret[i].push( arrs[j][i] );
}
}
}
return ret;
},
toSentence: function(items, connector) {
var length = items.length,
head,
tail;
if (length <= 1) {
return items[0];
} else {
head = items.slice(0, length - 1);
tail = items[length - 1];
return Ext.util.Format.format("{0} {1} {2}", head.join(", "), connector || 'and', tail);
}
},
setGlyphFontFamily: function(fontFamily) {
Ext._glyphFontFamily = fontFamily;
},
useShims: isIE6
});
}());
Ext.application = function(config) {
var App, paths, ns,
createApp = function() {
Ext.onReady(function() {
Ext.app.Application.instance = new App();
});
};
if (typeof config === "string") {
Ext.require(config, function() {
App = Ext.ClassManager.get(config);
createApp();
});
}
else {
Ext.Loader.setPath(config.name, config.appFolder || 'app');
if (paths = config.paths) {
for (ns in paths) {
if (paths.hasOwnProperty(ns)) {
Ext.Loader.setPath(ns, paths[ns]);
}
}
}
config['paths processed'] = true;
Ext.define(config.name + ".$application", Ext.apply({
extend: 'Ext.app.Application' 
}, config),
function () {
App = this;
createApp();
});
}
};
(function() {
Ext.ns('Ext.util');
var UtilFormat     = Ext.util.Format = {},
stripTagsRE    = /<\/?[^>]+>/gi,
stripScriptsRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig,
nl2brRe        = /\r?\n/g,
allHashes      = /^#+$/,
formatPattern = /[\d,\.#]+/,
formatCleanRe  = /[^\d\.#]/g,
I18NFormatCleanRe,
formatFns = {};
Ext.apply(UtilFormat, {
thousandSeparator: ',',
decimalSeparator: '.',
currencyPrecision: 2,
currencySign: '$',
currencyAtEnd: false,
undef : function(value) {
return value !== undefined ? value : "";
},
defaultValue : function(value, defaultValue) {
return value !== undefined && value !== '' ? value : defaultValue;
},
substr : 'ab'.substr(-1) != 'b'
? function (value, start, length) {
var str = String(value);
return (start < 0)
? str.substr(Math.max(str.length + start, 0), length)
: str.substr(start, length);
}
: function(value, start, length) {
return String(value).substr(start, length);
},
lowercase : function(value) {
return String(value).toLowerCase();
},
uppercase : function(value) {
return String(value).toUpperCase();
},
usMoney : function(v) {
return UtilFormat.currency(v, '$', 2);
},
currency: function(v, currencySign, decimals, end) {
var negativeSign = '',
format = ",0",
i = 0;
v = v - 0;
if (v < 0) {
v = -v;
negativeSign = '-';
}
decimals = Ext.isDefined(decimals) ? decimals : UtilFormat.currencyPrecision;
format += (decimals > 0 ? '.' : '');
for (; i < decimals; i++) {
format += '0';
}
v = UtilFormat.number(v, format);
if ((end || UtilFormat.currencyAtEnd) === true) {
return Ext.String.format("{0}{1}{2}", negativeSign, v, currencySign || UtilFormat.currencySign);
} else {
return Ext.String.format("{0}{1}{2}", negativeSign, currencySign || UtilFormat.currencySign, v);
}
},
date: function(v, format) {
if (!v) {
return "";
}
if (!Ext.isDate(v)) {
v = new Date(Date.parse(v));
}
return Ext.Date.dateFormat(v, format || Ext.Date.defaultFormat);
},
dateRenderer : function(format) {
return function(v) {
return UtilFormat.date(v, format);
};
},
stripTags : function(v) {
return !v ? v : String(v).replace(stripTagsRE, "");
},
stripScripts : function(v) {
return !v ? v : String(v).replace(stripScriptsRe, "");
},
fileSize : (function(){
var byteLimit = 1024,
kbLimit = 1048576,
mbLimit = 1073741824;
return function(size) {
var out;
if (size < byteLimit) {
if (size === 1) {
out = '1 byte';    
} else {
out = size + ' bytes';
}
} else if (size < kbLimit) {
out = (Math.round(((size*10) / byteLimit))/10) + ' KB';
} else if (size < mbLimit) {
out = (Math.round(((size*10) / kbLimit))/10) + ' MB';
} else {
out = (Math.round(((size*10) / mbLimit))/10) + ' GB';
}
return out;
};
})(),
math : (function(){
var fns = {};
return function(v, a){
if (!fns[a]) {
fns[a] = Ext.functionFactory('v', 'return v ' + a + ';');
}
return fns[a](v);
};
}()),
round : function(value, precision) {
var result = Number(value);
if (typeof precision == 'number') {
precision = Math.pow(10, precision);
result = Math.round(value * precision) / precision;
}
return result;
},
number : function(v, formatString) {
if (!formatString) {
return v;
}
var formatFn = formatFns[formatString];
if (!formatFn) {
var originalFormatString = formatString,
comma = UtilFormat.thousandSeparator,
decimalSeparator = UtilFormat.decimalSeparator,
precision = 0,
trimPart = '',
hasComma,
splitFormat,
extraChars,
multiplier,
trimTrailingZeroes,
code;
if (formatString.substr(formatString.length - 2) == '/i') {
if (!I18NFormatCleanRe) {
I18NFormatCleanRe = new RegExp('[^\\d\\' + UtilFormat.decimalSeparator + ']','g');
}
formatString = formatString.substr(0, formatString.length - 2);
hasComma = formatString.indexOf(comma) != -1;
splitFormat = formatString.replace(I18NFormatCleanRe, '').split(decimalSeparator);
} else {
hasComma = formatString.indexOf(',') != -1;
splitFormat = formatString.replace(formatCleanRe, '').split('.');
}
extraChars = formatString.replace(formatPattern, '');
if (splitFormat.length > 2) {
} else if (splitFormat.length === 2) {
precision = splitFormat[1].length;
trimTrailingZeroes = allHashes.test(splitFormat[1]);
if (trimTrailingZeroes) {
trimPart = 'trailingZeroes=new RegExp(Ext.String.escapeRegex(utilFormat.decimalSeparator) + "?0+$")'
}
}
code = [
'var utilFormat=Ext.util.Format,extNumber=Ext.Number,neg,absVal,fnum,parts' +
(hasComma ? ',thousandSeparator,thousands=[],j,n,i' : '') +
(extraChars  ? ',formatString="' + formatString + '",formatPattern=/[\\d,\\.#]+/' : '') +
',trailingZeroes;' +
'return function(v){' +
'if(typeof v!=="number"&&isNaN(v=extNumber.from(v,NaN)))return"";' +
'neg=v<0;',
'absVal=Math.abs(v);',
'fnum=Ext.Number.toFixed(absVal, ' + precision + ');',
trimPart, ';'
];
if (hasComma) {
if (precision) {
code[code.length] = 'parts=fnum.split(".");';
code[code.length] = 'fnum=parts[0];';
}
code[code.length] =
'if(absVal>=1000) {';
code[code.length] = 'thousandSeparator=utilFormat.thousandSeparator;' +
'thousands.length=0;' +
'j=fnum.length;' +
'n=fnum.length%3||3;' +
'for(i=0;i<j;i+=n){' +
'if(i!==0){' +
'n=3;' +
'}' +
'thousands[thousands.length]=fnum.substr(i,n);' +
'}' +
'fnum=thousands.join(thousandSeparator);' + 
'}';
if (precision) {
code[code.length] = 'fnum += utilFormat.decimalSeparator+parts[1];';
}
} else if (precision) {
code[code.length] = 'if(utilFormat.decimalSeparator!=="."){' +
'parts=fnum.split(".");' +
'fnum=parts[0]+utilFormat.decimalSeparator+parts[1];' +
'}';
}
if (trimTrailingZeroes) {
code[code.length] = 'fnum=fnum.replace(trailingZeroes,"");';
}
code[code.length] = 'if(neg&&fnum!=="' + (precision ? '0.' + Ext.String.repeat('0', precision) : '0') + '")fnum="-"+fnum;';
code[code.length] = 'return ';
if (extraChars) {
code[code.length] = 'formatString.replace(formatPattern, fnum);';
} else {
code[code.length] = 'fnum;';
}
code[code.length] = '};'
formatFn = formatFns[originalFormatString] = Ext.functionFactory('Ext', code.join(''))(Ext);
}
return formatFn(v);
},
numberRenderer : function(format) {
return function(v) {
return UtilFormat.number(v, format);
};
},
attributes: function(attributes) {
if (typeof attributes === 'object') {
var result = [],
name;
for (name in attributes) {
result.push(name, '="', name === 'style' ? Ext.DomHelper.generateStyles(attributes[name], null, true) : Ext.htmlEncode(attributes[name]), '"');
}
attributes = result.join('');
}
return attributes||'';
},
plural : function(v, s, p) {
return v +' ' + (v == 1 ? s : (p ? p : s+'s'));
},
nl2br : function(v) {
return Ext.isEmpty(v) ? '' : v.replace(nl2brRe, '<br/>');
},
capitalize: Ext.String.capitalize,
ellipsis: Ext.String.ellipsis,
format: Ext.String.format,
htmlDecode: Ext.String.htmlDecode,
htmlEncode: Ext.String.htmlEncode,
leftPad: Ext.String.leftPad,
trim : Ext.String.trim,
parseBox : function(box) {
box = box || 0;
if (typeof box === 'number') {
return {
top   : box,
right : box,
bottom: box,
left  : box
};
}
var parts  = box.split(' '),
ln = parts.length;
if (ln == 1) {
parts[1] = parts[2] = parts[3] = parts[0];
}
else if (ln == 2) {
parts[2] = parts[0];
parts[3] = parts[1];
}
else if (ln == 3) {
parts[3] = parts[1];
}
return {
top   :parseInt(parts[0], 10) || 0,
right :parseInt(parts[1], 10) || 0,
bottom:parseInt(parts[2], 10) || 0,
left  :parseInt(parts[3], 10) || 0
};
},
escapeRegex : function(s) {
return s.replace(/([\-.*+?\^${}()|\[\]\/\\])/g, "\\$1");
}
});
}());
Ext.define('Ext.util.TaskRunner', {
interval: 1024,
timerId: null,
constructor: function (interval) {
var me = this;
if (typeof interval == 'number') {
me.interval = interval;
} else if (interval) {
Ext.apply(me, interval);
}
me.tasks = [];
me.timerFn = Ext.Function.bind(me.onTick, me);
},
newTask: function (config) {
var task = new Ext.util.TaskRunner.Task(config);
task.manager = this;
return task;
},
start: function(task) {
var me = this,
now = Ext.Date.now();
if (!task.pending) {
me.tasks.push(task);
task.pending = true; 
}
task.stopped = false; 
task.taskStartTime = now;
task.taskRunTime = task.fireOnStart !== false ? 0 : task.taskStartTime;
task.taskRunCount = 0;
if (!me.firing) {
if (task.fireOnStart !== false) {
me.startTimer(0, now);
} else {
me.startTimer(task.interval, now);
}
}
return task;
},
stop: function(task) {
if (!task.stopped) {
task.stopped = true;
if (task.onStop) {
task.onStop.call(task.scope || task, task);
}
}
return task;
},
stopAll: function() {
Ext.each(this.tasks, this.stop, this);
},
firing: false,
nextExpires: 1e99,
onTick: function () {
var me = this,
tasks = me.tasks,
now = Ext.Date.now(),
nextExpires = 1e99,
len = tasks.length,
expires, newTasks, i, task, rt, remove;
me.timerId = null;
me.firing = true; 
for (i = 0; i < len || i < (len = tasks.length); ++i) {
task = tasks[i];
if (!(remove = task.stopped)) {
expires = task.taskRunTime + task.interval;
if (expires <= now) {
rt = 1; 
try {
rt = task.run.apply(task.scope || task, task.args || [++task.taskRunCount]);
} catch (taskError) {
try {
if (task.onError) {
rt = task.onError.call(task.scope || task, task, taskError);
}
} catch (ignore) { }
}
task.taskRunTime = now;
if (rt === false || task.taskRunCount === task.repeat) {
me.stop(task);
remove = true;
} else {
remove = task.stopped; 
expires = now + task.interval;
}
}
if (!remove && task.duration && task.duration <= (now - task.taskStartTime)) {
me.stop(task);
remove = true;
}
}
if (remove) {
task.pending = false; 
if (!newTasks) {
newTasks = tasks.slice(0, i);
}
} else {
if (newTasks) {
newTasks.push(task); 
}
if (nextExpires > expires) {
nextExpires = expires; 
}
}
}
if (newTasks) {
me.tasks = newTasks;
}
me.firing = false; 
if (me.tasks.length) {
me.startTimer(nextExpires - now, Ext.Date.now());
}
if (me.fireIdleEvent !== false) {
Ext.EventManager.idleEvent.fire();
}
},
startTimer: function (timeout, now) {
var me = this,
expires = now + timeout,
timerId = me.timerId;
if (timerId && me.nextExpires - expires > me.interval) {
clearTimeout(timerId);
timerId = null;
}
if (!timerId) {
if (timeout < me.interval) {
timeout = me.interval;
}
me.timerId = setTimeout(me.timerFn, timeout);
me.nextExpires = expires;
}
}
},
function () {
var me = this,
proto = me.prototype;
proto.destroy = proto.stopAll;
Ext.util.TaskManager = Ext.TaskManager = new me();
me.Task = new Ext.Class({
isTask: true,
stopped: true, 
fireOnStart: false,
constructor: function (config) {
Ext.apply(this, config);
},
restart: function (interval) {
if (interval !== undefined) {
this.interval = interval;
}
this.manager.start(this);
},
start: function (interval) {
if (this.stopped) {
this.restart(interval);
}
},
stop: function () {
this.manager.stop(this);
}
});
proto = me.Task.prototype;
proto.destroy = proto.stop;
});
Ext.define('Ext.util.TaskManager', {
extend:  Ext.util.TaskRunner ,
alternateClassName: [
'Ext.TaskManager'
],
singleton: true
});
Ext.is = {
init : function(navigator) {
var platforms = this.platforms,
ln = platforms.length,
i, platform;
navigator = navigator || window.navigator;
for (i = 0; i < ln; i++) {
platform = platforms[i];
this[platform.identity] = platform.regex.test(navigator[platform.property]);
}
this.Desktop = this.Mac || this.Windows || (this.Linux && !this.Android);
this.Tablet = this.iPad;
this.Phone = !this.Desktop && !this.Tablet;
this.iOS = this.iPhone || this.iPad || this.iPod;
this.Standalone = !!window.navigator.standalone;
},
platforms: [{
property: 'platform',
regex: /iPhone/i,
identity: 'iPhone'
},
{
property: 'platform',
regex: /iPod/i,
identity: 'iPod'
},
{
property: 'userAgent',
regex: /iPad/i,
identity: 'iPad'
},
{
property: 'userAgent',
regex: /Blackberry/i,
identity: 'Blackberry'
},
{
property: 'userAgent',
regex: /Android/i,
identity: 'Android'
},
{
property: 'platform',
regex: /Mac/i,
identity: 'Mac'
},
{
property: 'platform',
regex: /Win/i,
identity: 'Windows'
},
{
property: 'platform',
regex: /Linux/i,
identity: 'Linux'
}]
};
Ext.is.init();
(function(){
var getStyle = function(element, styleName){
var view = element.ownerDocument.defaultView,
style = (view ? view.getComputedStyle(element, null) : element.currentStyle) || element.style;
return style[styleName];
},
supportsVectors = {
'IE6-quirks':  [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0],
'IE6-strict':  [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,0],
'IE7-quirks':  [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0],
'IE7-strict':  [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,0,0,0],
'IE8-quirks':  [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0],
'IE8-strict':  [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,0,1],
'IE9-quirks':  [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0],
'IE9-strict':  [0,1,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,0,0,1],
'IE10-quirks': [1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,1],
'IE10-strict': [1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,1]
};
function getBrowserKey() {
var browser = Ext.isIE6 ? 'IE6' : Ext.isIE7 ? 'IE7' : Ext.isIE8 ? 'IE8' :
Ext.isIE9 ? 'IE9': Ext.isIE10 ? 'IE10' : '';
return browser ? browser + (Ext.isStrict ? '-strict' : '-quirks') : '';
}
Ext.supports = {
init : function() {
var me = this,
doc = document,
toRun = me.toRun || me.tests,
n = toRun.length,
div = n && Ext.isReady && doc.createElement('div'),
notRun = [],
browserKey = getBrowserKey(),
test, vector, value;
if (div) {
div.innerHTML = [
'<div style="height:30px;width:50px;">',
'<div style="height:20px;width:20px;"></div>',
'</div>',
'<div style="width: 200px; height: 200px; position: relative; padding: 5px;">',
'<div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>',
'</div>',
'<div style="position: absolute; left: 10%; top: 10%;"></div>',
'<div style="float:left; background-color:transparent;"></div>'
].join('');
doc.body.appendChild(div);
}
vector = supportsVectors[browserKey];
while (n--) {
test = toRun[n];
value = vector && vector[n];
if (value !== undefined) {
me[test.identity] = value;
} else if (div || test.early) {
me[test.identity] = test.fn.call(me, doc, div);
} else {
notRun.push(test);
}
}
if (div) {
doc.body.removeChild(div);
}
me.toRun = notRun;
},
PointerEvents: 'pointerEvents' in document.documentElement.style,
LocalStorage: (function() {
try {
return 'localStorage' in window && window['localStorage'] !== null;
} catch (e) {
return false;
}
})(),
CSS3BoxShadow: 'boxShadow' in document.documentElement.style || 'WebkitBoxShadow' in document.documentElement.style || 'MozBoxShadow' in document.documentElement.style,
ClassList: !!document.documentElement.classList,
OrientationChange: ((typeof window.orientation != 'undefined') && ('onorientationchange' in window)),
DeviceMotion: ('ondevicemotion' in window),
Touch: ('ontouchstart' in window) && (!Ext.is.Desktop),
TimeoutActualLateness: (function(){
setTimeout(function(){
Ext.supports.TimeoutActualLateness = arguments.length !== 0;
}, 0);
}()),
tests: [
{
identity: 'Transitions',
fn: function(doc, div) {
var prefix = [
'webkit',
'Moz',
'o',
'ms',
'khtml'
],
TE = 'TransitionEnd',
transitionEndName = [
prefix[0] + TE,
'transitionend', 
prefix[2] + TE,
prefix[3] + TE,
prefix[4] + TE
],
ln = prefix.length,
i = 0,
out = false;
for (; i < ln; i++) {
if (getStyle(div, prefix[i] + "TransitionProperty")) {
Ext.supports.CSS3Prefix = prefix[i];
Ext.supports.CSS3TransitionEnd = transitionEndName[i];
out = true;
break;
}
}
return out;
}
},
{
identity: 'RightMargin',
fn: function(doc, div) {
var view = doc.defaultView;
return !(view && view.getComputedStyle(div.firstChild.firstChild, null).marginRight != '0px');
}
},
{
identity: 'DisplayChangeInputSelectionBug',
early: true,
fn: function() {
var webKitVersion = Ext.webKitVersion;
return 0 < webKitVersion && webKitVersion < 533;
}
},
{
identity: 'DisplayChangeTextAreaSelectionBug',
early: true,
fn: function() {
var webKitVersion = Ext.webKitVersion;
return 0 < webKitVersion && webKitVersion < 534.24;
}
},
{
identity: 'TransparentColor',
fn: function(doc, div, view) {
view = doc.defaultView;
return !(view && view.getComputedStyle(div.lastChild, null).backgroundColor != 'transparent');
}
},
{
identity: 'ComputedStyle',
fn: function(doc, div, view) {
view = doc.defaultView;
return view && view.getComputedStyle;
}
},
{
identity: 'Svg',
fn: function(doc) {
return !!doc.createElementNS && !!doc.createElementNS( "http:/" + "/www.w3.org/2000/svg", "svg").createSVGRect;
}
},
{
identity: 'Canvas',
fn: function(doc) {
return !!doc.createElement('canvas').getContext;
}
},
{
identity: 'Vml',
fn: function(doc) {
var d = doc.createElement("div");
d.innerHTML = "<!--[if vml]><br/><br/><![endif]-->";
return (d.childNodes.length == 2);
}
},
{
identity: 'Float',
fn: function(doc, div) {
return !!div.lastChild.style.cssFloat;
}
},
{
identity: 'AudioTag',
fn: function(doc) {
return !!doc.createElement('audio').canPlayType;
}
},
{
identity: 'History',
fn: function() {
var history = window.history;
return !!(history && history.pushState);
}
},
{
identity: 'CSS3DTransform',
fn: function() {
return (typeof WebKitCSSMatrix != 'undefined' && new WebKitCSSMatrix().hasOwnProperty('m41'));
}
},
{
identity: 'CSS3LinearGradient',
fn: function(doc, div) {
var property = 'background-image:',
webkit   = '-webkit-gradient(linear, left top, right bottom, from(black), to(white))',
w3c      = 'linear-gradient(left top, black, white)',
moz      = '-moz-' + w3c,
ms       = '-ms-' + w3c,
opera    = '-o-' + w3c,
options  = [property + webkit, property + w3c, property + moz, property + ms, property + opera];
div.style.cssText = options.join(';');
return (("" + div.style.backgroundImage).indexOf('gradient') !== -1) && !Ext.isIE9;
}
},
{
identity: 'CSS3BorderRadius',
fn: function(doc, div) {
var domPrefixes = ['borderRadius', 'BorderRadius', 'MozBorderRadius', 'WebkitBorderRadius', 'OBorderRadius', 'KhtmlBorderRadius'],
pass = false,
i;
for (i = 0; i < domPrefixes.length; i++) {
if (document.body.style[domPrefixes[i]] !== undefined) {
return true;
}
}
return pass;
}
},
{
identity: 'GeoLocation',
fn: function() {
return (typeof navigator != 'undefined' && 'geolocation' in navigator) || (typeof google != 'undefined' && typeof google.gears != 'undefined');
}
},
{
identity: 'MouseEnterLeave',
fn: function(doc, div){
return ('onmouseenter' in div && 'onmouseleave' in div);
}
},
{
identity: 'MouseWheel',
fn: function(doc, div) {
return ('onmousewheel' in div);
}
},
{
identity: 'Opacity',
fn: function(doc, div){
if (Ext.isIE6 || Ext.isIE7 || Ext.isIE8) {
return false;
}
div.firstChild.style.cssText = 'opacity:0.73';
return div.firstChild.style.opacity == '0.73';
}
},
{
identity: 'Placeholder',
fn: function(doc) {
return 'placeholder' in doc.createElement('input');
}
},
{
identity: 'Direct2DBug',
fn: function() {
return Ext.isString(document.body.style.msTransformOrigin) && Ext.isIE10m;
}
},
{
identity: 'BoundingClientRect',
fn: function(doc, div) {
return Ext.isFunction(div.getBoundingClientRect);
}
},
{
identity: 'RotatedBoundingClientRect',
fn: function() {
var body = document.body,
supports = false,
el = document.createElement('div'),
style = el.style;
if (el.getBoundingClientRect) {
style.WebkitTransform = style.MozTransform =
style.OTransform = style.transform = 'rotate(90deg)';
style.width = '100px';
style.height = '30px';
body.appendChild(el)
supports = el.getBoundingClientRect().height !== 100;
body.removeChild(el);
}
return supports;
}
},
{
identity: 'IncludePaddingInWidthCalculation',
fn: function(doc, div){
return div.childNodes[1].firstChild.offsetWidth == 210;
}
},
{
identity: 'IncludePaddingInHeightCalculation',
fn: function(doc, div){
return div.childNodes[1].firstChild.offsetHeight == 210;
}
},
{
identity: 'ArraySort',
fn: function() {
var a = [1,2,3,4,5].sort(function(){ return 0; });
return a[0] === 1 && a[1] === 2 && a[2] === 3 && a[3] === 4 && a[4] === 5;
}
},
{
identity: 'Range',
fn: function() {
return !!document.createRange;
}
},
{
identity: 'CreateContextualFragment',
fn: function() {
var range = Ext.supports.Range ? document.createRange() : false;
return range && !!range.createContextualFragment;
}
},
{
identity: 'WindowOnError',
fn: function () {
return Ext.isIE || Ext.isGecko || Ext.webKitVersion >= 534.16; 
}
},
{
identity: 'TextAreaMaxLength',
fn: function(){
var el = document.createElement('textarea');
return ('maxlength' in el);
}
},
{
identity: 'GetPositionPercentage',
fn: function(doc, div){
return getStyle(div.childNodes[2], 'left') == '10%';
}
},
{
identity: 'PercentageHeightOverflowBug',
fn: function(doc) {
var hasBug = false,
style, el;
if (Ext.getScrollbarSize().height) {
el = doc.createElement('div');
style = el.style;
style.height = '50px';
style.width = '50px';
style.overflow = 'auto';
style.position = 'absolute';
el.innerHTML = [
'<div style="display:table;height:100%;">',
'<div style="width:51px;"></div>',
'</div>'
].join('');
doc.body.appendChild(el);
if (el.firstChild.offsetHeight === 50) {
hasBug = true;
}
doc.body.removeChild(el);
}
return hasBug;
}
},
{
identity: 'xOriginBug',
fn: function(doc, div) {
div.innerHTML = '<div id="b1" style="height:100px;width:100px;direction:rtl;position:relative;overflow:scroll">' +
'<div id="b2" style="position:relative;width:100%;height:20px;"></div>' +
'<div id="b3" style="position:absolute;width:20px;height:20px;top:0px;right:0px"></div>' +
'</div>';
var outerBox = document.getElementById('b1').getBoundingClientRect(),
b2 = document.getElementById('b2').getBoundingClientRect(),
b3 = document.getElementById('b3').getBoundingClientRect();
return (b2.left !== outerBox.left && b3.right !== outerBox.right);
}
},
{
identity: 'ScrollWidthInlinePaddingBug',
fn: function(doc) {
var hasBug = false,
style, el;
el = doc.createElement('div');
style = el.style;
style.height = '50px';
style.width = '50px';
style.padding = '10px';
style.overflow = 'hidden';
style.position = 'absolute';
el.innerHTML =
'<span style="display:inline-block;zoom:1;height:60px;width:60px;"></span>';
doc.body.appendChild(el);
if (el.scrollWidth === 70) {
hasBug = true;
}
doc.body.removeChild(el);
return hasBug;
}
}
]
};
}());
Ext.supports.init(); 
Ext.util.DelayedTask = function(fn, scope, args, cancelOnDelay) {
var me = this,
delay,
call = function() {
clearInterval(me.id);
me.id = null;
fn.apply(scope, args || []);
Ext.EventManager.idleEvent.fire();
};
cancelOnDelay = typeof cancelOnDelay === 'boolean' ? cancelOnDelay : true;
me.id = null;
me.delay = function(newDelay, newFn, newScope, newArgs) {
if (cancelOnDelay) {
me.cancel();
}
if (typeof newDelay === 'number') {
delay = newDelay;
}
fn    = newFn    || fn;
scope = newScope || scope;
args  = newArgs  || args;
if (!me.id) {
me.id = setInterval(call, delay);
}
};
me.cancel = function() {
if (me.id) {
clearInterval(me.id);
me.id = null;
}
};
};
Ext.define('Ext.util.Event', function() {
var arraySlice = Array.prototype.slice,
arrayInsert = Ext.Array.insert,
toArray = Ext.Array.toArray,
DelayedTask = Ext.util.DelayedTask;
return {
isEvent: true,
suspended: 0,
noOptions: {},
constructor: function(observable, name) {
this.name = name;
this.observable = observable;
this.listeners = [];
},
addListener: function(fn, scope, options) {
var me = this,
listeners, listener, priority, isNegativePriority, highestNegativePriorityIndex,
hasNegativePriorityIndex, length, index, i, listenerPriority;
scope = scope || me.observable;
if (!me.isListening(fn, scope)) {
listener = me.createListener(fn, scope, options);
if (me.firing) {
me.listeners = me.listeners.slice(0);
}
listeners = me.listeners;
index = length = listeners.length;
priority = options && options.priority;
highestNegativePriorityIndex = me._highestNegativePriorityIndex;
hasNegativePriorityIndex = (highestNegativePriorityIndex !== undefined);
if (priority) {
isNegativePriority = (priority < 0);
if (!isNegativePriority || hasNegativePriorityIndex) {
for(i = (isNegativePriority ? highestNegativePriorityIndex : 0); i < length; i++) {
listenerPriority = listeners[i].o ? listeners[i].o.priority||0 : 0;
if (listenerPriority < priority) {
index = i;
break;
}
}
} else {
me._highestNegativePriorityIndex = index;
}
} else if (hasNegativePriorityIndex) {
index = highestNegativePriorityIndex;
}
if (!isNegativePriority && index <= highestNegativePriorityIndex) {
me._highestNegativePriorityIndex ++;
}
if (index === length) {
me.listeners[length] = listener;
} else {
arrayInsert(me.listeners, index, [listener]);
}
}
},
createListener: function(fn, scope, o) {
scope = scope || this.observable;
var me = this,
listener = {
fn: fn,
scope: scope,
ev: me
},
handler = fn;
if (o) {
listener.o = o;
if (o.single) {
handler = me.createSingle(handler, listener, o, scope);
}
if (o.target) {
handler = me.createTargeted(handler, listener, o, scope);
}
if (o.delay) {
handler = me.createDelayed(handler, listener, o, scope);
}
if (o.buffer) {
handler = me.createBuffered(handler, listener, o, scope);
}
}
listener.fireFn = handler;
return listener;
},
findListener: function(fn, scope) {
var listeners = this.listeners,
i = listeners.length,
listener,
s;
while (i--) {
listener = listeners[i];
if (listener) {
s = listener.scope;
if (listener.fn == fn && (s == (scope || this.observable))) {
return i;
}
}
}
return - 1;
},
isListening: function(fn, scope) {
return this.findListener(fn, scope) !== -1;
},
removeListener: function(fn, scope) {
var me = this,
index,
listener,
highestNegativePriorityIndex,
k;
index = me.findListener(fn, scope);
if (index != -1) {
listener = me.listeners[index];
highestNegativePriorityIndex = me._highestNegativePriorityIndex;
if (me.firing) {
me.listeners = me.listeners.slice(0);
}
if (listener.task) {
listener.task.cancel();
delete listener.task;
}
k = listener.tasks && listener.tasks.length;
if (k) {
while (k--) {
listener.tasks[k].cancel();
}
delete listener.tasks;
}
me.listeners.splice(index, 1);
if (highestNegativePriorityIndex) {
if (index < highestNegativePriorityIndex) {
me._highestNegativePriorityIndex --;
} else if (index === highestNegativePriorityIndex && index === me.listeners.length) {
delete me._highestNegativePriorityIndex;
}
}
return true;
}
return false;
},
clearListeners: function() {
var listeners = this.listeners,
i = listeners.length;
while (i--) {
this.removeListener(listeners[i].fn, listeners[i].scope);
}
},
suspend: function() {
this.suspended += 1;
},
resume: function() {
if (this.suspended) {
this.suspended--;
}
},
fire: function() {
var me = this,
listeners = me.listeners,
count = listeners.length,
i,
args,
listener,
len;
if (!me.suspended && count > 0) {
me.firing = true;
args = arguments.length ? arraySlice.call(arguments, 0) : []
len = args.length;
for (i = 0; i < count; i++) {
listener = listeners[i];
if (listener.o) {
args[len] = listener.o;
}
if (listener && listener.fireFn.apply(listener.scope || me.observable, args) === false) {
return (me.firing = false);
}
}
}
me.firing = false;
return true;
},
createTargeted: function (handler, listener, o, scope) {
return function(){
if (o.target === arguments[0]){
handler.apply(scope, arguments);
}
};
},
createBuffered: function (handler, listener, o, scope) {
listener.task = new DelayedTask();
return function() {
listener.task.delay(o.buffer, handler, scope, toArray(arguments));
};
},
createDelayed: function (handler, listener, o, scope) {
return function() {
var task = new DelayedTask();
if (!listener.tasks) {
listener.tasks = [];
}
listener.tasks.push(task);
task.delay(o.delay || 10, handler, scope, toArray(arguments));
};
},
createSingle: function (handler, listener, o, scope) {
return function() {
var event = listener.ev;
if (event.removeListener(listener.fn, scope) && event.observable) {
event.observable.hasListeners[event.name]--;
}
return handler.apply(scope, arguments);
};
}
};
});
Ext.EventManager = new function() {
var EventManager = this,
doc = document,
win = window,
escapeRx = /\\/g,
prefix = Ext.baseCSSPrefix,
supportsAddEventListener = !Ext.isIE9 && 'addEventListener' in doc,
readyEvent,
initExtCss = function() {
var bd = doc.body || doc.getElementsByTagName('body')[0],
cls = [],
htmlCls = [],
supportsLG = Ext.supports.CSS3LinearGradient,
supportsBR = Ext.supports.CSS3BorderRadius,
html;
if (!Ext.scopeCss) {
cls.push(prefix + 'body');
}
if (!bd) {
return false;
}
html = bd.parentNode;
function add (c) {
cls.push(prefix + c);
}
if (Ext.isIE && Ext.isIE9m) {
add('ie');
if (Ext.isIE6) {
add('ie6');
} else { 
add('ie7p');
if (Ext.isIE7) {
add('ie7');
} else {
add('ie8p');
if (Ext.isIE8) {
add('ie8');
} else {
add('ie9p');
if (Ext.isIE9) {
add('ie9');
}
}
}
}
if (Ext.isIE7m) {
add('ie7m');
}
if (Ext.isIE8m) {
add('ie8m');
}
if (Ext.isIE9m) {
add('ie9m');
}
if (Ext.isIE7 || Ext.isIE8) {
add('ie78');
}
}
if (Ext.isIE10) {
add('ie10');
}
if (Ext.isGecko) {
add('gecko');
if (Ext.isGecko3) {
add('gecko3');
}
if (Ext.isGecko4) {
add('gecko4');
}
if (Ext.isGecko5) {
add('gecko5');
}
}
if (Ext.isOpera) {
add('opera');
}
if (Ext.isWebKit) {
add('webkit');
}
if (Ext.isSafari) {
add('safari');
if (Ext.isSafari2) {
add('safari2');
}
if (Ext.isSafari3) {
add('safari3');
}
if (Ext.isSafari4) {
add('safari4');
}
if (Ext.isSafari5) {
add('safari5');
}
if (Ext.isSafari5_0) {
add('safari5_0')
}
}
if (Ext.isChrome) {
add('chrome');
}
if (Ext.isMac) {
add('mac');
}
if (Ext.isLinux) {
add('linux');
}
if (!supportsBR) {
add('nbr');
}
if (!supportsLG) {
add('nlg');
}
if (html) {
if (Ext.isStrict && (Ext.isIE6 || Ext.isIE7)) {
Ext.isBorderBox = false;
}
else {
Ext.isBorderBox = true;
}
if(!Ext.isBorderBox) {
htmlCls.push(prefix + 'content-box');
}
if (Ext.isStrict) {
htmlCls.push(prefix + 'strict');
} else {
htmlCls.push(prefix + 'quirks');
}
Ext.fly(html, '_internal').addCls(htmlCls);
}
Ext.fly(bd, '_internal').addCls(cls);
return true;
};
Ext.apply(EventManager, {
hasBoundOnReady: false,
hasFiredReady: false,
deferReadyEvent : 1,
onReadyChain : [],
readyEvent:
(function () {
readyEvent = new Ext.util.Event();
readyEvent.fire = function () {
Ext._beforeReadyTime = Ext._beforeReadyTime || new Date().getTime();
readyEvent.self.prototype.fire.apply(readyEvent, arguments);
Ext._afterReadytime = new Date().getTime();
};
return readyEvent;
}()),
idleEvent: new Ext.util.Event(),
isReadyPaused: function(){
return (/[?&]ext-pauseReadyFire\b/i.test(location.search) && !Ext._continueFireReady);
},
bindReadyEvent: function() {
if (EventManager.hasBoundOnReady) {
return;
}
if ( doc.readyState == 'complete'  ) {  
EventManager.onReadyEvent({
type: doc.readyState || 'body'
});
} else {
doc.addEventListener('DOMContentLoaded', EventManager.onReadyEvent, false);
win.addEventListener('load', EventManager.onReadyEvent, false);
EventManager.hasBoundOnReady = true;
}
},
onReadyEvent : function(e) {
if (e && e.type) {
EventManager.onReadyChain.push(e.type);
}
if (EventManager.hasBoundOnReady) {
doc.removeEventListener('DOMContentLoaded', EventManager.onReadyEvent, false);
win.removeEventListener('load', EventManager.onReadyEvent, false);
}
if (!Ext.isReady) {
EventManager.fireDocReady();
}
},
fireDocReady: function() {
if (!Ext.isReady) {
Ext._readyTime = new Date().getTime();
Ext.isReady = true;
Ext.supports.init();
EventManager.onWindowUnload();
readyEvent.onReadyChain = EventManager.onReadyChain;    
if (Ext.isNumber(EventManager.deferReadyEvent)) {
Ext.Function.defer(EventManager.fireReadyEvent, EventManager.deferReadyEvent);
EventManager.hasDocReadyTimer = true;
} else {
EventManager.fireReadyEvent();
}
}
},
fireReadyEvent: function() {
EventManager.hasDocReadyTimer = false;
EventManager.isFiring = true;
while (readyEvent.listeners.length && !EventManager.isReadyPaused()) {
readyEvent.fire();
}
EventManager.isFiring = false;
EventManager.hasFiredReady = true;
Ext.EventManager.idleEvent.fire();
},
onDocumentReady: function(fn, scope, options) {
options = options || {};
options.single = true;
readyEvent.addListener(fn, scope, options);
if (!(EventManager.isFiring || EventManager.hasDocReadyTimer)) {
if (Ext.isReady) {
EventManager.fireReadyEvent();
} else {
EventManager.bindReadyEvent();
}
}
},
stoppedMouseDownEvent: new Ext.util.Event(),
propRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|freezeEvent)$/,
getId : function(element) {
var id;
element = Ext.getDom(element);
if (element === doc || element === win) {
id = element === doc ? Ext.documentId : Ext.windowId;
}
else {
id = Ext.id(element);
}
if (!Ext.cache[id]) {
Ext.addCacheEntry(id, null, element);
}
return id;
},
prepareListenerConfig: function(element, config, isRemove) {
var propRe = EventManager.propRe,
key, value, args;
for (key in config) {
if (config.hasOwnProperty(key)) {
if (!propRe.test(key)) {
value = config[key];
if (typeof value == 'function') {
args = [element, key, value, config.scope, config];
} else {
args = [element, key, value.fn, value.scope, value];
}
if (isRemove) {
EventManager.removeListener.apply(EventManager, args);
} else {
EventManager.addListener.apply(EventManager, args);
}
}
}
}
},
mouseEnterLeaveRe: /mouseenter|mouseleave/,
normalizeEvent: function(eventName, fn) {
if (EventManager.mouseEnterLeaveRe.test(eventName) && !Ext.supports.MouseEnterLeave) {
if (fn) {
fn = Ext.Function.createInterceptor(fn, EventManager.contains);
}
eventName = eventName == 'mouseenter' ? 'mouseover' : 'mouseout';
} else if (eventName == 'mousewheel' && !Ext.supports.MouseWheel && !Ext.isOpera) {
eventName = 'DOMMouseScroll';
}
return {
eventName: eventName,
fn: fn
};
},
contains: function(event) {
event = event.browserEvent || event;
var parent = event.currentTarget,
child = EventManager.getRelatedTarget(event);
if (parent && parent.firstChild) {
while (child) {
if (child === parent) {
return false;
}
child = child.parentNode;
if (child && (child.nodeType != 1)) {
child = null;
}
}
}
return true;
},
addListener: function(element, eventName, fn, scope, options) {
if (typeof eventName !== 'string') {
EventManager.prepareListenerConfig(element, eventName);
return;
}
var dom = element.dom || Ext.getDom(element),
hasAddEventListener, bind, wrap, cache, id, cacheItem, capture;
if (typeof fn === 'string') {
fn = Ext.resolveMethod(fn, scope || element);
}
options = options || {};
bind = EventManager.normalizeEvent(eventName, fn);
wrap = EventManager.createListenerWrap(dom, eventName, bind.fn, scope, options);
cache = EventManager.getEventListenerCache(element.dom ? element : dom, eventName);
eventName = bind.eventName;
hasAddEventListener = supportsAddEventListener || (Ext.isIE9 && !dom.attachEvent);
if (!hasAddEventListener) {
id = EventManager.normalizeId(dom);
if (id) {
cacheItem = Ext.cache[id][eventName];
if (cacheItem && cacheItem.firing) {
cache = EventManager.cloneEventListenerCache(dom, eventName);
}
}
}
capture = !!options.capture;
cache.push({
fn: fn,
wrap: wrap,
scope: scope,
capture: capture 
});
if (!hasAddEventListener) {
if (cache.length === 1) {
id = EventManager.normalizeId(dom, true);
fn = Ext.Function.bind(EventManager.handleSingleEvent, EventManager, [id, eventName], true);
Ext.cache[id][eventName] = {
firing: false,
fn: fn
};
dom.attachEvent('on' + eventName, fn);
}
} else {
dom.addEventListener(eventName, wrap, capture);
}
if (dom == doc && eventName == 'mousedown') {
EventManager.stoppedMouseDownEvent.addListener(wrap);
}
},
normalizeId: function(dom, force) {
var id;
if (dom === document) {
id = Ext.documentId;
} else if (dom === window) {
id = Ext.windowId;
} else {
id = dom.id;
}
if (!id && force) {
id = EventManager.getId(dom);
}
return id;
},
handleSingleEvent: function(e, id, eventName) {
var listenerCache = EventManager.getEventListenerCache(id, eventName),
attachItem = Ext.cache[id][eventName],
len, i;
if (attachItem.firing) {
return;
}
attachItem.firing = true;
for (i = 0, len = listenerCache.length; i < len; ++i) {
listenerCache[i].wrap(e);
}
attachItem.firing = false;
},
removeListener : function(element, eventName, fn, scope) {
if (typeof eventName !== 'string') {
EventManager.prepareListenerConfig(element, eventName, true);
return;
}
var dom = Ext.getDom(element),
id, el = element.dom ? element : Ext.get(dom),
cache = EventManager.getEventListenerCache(el, eventName),
bindName = EventManager.normalizeEvent(eventName).eventName,
i = cache.length, j, cacheItem, hasRemoveEventListener,
listener, wrap;
if (!dom) {
return;
}
hasRemoveEventListener = supportsAddEventListener || (Ext.isIE9 && !dom.detachEvent);
if (typeof fn === 'string') {
fn = Ext.resolveMethod(fn, scope || element);
}
while (i--) {
listener = cache[i];
if (listener && (!fn || listener.fn == fn) && (!scope || listener.scope === scope)) {
wrap = listener.wrap;
if (wrap.task) {
clearTimeout(wrap.task);
delete wrap.task;
}
j = wrap.tasks && wrap.tasks.length;
if (j) {
while (j--) {
clearTimeout(wrap.tasks[j]);
}
delete wrap.tasks;
}
if (!hasRemoveEventListener) {
id = EventManager.normalizeId(dom, true);
cacheItem = Ext.cache[id][bindName];
if (cacheItem && cacheItem.firing) {
cache = EventManager.cloneEventListenerCache(dom, bindName);
}
if (cache.length === 1) {
fn = cacheItem.fn;
delete Ext.cache[id][bindName];
dom.detachEvent('on' + bindName, fn);
}
} else {
dom.removeEventListener(bindName, wrap, listener.capture);
}
if (wrap && dom == doc && eventName == 'mousedown') {
EventManager.stoppedMouseDownEvent.removeListener(wrap);
}
Ext.Array.erase(cache, i, 1);
}
}
},
removeAll : function(element) {
var id = (typeof element === 'string') ? element : element.id,
cache, events, eventName;
if (id && (cache = Ext.cache[id])) {
events = cache.events;
for (eventName in events) {
if (events.hasOwnProperty(eventName)) {
EventManager.removeListener(element, eventName);
}
}
cache.events = {};
}
},
purgeElement : function(element, eventName) {
var dom = Ext.getDom(element),
i = 0, len, childNodes;
if (eventName) {
EventManager.removeListener(element, eventName);
} else {
EventManager.removeAll(element);
}
if (dom && dom.childNodes) {
childNodes = dom.childNodes;
for (len = childNodes.length; i < len; i++) {
EventManager.purgeElement(childNodes[i], eventName);
}
}
},
createListenerWrap : function(dom, ename, fn, scope, options) {
options = options || {};
var gen, wrap = function(e, args) {
var f;
if (!gen) {
f = ['if(!' + Ext.name + ') {return;}'];
if (options.buffer || options.delay || options.freezeEvent) {
if (options.freezeEvent) {
f.push('e = X.EventObject.setEvent(e);');
}
f.push('e = new X.EventObjectImpl(e, ' + (options.freezeEvent ? 'true' : 'false' ) + ');');
} else {
f.push('e = X.EventObject.setEvent(e);');
}
if (options.delegate) {
f.push('var result, t = e.getTarget("' + (options.delegate + '').replace(escapeRx, '\\\\') + '", this);');
f.push('if(!t) {return;}');
} else {
f.push('var t = e.target, result;');
}
if (options.target) {
f.push('if(e.target !== options.target) {return;}');
}
if (options.stopEvent) {
f.push('e.stopEvent();');
} else {
if(options.preventDefault) {
f.push('e.preventDefault();');
}
if(options.stopPropagation) {
f.push('e.stopPropagation();');
}
}
if (options.normalized === false) {
f.push('e = e.browserEvent;');
}
if (options.buffer) {
f.push('(wrap.task && clearTimeout(wrap.task));');
f.push('wrap.task = setTimeout(function() {');
}
if (options.delay) {
f.push('wrap.tasks = wrap.tasks || [];');
f.push('wrap.tasks.push(setTimeout(function() {');
}
f.push('result = fn.call(scope || dom, e, t, options);');
if (options.single) {
f.push('evtMgr.removeListener(dom, ename, fn, scope);');
}
if (ename !== 'mousemove' && ename !== 'unload') {
f.push('if (evtMgr.idleEvent.listeners.length) {');
f.push('evtMgr.idleEvent.fire();');
f.push('}');
}
if (options.delay) {
f.push('}, ' + options.delay + '));');
}
if (options.buffer) {
f.push('}, ' + options.buffer + ');');
}
f.push('return result;');
gen = Ext.cacheableFunctionFactory('e', 'options', 'fn', 'scope', 'ename', 'dom', 'wrap', 'args', 'X', 'evtMgr', f.join('\n'));
}
return gen.call(dom, e, options, fn, scope, ename, dom, wrap, args, Ext, EventManager);
};
return wrap;
},
getEventCache: function(element) {
var elementCache, eventCache, id;
if (!element) {
return [];
}
if (element.$cache) {
elementCache = element.$cache;
} else {
if (typeof element === 'string') {
id = element;
} else {
id = EventManager.getId(element);
}
elementCache = Ext.cache[id];
}
eventCache = elementCache.events || (elementCache.events = {});
return eventCache;
},
getEventListenerCache : function(element, eventName) {
var eventCache = EventManager.getEventCache(element);
return eventCache[eventName] || (eventCache[eventName] = []);
},
cloneEventListenerCache: function(element, eventName){
var eventCache = EventManager.getEventCache(element),
out;
if (eventCache[eventName]) {
out = eventCache[eventName].slice(0);
} else {
out = [];
}
eventCache[eventName] = out;
return out;
},
mouseLeaveRe: /(mouseout|mouseleave)/,
mouseEnterRe: /(mouseover|mouseenter)/,
stopEvent: function(event) {
EventManager.stopPropagation(event);
EventManager.preventDefault(event);
},
stopPropagation: function(event) {
event = event.browserEvent || event;
if (event.stopPropagation) {
event.stopPropagation();
} else {
event.cancelBubble = true;
}
},
preventDefault: function(event) {
event = event.browserEvent || event;
if (event.preventDefault) {
event.preventDefault();
} else {
event.returnValue = false;
try {
if (event.ctrlKey || event.keyCode > 111 && event.keyCode < 124) {
event.keyCode = -1;
}
} catch (e) {
}
}
},
getRelatedTarget: function(event) {
event = event.browserEvent || event;
var target = event.relatedTarget;
if (!target) {
if (EventManager.mouseLeaveRe.test(event.type)) {
target = event.toElement;
} else if (EventManager.mouseEnterRe.test(event.type)) {
target = event.fromElement;
}
}
return EventManager.resolveTextNode(target);
},
getPageX: function(event) {
return EventManager.getPageXY(event)[0];
},
getPageY: function(event) {
return EventManager.getPageXY(event)[1];
},
getPageXY: function(event) {
event = event.browserEvent || event;
var x = event.pageX,
y = event.pageY,
docEl = doc.documentElement,
body = doc.body;
if (!x && x !== 0) {
x = event.clientX + (docEl && docEl.scrollLeft || body && body.scrollLeft || 0) - (docEl && docEl.clientLeft || body && body.clientLeft || 0);
y = event.clientY + (docEl && docEl.scrollTop  || body && body.scrollTop  || 0) - (docEl && docEl.clientTop  || body && body.clientTop  || 0);
}
return [x, y];
},
getTarget: function(event) {
event = event.browserEvent || event;
return EventManager.resolveTextNode(event.target || event.srcElement);
},
resolveTextNode: Ext.isGecko ?
function(node) {
if (node) {
var s = HTMLElement.prototype.toString.call(node);
if (s !== '[xpconnect wrapped native prototype]' && s !== '[object XULElement]') {
return node.nodeType == 3 ? node.parentNode: node;
}
}
}
:
function(node) {
return node && node.nodeType == 3 ? node.parentNode: node;
},
curWidth: 0,
curHeight: 0,
onWindowResize: function(fn, scope, options) {
var resize = EventManager.resizeEvent;
if (!resize) {
EventManager.resizeEvent = resize = new Ext.util.Event();
EventManager.on(win, 'resize', EventManager.fireResize, null, {buffer: 100});
}
resize.addListener(fn, scope, options);
},
fireResize: function() {
var w = Ext.Element.getViewWidth(),
h = Ext.Element.getViewHeight();
if (EventManager.curHeight != h || EventManager.curWidth != w) {
EventManager.curHeight = h;
EventManager.curWidth = w;
EventManager.resizeEvent.fire(w, h);
}
},
removeResizeListener: function(fn, scope) {
var resize = EventManager.resizeEvent;
if (resize) {
resize.removeListener(fn, scope);
}
},
onWindowUnload: function(fn, scope, options) {
var unload = EventManager.unloadEvent;
if (!unload) {
EventManager.unloadEvent = unload = new Ext.util.Event();
EventManager.addListener(win, 'unload', EventManager.fireUnload);
}
if (fn) {
unload.addListener(fn, scope, options);
}
},
fireUnload: function() {
try {
doc = win = undefined;
var gridviews, i, ln,
el, cache;
EventManager.unloadEvent.fire();
if (Ext.isGecko3) {
gridviews = Ext.ComponentQuery.query('gridview');
i = 0;
ln = gridviews.length;
for (; i < ln; i++) {
gridviews[i].scrollToTop();
}
}
cache = Ext.cache;
for (el in cache) {
if (cache.hasOwnProperty(el)) {
EventManager.removeAll(el);
}
}
} catch(e) {
}
},
removeUnloadListener: function(fn, scope) {
var unload = EventManager.unloadEvent;
if (unload) {
unload.removeListener(fn, scope);
}
},
useKeyDown: Ext.isWebKit ?
parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) >= 525 :
!((Ext.isGecko && !Ext.isWindows) || (Ext.isOpera && Ext.operaVersion < 12)),
getKeyEvent: function() {
return EventManager.useKeyDown ? 'keydown' : 'keypress';
}
});
if(!supportsAddEventListener && document.attachEvent) {
Ext.apply( EventManager, {
pollScroll : function() {
var scrollable = true;
try {
document.documentElement.doScroll('left');
} catch(e) {
scrollable = false;
}
if (scrollable && document.body) {
EventManager.onReadyEvent({
type:'doScroll'
});
} else {
EventManager.scrollTimeout = setTimeout(EventManager.pollScroll, 20);
}
return scrollable;
},
scrollTimeout: null,
readyStatesRe  : /complete/i,
checkReadyState: function() {
var state = document.readyState;
if (EventManager.readyStatesRe.test(state)) {
EventManager.onReadyEvent({
type: state
});
}
},
bindReadyEvent: function() {
var topContext = true;
if (EventManager.hasBoundOnReady) {
return;
}
try {
topContext = window.frameElement === undefined;
} catch(e) {
topContext = false;
}
if (!topContext || !doc.documentElement.doScroll) {
EventManager.pollScroll = Ext.emptyFn;   
}
if (EventManager.pollScroll() === true) {
return;
}
if (doc.readyState == 'complete' )  {
EventManager.onReadyEvent({type: 'already ' + (doc.readyState || 'body') });
} else {
doc.attachEvent('onreadystatechange', EventManager.checkReadyState);
window.attachEvent('onload', EventManager.onReadyEvent);
EventManager.hasBoundOnReady = true;
}
},
onReadyEvent : function(e) {
if (e && e.type) {
EventManager.onReadyChain.push(e.type);
}
if (EventManager.hasBoundOnReady) {
document.detachEvent('onreadystatechange', EventManager.checkReadyState);
window.detachEvent('onload', EventManager.onReadyEvent);
}
if (Ext.isNumber(EventManager.scrollTimeout)) {
clearTimeout(EventManager.scrollTimeout);
delete EventManager.scrollTimeout;
}
if (!Ext.isReady) {
EventManager.fireDocReady();
}
},
onReadyChain : []
});
}
Ext.onReady = function(fn, scope, options) {
Ext.Loader.onReady(fn, scope, true, options);
};
Ext.onDocumentReady = EventManager.onDocumentReady;
EventManager.on = EventManager.addListener;
EventManager.un = EventManager.removeListener;
Ext.onReady(initExtCss);
};
Ext.define('Ext.util.Observable', function(Observable) {
var emptyFn = Ext.emptyFn,
emptyArray = [],
arrayProto = Array.prototype,
arraySlice = arrayProto.slice,
ExtEvent = Ext.util.Event,
ListenerRemover = function(observable) {
if (observable instanceof ListenerRemover) {
return observable;
}
this.observable = observable;
if (arguments[1].isObservable) {
this.managedListeners = true;
}
this.args = arraySlice.call(arguments, 1);
};
ListenerRemover.prototype.destroy = function() {
this.observable[this.managedListeners ? 'mun' : 'un'].apply(this.observable, this.args);
};
return {
statics: {
releaseCapture: function(o) {
o.fireEventArgs = this.prototype.fireEventArgs;
},
capture: function(o, fn, scope) {
var newFn = function(eventName, args) {
return fn.apply(scope, [eventName].concat(args));
}
this.captureArgs(o, newFn, scope);
},
captureArgs: function(o, fn, scope) {
o.fireEventArgs = Ext.Function.createInterceptor(o.fireEventArgs, fn, scope);
},
observe: function(cls, listeners) {
if (cls) {
if (!cls.isObservable) {
Ext.applyIf(cls, new this());
this.captureArgs(cls.prototype, cls.fireEventArgs, cls);
}
if (Ext.isObject(listeners)) {
cls.on(listeners);
}
}
return cls;
},
prepareClass: function (T, mixin) {
if (!T.HasListeners) {
var HasListeners = function () {},
SuperHL = T.superclass.HasListeners || (mixin && mixin.HasListeners) ||
Observable.HasListeners;
T.prototype.HasListeners = T.HasListeners = HasListeners;
HasListeners.prototype = T.hasListeners = new SuperHL();
}
}
},
isObservable: true,
eventsSuspended: 0,
constructor: function(config) {
var me = this;
Ext.apply(me, config);
if (!me.hasListeners) {
me.hasListeners = new me.HasListeners();
}
me.events = me.events || {};
if (me.listeners) {
me.on(me.listeners);
me.listeners = null; 
}
if (me.bubbleEvents) {
me.enableBubble(me.bubbleEvents);
}
},
onClassExtended: function (T) {
if (!T.HasListeners) {
Observable.prepareClass(T);
}
},
eventOptionsRe : /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|element|destroyable|vertical|horizontal|freezeEvent|priority)$/,
addManagedListener: function(item, ename, fn, scope, options,  noDestroy) {
var me = this,
managedListeners = me.managedListeners = me.managedListeners || [],
config, passedOptions;
if (typeof ename !== 'string') {
passedOptions = arguments.length > 4 ? options : ename;
options = ename;
for (ename in options) {
if (options.hasOwnProperty(ename)) {
config = options[ename];
if (!me.eventOptionsRe.test(ename)) {
me.addManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope, config.fn ? config : passedOptions, true);
}
}
}
if (options && options.destroyable) {
return new ListenerRemover(me, item, options);
}
}
else {
if (typeof fn === 'string') {
scope = scope || me;
fn = Ext.resolveMethod(fn, scope);
}
if (fn !== emptyFn) {
managedListeners.push({
item: item,
ename: ename,
fn: fn,
scope: scope,
options: options
});
item.on(ename, fn, scope, options);
if (!noDestroy && options && options.destroyable) {
return new ListenerRemover(me, item, ename, fn, scope);
}
}
}
},
removeManagedListener: function(item, ename, fn, scope) {
var me = this,
options,
config,
managedListeners,
length,
i;
if (typeof ename !== 'string') {
options = ename;
for (ename in options) {
if (options.hasOwnProperty(ename)) {
config = options[ename];
if (!me.eventOptionsRe.test(ename)) {
me.removeManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope);
}
}
}
} else {
managedListeners = me.managedListeners ? me.managedListeners.slice() : [];
if (typeof fn === 'string') {
scope = scope || me;
fn = Ext.resolveMethod(fn, scope);
}
for (i = 0, length = managedListeners.length; i < length; i++) {
me.removeManagedListenerItem(false, managedListeners[i], item, ename, fn, scope);
}
}
},
fireEvent: function(eventName) {
return this.fireEventArgs(eventName, arraySlice.call(arguments, 1));
},
fireEventArgs: function(eventName, args) {
eventName = eventName.toLowerCase();
var me = this,
events = me.events,
event = events && events[eventName],
ret = true;
if (event && me.hasListeners[eventName]) {
ret = me.continueFireEvent(eventName, args || emptyArray, event.bubble);
}
return ret;
},
continueFireEvent: function(eventName, args, bubbles) {
var target = this,
queue, event,
ret = true;
do {
if (target.eventsSuspended) {
if ((queue = target.eventQueue)) {
queue.push([eventName, args, bubbles]);
}
return ret;
} else {
event = target.events[eventName];
if (event && event !== true) {
if ((ret = event.fire.apply(event, args)) === false) {
break;
}
}
}
} while (bubbles && (target = target.getBubbleParent()));
return ret;
},
getBubbleParent: function() {
var me = this, parent = me.getBubbleTarget && me.getBubbleTarget();
if (parent && parent.isObservable) {
return parent;
}
return null;
},
addListener: function(ename, fn, scope, options) {
var me = this,
config, event,
prevListenerCount = 0;
if (typeof ename !== 'string') {
options = ename;
for (ename in options) {
if (options.hasOwnProperty(ename)) {
config = options[ename];
if (!me.eventOptionsRe.test(ename)) {
me.addListener(ename, config.fn || config, config.scope || options.scope, config.fn ? config : options);
}
}
}
if (options && options.destroyable) {
return new ListenerRemover(me, options);
}
}
else {
ename = ename.toLowerCase();
event = me.events[ename];
if (event && event.isEvent) {
prevListenerCount = event.listeners.length;
} else {
me.events[ename] = event = new ExtEvent(me, ename);
}
if (typeof fn === 'string') {
scope = scope || me;
fn = Ext.resolveMethod(fn, scope);
}
if (fn !== emptyFn) {
event.addListener(fn, scope, options);
if (event.listeners.length !== prevListenerCount) {
me.hasListeners._incr_(ename);
}
if (options && options.destroyable) {
return new ListenerRemover(me, ename, fn, scope, options);
}
}
}
},
removeListener: function(ename, fn, scope) {
var me = this,
config,
event,
options;
if (typeof ename !== 'string') {
options = ename;
for (ename in options) {
if (options.hasOwnProperty(ename)) {
config = options[ename];
if (!me.eventOptionsRe.test(ename)) {
me.removeListener(ename, config.fn || config, config.scope || options.scope);
}
}
}
} else {
ename = ename.toLowerCase();
event = me.events[ename];
if (event && event.isEvent) {
if (typeof fn === 'string') {
scope = scope || me;
fn = Ext.resolveMethod(fn, scope);
}
if (event.removeListener(fn, scope)) {
me.hasListeners._decr_(ename);
}
}
}
},
clearListeners: function() {
var events = this.events,
hasListeners = this.hasListeners,
event,
key;
for (key in events) {
if (events.hasOwnProperty(key)) {
event = events[key];
if (event.isEvent) {
delete hasListeners[key];
event.clearListeners();
}
}
}
this.clearManagedListeners();
},
clearManagedListeners : function() {
var managedListeners = this.managedListeners || [],
i = 0,
len = managedListeners.length;
for (; i < len; i++) {
this.removeManagedListenerItem(true, managedListeners[i]);
}
this.managedListeners = [];
},
removeManagedListenerItem: function(isClear, managedListener, item, ename, fn, scope){
if (isClear || (managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope))) {
managedListener.item.un(managedListener.ename, managedListener.fn, managedListener.scope);
if (!isClear) {
Ext.Array.remove(this.managedListeners, managedListener);
}
}
},
addEvents: function(o) {
var me = this,
events = me.events || (me.events = {}),
arg, args, i;
if (typeof o == 'string') {
for (args = arguments, i = args.length; i--; ) {
arg = args[i];
if (!events[arg]) {
events[arg] = true;
}
}
} else {
Ext.applyIf(me.events, o);
}
},
hasListener: function(ename) {
return !!this.hasListeners[ename.toLowerCase()];
},
suspendEvents: function(queueSuspended) {
this.eventsSuspended += 1;
if (queueSuspended && !this.eventQueue) {
this.eventQueue = [];
}
},
suspendEvent: function(eventName) {
var len = arguments.length,
i, event;
for (i = 0; i < len; i++) {
event = this.events[arguments[i]];
if (event && event.suspend) {
event.suspend();
}
}
},
resumeEvent: function() {
var len = arguments.length,
i, event;
for (i = 0; i < len; i++) {
event = this.events[arguments[i]];
if (event && event.resume) {
event.resume();
}
}
},
resumeEvents: function() {
var me = this,
queued = me.eventQueue,
qLen, q;
if (me.eventsSuspended && ! --me.eventsSuspended) {
if (queued) {
qLen = queued.length;
for (q = 0; q < qLen; q++) {
me.continueFireEvent.apply(me, queued[q]);
}
me.eventQueue = void 0;
}
}
},
relayEvents : function(origin, events, prefix) {
var me = this,
len = events.length,
i = 0,
oldName,
relayers = {};
for (; i < len; i++) {
oldName = events[i];
relayers[oldName] = me.createRelayer(prefix ? prefix + oldName : oldName);
}
me.mon(origin, relayers, null, null, undefined);
return new ListenerRemover(me, origin, relayers);
},
createRelayer: function(newName, beginEnd) {
var me = this;
return function() {
return me.fireEventArgs.call(me, newName, beginEnd ? arraySlice.apply(arguments, beginEnd) : arguments);
};
},
enableBubble: function(eventNames) {
if (eventNames) {
var me = this,
names = (typeof eventNames == 'string') ? arguments : eventNames,
length = names.length,
events = me.events,
ename, event, i;
for (i = 0; i < length; ++i) {
ename = names[i].toLowerCase();
event = events[ename];
if (!event || typeof event == 'boolean') {
events[ename] = event = new ExtEvent(me, ename);
}
me.hasListeners._incr_(ename);
event.bubble = true;
}
}
}
};
}, function() {
var Observable = this,
proto = Observable.prototype,
HasListeners = function () {},
prepareMixin = function (T) {
if (!T.HasListeners) {
var proto = T.prototype;
Observable.prepareClass(T, this);
T.onExtended(function (U) {
Observable.prepareClass(U);
});
if (proto.onClassMixedIn) {
Ext.override(T, {
onClassMixedIn: function (U) {
prepareMixin.call(this, U);
this.callParent(arguments);
}
});
} else {
proto.onClassMixedIn = function (U) {
prepareMixin.call(this, U);
};
}
}
},
globalEvents;
HasListeners.prototype = {
_decr_: function (ev) {
if (! --this[ev]) {
delete this[ev];
}
},
_incr_: function (ev) {
if (this.hasOwnProperty(ev)) {
++this[ev];
} else {
this[ev] = 1;
}
}
};
proto.HasListeners = Observable.HasListeners = HasListeners;
Observable.createAlias({
on: 'addListener',
un: 'removeListener',
mon: 'addManagedListener',
mun: 'removeManagedListener'
});
Observable.observeClass = Observable.observe;
Ext.globalEvents = globalEvents = new Observable({
events: {
idle: Ext.EventManager.idleEvent,
ready: Ext.EventManager.readyEvent
}
});
Ext.on = function() {
return globalEvents.addListener.apply(globalEvents, arguments);
};
Ext.un = function() {
return globalEvents.removeListener.apply(globalEvents, arguments);
};
function getMethodEvent(method){
var e = (this.methodEvents = this.methodEvents || {})[method],
returnValue,
v,
cancel,
obj = this,
makeCall;
if (!e) {
this.methodEvents[method] = e = {};
e.originalFn = this[method];
e.methodName = method;
e.before = [];
e.after = [];
makeCall = function(fn, scope, args){
if((v = fn.apply(scope || obj, args)) !== undefined){
if (typeof v == 'object') {
if(v.returnValue !== undefined){
returnValue = v.returnValue;
}else{
returnValue = v;
}
cancel = !!v.cancel;
}
else
if (v === false) {
cancel = true;
}
else {
returnValue = v;
}
}
};
this[method] = function(){
var args = Array.prototype.slice.call(arguments, 0),
b, i, len;
returnValue = v = undefined;
cancel = false;
for(i = 0, len = e.before.length; i < len; i++){
b = e.before[i];
makeCall(b.fn, b.scope, args);
if (cancel) {
return returnValue;
}
}
if((v = e.originalFn.apply(obj, args)) !== undefined){
returnValue = v;
}
for(i = 0, len = e.after.length; i < len; i++){
b = e.after[i];
makeCall(b.fn, b.scope, args);
if (cancel) {
return returnValue;
}
}
return returnValue;
};
}
return e;
}
Ext.apply(proto, {
onClassMixedIn: prepareMixin,
beforeMethod : function(method, fn, scope){
getMethodEvent.call(this, method).before.push({
fn: fn,
scope: scope
});
},
afterMethod : function(method, fn, scope){
getMethodEvent.call(this, method).after.push({
fn: fn,
scope: scope
});
},
removeMethodListener: function(method, fn, scope){
var e = this.getMethodEvent(method),
i, len;
for(i = 0, len = e.before.length; i < len; i++){
if(e.before[i].fn == fn && e.before[i].scope == scope){
Ext.Array.erase(e.before, i, 1);
return;
}
}
for(i = 0, len = e.after.length; i < len; i++){
if(e.after[i].fn == fn && e.after[i].scope == scope){
Ext.Array.erase(e.after, i, 1);
return;
}
}
},
toggleEventLogging: function(toggle) {
Ext.util.Observable[toggle ? 'capture' : 'releaseCapture'](this, function(en) {
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.log(en, arguments);
}
});
}
});
});
Ext.define('Ext.EventObjectImpl', {
BACKSPACE: 8,
TAB: 9,
NUM_CENTER: 12,
ENTER: 13,
RETURN: 13,
SHIFT: 16,
CTRL: 17,
ALT: 18,
PAUSE: 19,
CAPS_LOCK: 20,
ESC: 27,
SPACE: 32,
PAGE_UP: 33,
PAGE_DOWN: 34,
END: 35,
HOME: 36,
LEFT: 37,
UP: 38,
RIGHT: 39,
DOWN: 40,
PRINT_SCREEN: 44,
INSERT: 45,
DELETE: 46,
ZERO: 48,
ONE: 49,
TWO: 50,
THREE: 51,
FOUR: 52,
FIVE: 53,
SIX: 54,
SEVEN: 55,
EIGHT: 56,
NINE: 57,
A: 65,
B: 66,
C: 67,
D: 68,
E: 69,
F: 70,
G: 71,
H: 72,
I: 73,
J: 74,
K: 75,
L: 76,
M: 77,
N: 78,
O: 79,
P: 80,
Q: 81,
R: 82,
S: 83,
T: 84,
U: 85,
V: 86,
W: 87,
X: 88,
Y: 89,
Z: 90,
CONTEXT_MENU: 93,
NUM_ZERO: 96,
NUM_ONE: 97,
NUM_TWO: 98,
NUM_THREE: 99,
NUM_FOUR: 100,
NUM_FIVE: 101,
NUM_SIX: 102,
NUM_SEVEN: 103,
NUM_EIGHT: 104,
NUM_NINE: 105,
NUM_MULTIPLY: 106,
NUM_PLUS: 107,
NUM_MINUS: 109,
NUM_PERIOD: 110,
NUM_DIVISION: 111,
F1: 112,
F2: 113,
F3: 114,
F4: 115,
F5: 116,
F6: 117,
F7: 118,
F8: 119,
F9: 120,
F10: 121,
F11: 122,
F12: 123,
WHEEL_SCALE: (function () {
var scale;
if (Ext.isGecko) {
scale = 3;
} else if (Ext.isMac) {
if (Ext.isSafari && Ext.webKitVersion >= 532.0) {
scale = 120;
} else {
scale = 12;
}
scale *= 3;
} else {
scale = 120;
}
return scale;
}()),
clickRe: /(dbl)?click/,
safariKeys: {
3: 13, 
63234: 37, 
63235: 39, 
63232: 38, 
63233: 40, 
63276: 33, 
63277: 34, 
63272: 46, 
63273: 36, 
63275: 35 
},
btnMap: Ext.isIE ? {
1: 0,
4: 1,
2: 2
} : {
0: 0,
1: 1,
2: 2
},
constructor: function(event, freezeEvent){
if (event) {
this.setEvent(event.browserEvent || event, freezeEvent);
}
},
setEvent: function(event, freezeEvent){
var me = this, button;
if (event === me || (event && event.browserEvent)) { 
return event;
}
me.browserEvent = event;
if (event) {
button = event.button ? me.btnMap[event.button] : (event.which ? event.which - 1 : -1);
if (me.clickRe.test(event.type) && button == -1) {
button = 0;
}
me.type = event.type;
me.button = button;
me.shiftKey = event.shiftKey;
me.ctrlKey = event.ctrlKey || event.metaKey || false;
me.altKey = event.altKey;
me.keyCode = event.keyCode;
me.charCode = event.charCode;
me.target = Ext.EventManager.getTarget(event);
me.relatedTarget = Ext.EventManager.getRelatedTarget(event);
me.currentTarget = event.currentTarget;
me.xy = (freezeEvent ? me.getXY() : null);
} else {
me.button = -1;
me.shiftKey = false;
me.ctrlKey = false;
me.altKey = false;
me.keyCode = 0;
me.charCode = 0;
me.target = null;
me.xy = [0, 0];
}
return me;
},
clone: function() {
return new this.self(this.browserEvent, this);
},
stopEvent: function(){
this.stopPropagation();
this.preventDefault();
},
preventDefault: function(){
if (this.browserEvent) {
Ext.EventManager.preventDefault(this.browserEvent);
}
},
stopPropagation: function(){
var browserEvent = this.browserEvent;
if (browserEvent) {
if (browserEvent.type == 'mousedown') {
Ext.EventManager.stoppedMouseDownEvent.fire(this);
}
Ext.EventManager.stopPropagation(browserEvent);
}
},
getCharCode: function(){
return this.charCode || this.keyCode;
},
getKey: function(){
return this.normalizeKey(this.keyCode || this.charCode);
},
normalizeKey: function(key){
return Ext.isWebKit ? (this.safariKeys[key] || key) : key;
},
getPageX: function(){
return this.getX();
},
getPageY: function(){
return this.getY();
},
getX: function() {
return this.getXY()[0];
},
getY: function() {
return this.getXY()[1];
},
getXY: function() {
if (!this.xy) {
this.xy = Ext.EventManager.getPageXY(this.browserEvent);
}
return this.xy;
},
getTarget : function(selector, maxDepth, returnEl){
if (selector) {
return Ext.fly(this.target).findParent(selector, maxDepth, returnEl);
}
return returnEl ? Ext.get(this.target) : this.target;
},
getRelatedTarget : function(selector, maxDepth, returnEl){
if (selector && this.relatedTarget) {
return Ext.fly(this.relatedTarget).findParent(selector, maxDepth, returnEl);
}
return returnEl ? Ext.get(this.relatedTarget) : this.relatedTarget;
},
correctWheelDelta : function (delta) {
var scale = this.WHEEL_SCALE,
ret = Math.round(delta / scale);
if (!ret && delta) {
ret = (delta < 0) ? -1 : 1; 
}
return ret;
},
getWheelDeltas : function () {
var me = this,
event = me.browserEvent,
dx = 0, dy = 0; 
if (Ext.isDefined(event.wheelDeltaX)) { 
dx = event.wheelDeltaX;
dy = event.wheelDeltaY;
} else if (event.wheelDelta) { 
dy = event.wheelDelta;
} else if (event.detail) { 
dy = -event.detail; 
if (dy > 100) {
dy = 3;
} else if (dy < -100) {
dy = -3;
}
if (Ext.isDefined(event.axis) && event.axis === event.HORIZONTAL_AXIS) {
dx = dy;
dy = 0;
}
}
return {
x: me.correctWheelDelta(dx),
y: me.correctWheelDelta(dy)
};
},
getWheelDelta : function(){
var deltas = this.getWheelDeltas();
return deltas.y;
},
within : function(el, related, allowEl){
if(el){
var t = related ? this.getRelatedTarget() : this.getTarget(),
result;
if (t) {
result = Ext.fly(el, '_internal').contains(t);
if (!result && allowEl) {
result = t == Ext.getDom(el);
}
return result;
}
}
return false;
},
isNavKeyPress : function(){
var me = this,
k = this.normalizeKey(me.keyCode);
return (k >= 33 && k <= 40) ||  
k == me.RETURN ||
k == me.TAB ||
k == me.ESC;
},
isSpecialKey : function(){
var k = this.normalizeKey(this.keyCode);
return (this.type == 'keypress' && this.ctrlKey) ||
this.isNavKeyPress() ||
(k == this.BACKSPACE) || 
(k >= 16 && k <= 20) || 
(k >= 44 && k <= 46);   
},
getPoint : function(){
var xy = this.getXY();
return new Ext.util.Point(xy[0], xy[1]);
},
hasModifier : function(){
return this.ctrlKey || this.altKey || this.shiftKey || this.metaKey;
},
injectEvent: (function () {
var API,
dispatchers = {}, 
crazyIEButtons;
if (!Ext.isIE9m && document.createEvent) { 
API = {
createHtmlEvent: function (doc, type, bubbles, cancelable) {
var event = doc.createEvent('HTMLEvents');
event.initEvent(type, bubbles, cancelable);
return event;
},
createMouseEvent: function (doc, type, bubbles, cancelable, detail,
clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,
button, relatedTarget) {
var event = doc.createEvent('MouseEvents'),
view = doc.defaultView || window;
if (event.initMouseEvent) {
event.initMouseEvent(type, bubbles, cancelable, view, detail,
clientX, clientY, clientX, clientY, ctrlKey, altKey,
shiftKey, metaKey, button, relatedTarget);
} else { 
event = doc.createEvent('UIEvents');
event.initEvent(type, bubbles, cancelable);
event.view = view;
event.detail = detail;
event.screenX = clientX;
event.screenY = clientY;
event.clientX = clientX;
event.clientY = clientY;
event.ctrlKey = ctrlKey;
event.altKey = altKey;
event.metaKey = metaKey;
event.shiftKey = shiftKey;
event.button = button;
event.relatedTarget = relatedTarget;
}
return event;
},
createUIEvent: function (doc, type, bubbles, cancelable, detail) {
var event = doc.createEvent('UIEvents'),
view = doc.defaultView || window;
event.initUIEvent(type, bubbles, cancelable, view, detail);
return event;
},
fireEvent: function (target, type, event) {
target.dispatchEvent(event);
},
fixTarget: function (target) {
if (target == window && !target.dispatchEvent) {
return document;
}
return target;
}
};
} else if (document.createEventObject) { 
crazyIEButtons = { 0: 1, 1: 4, 2: 2 };
API = {
createHtmlEvent: function (doc, type, bubbles, cancelable) {
var event = doc.createEventObject();
event.bubbles = bubbles;
event.cancelable = cancelable;
return event;
},
createMouseEvent: function (doc, type, bubbles, cancelable, detail,
clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,
button, relatedTarget) {
var event = doc.createEventObject();
event.bubbles = bubbles;
event.cancelable = cancelable;
event.detail = detail;
event.screenX = clientX;
event.screenY = clientY;
event.clientX = clientX;
event.clientY = clientY;
event.ctrlKey = ctrlKey;
event.altKey = altKey;
event.shiftKey = shiftKey;
event.metaKey = metaKey;
event.button = crazyIEButtons[button] || button;
event.relatedTarget = relatedTarget; 
return event;
},
createUIEvent: function (doc, type, bubbles, cancelable, detail) {
var event = doc.createEventObject();
event.bubbles = bubbles;
event.cancelable = cancelable;
return event;
},
fireEvent: function (target, type, event) {
target.fireEvent('on' + type, event);
},
fixTarget: function (target) {
if (target == document) {
return document.documentElement;
}
return target;
}
};
}
Ext.Object.each({
load:   [false, false],
unload: [false, false],
select: [true, false],
change: [true, false],
submit: [true, true],
reset:  [true, false],
resize: [true, false],
scroll: [true, false]
},
function (name, value) {
var bubbles = value[0], cancelable = value[1];
dispatchers[name] = function (targetEl, srcEvent) {
var e = API.createHtmlEvent(name, bubbles, cancelable);
API.fireEvent(targetEl, name, e);
};
});
function createMouseEventDispatcher (type, detail) {
var cancelable = (type != 'mousemove');
return function (targetEl, srcEvent) {
var xy = srcEvent.getXY(),
e = API.createMouseEvent(targetEl.ownerDocument, type, true, cancelable,
detail, xy[0], xy[1], srcEvent.ctrlKey, srcEvent.altKey,
srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button,
srcEvent.relatedTarget);
API.fireEvent(targetEl, type, e);
};
}
Ext.each(['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mousemove', 'mouseout'],
function (eventName) {
dispatchers[eventName] = createMouseEventDispatcher(eventName, 1);
});
Ext.Object.each({
focusin:  [true, false],
focusout: [true, false],
activate: [true, true],
focus:    [false, false],
blur:     [false, false]
},
function (name, value) {
var bubbles = value[0], cancelable = value[1];
dispatchers[name] = function (targetEl, srcEvent) {
var e = API.createUIEvent(targetEl.ownerDocument, name, bubbles, cancelable, 1);
API.fireEvent(targetEl, name, e);
};
});
if (!API) {
dispatchers = {}; 
API = {
fixTarget: Ext.identityFn
};
}
function cannotInject (target, srcEvent) {
}
return function (target) {
var me = this,
dispatcher = dispatchers[me.type] || cannotInject,
t = target ? (target.dom || target) : me.getTarget();
t = API.fixTarget(t);
dispatcher(t, me);
};
}()) 
}, function() {
Ext.EventObject = new Ext.EventObjectImpl();
});
Ext.define('Ext.dom.AbstractQuery', {
select: function(q, root) {
var results = [],
nodes,
i,
j,
qlen,
nlen;
root = root || document;
if (typeof root == 'string') {
root = document.getElementById(root);
}
q = q.split(",");
for (i = 0,qlen = q.length; i < qlen; i++) {
if (typeof q[i] == 'string') {
if (typeof q[i][0] == '@') {
nodes = root.getAttributeNode(q[i].substring(1));
results.push(nodes);
} else {
nodes = root.querySelectorAll(q[i]);
for (j = 0,nlen = nodes.length; j < nlen; j++) {
results.push(nodes[j]);
}
}
}
}
return results;
},
selectNode: function(q, root) {
return this.select(q, root)[0];
},
is: function(el, q) {
if (typeof el == "string") {
el = document.getElementById(el);
}
return this.select(q).indexOf(el) !== -1;
}
});
Ext.define('Ext.dom.AbstractHelper', {
emptyTags : /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i,
confRe : /^(?:tag|children|cn|html|tpl|tplData)$/i,
endRe : /end/i,
styleSepRe: /\s*(?::|;)\s*/,
attributeTransform: { cls : 'class', htmlFor : 'for' },
closeTags: {},
decamelizeName : (function () {
var camelCaseRe = /([a-z])([A-Z])/g,
cache = {};
function decamel (match, p1, p2) {
return p1 + '-' + p2.toLowerCase();
}
return function (s) {
return cache[s] || (cache[s] = s.replace(camelCaseRe, decamel));
};
}()),
generateMarkup: function(spec, buffer) {
var me = this,
specType = typeof spec,
attr, val, tag, i, closeTags;
if (specType == "string" || specType == "number") {
buffer.push(spec);
} else if (Ext.isArray(spec)) {
for (i = 0; i < spec.length; i++) {
if (spec[i]) {
me.generateMarkup(spec[i], buffer);
}
}
} else {
tag = spec.tag || 'div';
buffer.push('<', tag);
for (attr in spec) {
if (spec.hasOwnProperty(attr)) {
val = spec[attr];
if (!me.confRe.test(attr)) {
if (typeof val == "object") {
buffer.push(' ', attr, '="');
me.generateStyles(val, buffer, true).push('"');
} else {
buffer.push(' ', me.attributeTransform[attr] || attr, '="', val, '"');
}
}
}
}
if (me.emptyTags.test(tag)) {
buffer.push('/>');
} else {
buffer.push('>');
if ((val = spec.tpl)) {
val.applyOut(spec.tplData, buffer);
}
if ((val = spec.html)) {
buffer.push(val);
}
if ((val = spec.cn || spec.children)) {
me.generateMarkup(val, buffer);
}
closeTags = me.closeTags;
buffer.push(closeTags[tag] || (closeTags[tag] = '</' + tag + '>'));
}
}
return buffer;
},
generateStyles: function (styles, buffer, encode) {
var a = buffer || [],
name, val;
for (name in styles) {
if (styles.hasOwnProperty(name)) {
val = styles[name];
name = this.decamelizeName(name);
if (encode && Ext.String.hasHtmlCharacters(val)) {
val = Ext.String.htmlEncode(val);
}
a.push(name, ':', val, ';');
}
}
return buffer || a.join('');
},
markup: function(spec) {
if (typeof spec == "string") {
return spec;
}
var buf = this.generateMarkup(spec, []);
return buf.join('');
},
applyStyles: function(el, styles) {
if (styles) {
var i = 0,
len;
el = Ext.fly(el, '_applyStyles');
if (typeof styles == 'function') {
styles = styles.call();
}
if (typeof styles == 'string') {
styles = Ext.util.Format.trim(styles).split(this.styleSepRe);
for (len = styles.length; i < len;) {
el.setStyle(styles[i++], styles[i++]);
}
} else if (Ext.isObject(styles)) {
el.setStyle(styles);
}
}
},
insertHtml: function(where, el, html) {
var hash = {},
setStart,
range,
frag,
rangeEl;
where = where.toLowerCase();
hash.beforebegin = ['BeforeBegin', 'previousSibling'];
hash.afterend = ['AfterEnd', 'nextSibling'];
range = el.ownerDocument.createRange();
setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
if (hash[where]) {
range[setStart](el);
frag = range.createContextualFragment(html);
el.parentNode.insertBefore(frag, where == 'beforebegin' ? el : el.nextSibling);
return el[(where == 'beforebegin' ? 'previous' : 'next') + 'Sibling'];
}
else {
rangeEl = (where == 'afterbegin' ? 'first' : 'last') + 'Child';
if (el.firstChild) {
range[setStart](el[rangeEl]);
frag = range.createContextualFragment(html);
if (where == 'afterbegin') {
el.insertBefore(frag, el.firstChild);
}
else {
el.appendChild(frag);
}
}
else {
el.innerHTML = html;
}
return el[rangeEl];
}
throw 'Illegal insertion point -> "' + where + '"';
},
insertBefore: function(el, o, returnElement) {
return this.doInsert(el, o, returnElement, 'beforebegin');
},
insertAfter: function(el, o, returnElement) {
return this.doInsert(el, o, returnElement, 'afterend', 'nextSibling');
},
insertFirst: function(el, o, returnElement) {
return this.doInsert(el, o, returnElement, 'afterbegin', 'firstChild');
},
append: function(el, o, returnElement) {
return this.doInsert(el, o, returnElement, 'beforeend', '', true);
},
overwrite: function(el, o, returnElement) {
el = Ext.getDom(el);
el.innerHTML = this.markup(o);
return returnElement ? Ext.get(el.firstChild) : el.firstChild;
},
doInsert: function(el, o, returnElement, pos, sibling, append) {
var newNode = this.insertHtml(pos, Ext.getDom(el), this.markup(o));
return returnElement ? Ext.get(newNode, true) : newNode;
}
});
Ext.define('Ext.dom.AbstractElement_static', {
override: 'Ext.dom.AbstractElement',
inheritableStatics: {
unitRe: /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i,
camelRe: /(-[a-z])/gi,
msRe: /^-ms-/,
cssRe: /([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*)?;?/gi,
opacityRe: /alpha\(opacity=(.*)\)/i,
propertyCache: {},
defaultUnit : "px",
borders: {l: 'border-left-width', r: 'border-right-width', t: 'border-top-width', b: 'border-bottom-width'},
paddings: {l: 'padding-left', r: 'padding-right', t: 'padding-top', b: 'padding-bottom'},
margins: {l: 'margin-left', r: 'margin-right', t: 'margin-top', b: 'margin-bottom'},
addUnits: function(size, units) {
if (typeof size == 'number') {
return size + (units || this.defaultUnit || 'px');
}
if (size === "" || size == "auto" || size === undefined || size === null) {
return size || '';
}
if (!this.unitRe.test(size)) {
return size || '';
}
return size;
},
isAncestor: function(p, c) {
var ret = false;
p = Ext.getDom(p);
c = Ext.getDom(c);
if (p && c) {
if (p.contains) {
return p.contains(c);
} else if (p.compareDocumentPosition) {
return !!(p.compareDocumentPosition(c) & 16);
} else {
while ((c = c.parentNode)) {
ret = c == p || ret;
}
}
}
return ret;
},
parseBox: function(box) {
box = box || 0;
var type = typeof box,
parts,
ln;
if (type === 'number') {
return {
top   : box,
right : box,
bottom: box,
left  : box
};
} else if (type !== 'string') {
return box;
}
parts  = box.split(' ');
ln = parts.length;
if (ln == 1) {
parts[1] = parts[2] = parts[3] = parts[0];
} else if (ln == 2) {
parts[2] = parts[0];
parts[3] = parts[1];
} else if (ln == 3) {
parts[3] = parts[1];
}
return {
top   :parseFloat(parts[0]) || 0,
right :parseFloat(parts[1]) || 0,
bottom:parseFloat(parts[2]) || 0,
left  :parseFloat(parts[3]) || 0
};
},
unitizeBox: function(box, units) {
var a = this.addUnits,
b = this.parseBox(box);
return a(b.top, units) + ' ' +
a(b.right, units) + ' ' +
a(b.bottom, units) + ' ' +
a(b.left, units);
},
camelReplaceFn: function(m, a) {
return a.charAt(1).toUpperCase();
},
normalize: function(prop) {
if (prop == 'float') {
prop = Ext.supports.Float ? 'cssFloat' : 'styleFloat';
}
return this.propertyCache[prop] || (this.propertyCache[prop] = prop.replace(this.msRe, 'ms-').replace(this.camelRe, this.camelReplaceFn));
},
getDocumentHeight: function() {
return Math.max(!Ext.isStrict ? document.body.scrollHeight : document.documentElement.scrollHeight, this.getViewportHeight());
},
getDocumentWidth: function() {
return Math.max(!Ext.isStrict ? document.body.scrollWidth : document.documentElement.scrollWidth, this.getViewportWidth());
},
getViewportHeight: function(){
return window.innerHeight;
},
getViewportWidth: function() {
return window.innerWidth;
},
getViewSize: function() {
return {
width: window.innerWidth,
height: window.innerHeight
};
},
getOrientation: function() {
if (Ext.supports.OrientationChange) {
return (window.orientation == 0) ? 'portrait' : 'landscape';
}
return (window.innerHeight > window.innerWidth) ? 'portrait' : 'landscape';
},
fromPoint: function(x, y) {
return Ext.get(document.elementFromPoint(x, y));
},
parseStyles: function(styles){
var out = {},
cssRe = this.cssRe,
matches;
if (styles) {
cssRe.lastIndex = 0;
while ((matches = cssRe.exec(styles))) {
out[matches[1]] = matches[2]||'';
}
}
return out;
}
}
},
function () {
var doc = document,
activeElement = null,
isCSS1 = doc.compatMode == "CSS1Compat";
if (!('activeElement' in doc) && doc.addEventListener) {
doc.addEventListener('focus',
function (ev) {
if (ev && ev.target) {
activeElement = (ev.target == doc) ? null : ev.target;
}
}, true);
}
function makeSelectionRestoreFn (activeEl, start, end) {
return function () {
activeEl.selectionStart = start;
activeEl.selectionEnd = end;
};
}
this.addInheritableStatics({
getActiveElement: function () {
var active;
try {
active = doc.activeElement;
} catch(e) {}
active = active || activeElement;
if (!active) {
active = activeElement = document.body;
}
return active;
},
getRightMarginFixCleaner: function (target) {
var supports = Ext.supports,
hasInputBug = supports.DisplayChangeInputSelectionBug,
hasTextAreaBug = supports.DisplayChangeTextAreaSelectionBug,
activeEl,
tag,
start,
end;
if (hasInputBug || hasTextAreaBug) {
activeEl = doc.activeElement || activeElement; 
tag = activeEl && activeEl.tagName;
if ((hasTextAreaBug && tag == 'TEXTAREA') ||
(hasInputBug && tag == 'INPUT' && activeEl.type == 'text')) {
if (Ext.dom.Element.isAncestor(target, activeEl)) {
start = activeEl.selectionStart;
end = activeEl.selectionEnd;
if (Ext.isNumber(start) && Ext.isNumber(end)) { 
return makeSelectionRestoreFn(activeEl, start, end);
}
}
}
}
return Ext.emptyFn; 
},
getViewWidth: function(full) {
return full ? Ext.dom.Element.getDocumentWidth() : Ext.dom.Element.getViewportWidth();
},
getViewHeight: function(full) {
return full ? Ext.dom.Element.getDocumentHeight() : Ext.dom.Element.getViewportHeight();
},
getDocumentHeight: function() {
return Math.max(!isCSS1 ? doc.body.scrollHeight : doc.documentElement.scrollHeight, Ext.dom.Element.getViewportHeight());
},
getDocumentWidth: function() {
return Math.max(!isCSS1 ? doc.body.scrollWidth : doc.documentElement.scrollWidth, Ext.dom.Element.getViewportWidth());
},
getViewportHeight: function(){
return Ext.isIE9m ?
(Ext.isStrict ? doc.documentElement.clientHeight : doc.body.clientHeight) :
self.innerHeight;
},
getViewportWidth: function() {
return (!Ext.isStrict && !Ext.isOpera) ? doc.body.clientWidth :
Ext.isIE9m ? doc.documentElement.clientWidth : self.innerWidth;
},
serializeForm: function(form) {
var fElements = form.elements || (document.forms[form] || Ext.getDom(form)).elements,
hasSubmit = false,
encoder   = encodeURIComponent,
data      = '',
eLen      = fElements.length,
element, name, type, options, hasValue, e,
o, oLen, opt;
for (e = 0; e < eLen; e++) {
element = fElements[e];
name    = element.name;
type    = element.type;
options = element.options;
if (!element.disabled && name) {
if (/select-(one|multiple)/i.test(type)) {
oLen = options.length;
for (o = 0; o < oLen; o++) {
opt = options[o];
if (opt.selected) {
hasValue = opt.hasAttribute ? opt.hasAttribute('value') : opt.getAttributeNode('value').specified;
data += Ext.String.format("{0}={1}&", encoder(name), encoder(hasValue ? opt.value : opt.text));
}
}
} else if (!(/file|undefined|reset|button/i.test(type))) {
if (!(/radio|checkbox/i.test(type) && !element.checked) && !(type == 'submit' && hasSubmit)) {
data += encoder(name) + '=' + encoder(element.value) + '&';
hasSubmit = /submit/i.test(type);
}
}
}
}
return data.substr(0, data.length - 1);
}
});
});
Ext.define('Ext.dom.AbstractElement_insertion', {
override: 'Ext.dom.AbstractElement',
appendChild: function(el, returnDom) {
var me = this,
insertEl,
eLen, e, oldUseDom;
if (el.nodeType || el.dom || typeof el == 'string') { 
el = Ext.getDom(el);
me.dom.appendChild(el);
return !returnDom ? Ext.get(el) : el;
} else if (el.length) {
insertEl = Ext.fly(document.createDocumentFragment(), '_internal');
eLen = el.length;
Ext.DomHelper.useDom = true;
for (e = 0; e < eLen; e++) {
insertEl.appendChild(el[e], returnDom);
}
Ext.DomHelper.useDom = oldUseDom;
me.dom.appendChild(insertEl.dom);
return returnDom ? insertEl.dom : insertEl;
}
else { 
return me.createChild(el, null, returnDom);
}
},
appendTo: function(el) {
Ext.getDom(el).appendChild(this.dom);
return this;
},
insertBefore: function(el) {
el = Ext.getDom(el);
el.parentNode.insertBefore(this.dom, el);
return this;
},
insertAfter: function(el) {
el = Ext.getDom(el);
el.parentNode.insertBefore(this.dom, el.nextSibling);
return this;
},
insertFirst: function(el, returnDom) {
el = el || {};
if (el.nodeType || el.dom || typeof el == 'string') { 
el = Ext.getDom(el);
this.dom.insertBefore(el, this.dom.firstChild);
return !returnDom ? Ext.get(el) : el;
}
else { 
return this.createChild(el, this.dom.firstChild, returnDom);
}
},
insertSibling: function(el, where, returnDom) {
var me        = this,
DomHelper = Ext.core.DomHelper,
oldUseDom = DomHelper.useDom,
isAfter   = (where || 'before').toLowerCase() == 'after',
rt, insertEl, eLen, e;
if (Ext.isArray(el)) {
insertEl = Ext.fly(document.createDocumentFragment(), '_internal');
eLen = el.length;
DomHelper.useDom = true;
for (e = 0; e < eLen; e++) {
rt = insertEl.appendChild(el[e], returnDom);
}
DomHelper.useDom = oldUseDom;
me.dom.parentNode.insertBefore(insertEl.dom, isAfter ? me.dom.nextSibling : me.dom);
return rt;
}
el = el || {};
if (el.nodeType || el.dom) {
rt = me.dom.parentNode.insertBefore(Ext.getDom(el), isAfter ? me.dom.nextSibling : me.dom);
if (!returnDom) {
rt = Ext.get(rt);
}
} else {
if (isAfter && !me.dom.nextSibling) {
rt = DomHelper.append(me.dom.parentNode, el, !returnDom);
} else {
rt = DomHelper[isAfter ? 'insertAfter' : 'insertBefore'](me.dom, el, !returnDom);
}
}
return rt;
},
replace: function(el) {
el = Ext.get(el);
this.insertBefore(el);
el.remove();
return this;
},
replaceWith: function(el){
var me = this;
if (el.nodeType || el.dom || typeof el == 'string') {
el = Ext.get(el);
me.dom.parentNode.insertBefore(el.dom, me.dom);
} else {
el = Ext.core.DomHelper.insertBefore(me.dom, el);
}
delete Ext.cache[me.id];
Ext.removeNode(me.dom);
me.id = Ext.id(me.dom = el);
Ext.dom.AbstractElement.addToCache(me.isFlyweight ? new Ext.dom.AbstractElement(me.dom) : me);
return me;
},
createChild: function(config, insertBefore, returnDom) {
config = config || {tag:'div'};
if (insertBefore) {
return Ext.core.DomHelper.insertBefore(insertBefore, config, returnDom !== true);
}
else {
return Ext.core.DomHelper.append(this.dom, config,  returnDom !== true);
}
},
wrap: function(config, returnDom, selector) {
var newEl = Ext.core.DomHelper.insertBefore(this.dom, config || {tag: "div"}, true),
target = newEl;
if (selector) {
target = Ext.DomQuery.selectNode(selector, newEl.dom);
}
target.appendChild(this.dom);
return returnDom ? newEl.dom : newEl;
},
insertHtml: function(where, html, returnEl) {
var el = Ext.core.DomHelper.insertHtml(where, this.dom, html);
return returnEl ? Ext.get(el) : el;
}
});
Ext.define('Ext.dom.AbstractElement_style', {
override: 'Ext.dom.AbstractElement'
}, function() {
var Element = this,
wordsRe = /\w/g,
spacesRe = /\s+/,
transparentRe = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i,
hasClassList = Ext.supports.ClassList,
PADDING = 'padding',
MARGIN = 'margin',
BORDER = 'border',
LEFT_SUFFIX = '-left',
RIGHT_SUFFIX = '-right',
TOP_SUFFIX = '-top',
BOTTOM_SUFFIX = '-bottom',
WIDTH = '-width',
borders = {l: BORDER + LEFT_SUFFIX + WIDTH, r: BORDER + RIGHT_SUFFIX + WIDTH, t: BORDER + TOP_SUFFIX + WIDTH, b: BORDER + BOTTOM_SUFFIX + WIDTH},
paddings = {l: PADDING + LEFT_SUFFIX, r: PADDING + RIGHT_SUFFIX, t: PADDING + TOP_SUFFIX, b: PADDING + BOTTOM_SUFFIX},
margins = {l: MARGIN + LEFT_SUFFIX, r: MARGIN + RIGHT_SUFFIX, t: MARGIN + TOP_SUFFIX, b: MARGIN + BOTTOM_SUFFIX},
internalFly = new Element.Fly();
Ext.override(Element, {
styleHooks: {},
addStyles : function(sides, styles){
var totalSize = 0,
sidesArr = (sides || '').match(wordsRe),
i,
len = sidesArr.length,
side,
styleSides = [];
if (len == 1) {
totalSize = Math.abs(parseFloat(this.getStyle(styles[sidesArr[0]])) || 0);
} else if (len) {
for (i = 0; i < len; i++) {
side = sidesArr[i];
styleSides.push(styles[side]);
}
styleSides = this.getStyle(styleSides);
for (i=0; i < len; i++) {
side = sidesArr[i];
totalSize += Math.abs(parseFloat(styleSides[styles[side]]) || 0);
}
}
return totalSize;
},
addCls: (function(){
var addWithClassList = function(className) {
var me = this,
dom = me.dom,
trimRe = me.trimRe,
origClassName = className,
classList,
newCls,
i,
len,
cls;
if (typeof(className) == 'string') {
className = className.replace(trimRe, '').split(spacesRe);
}
if (dom && className && !!(len = className.length)) {
if (!dom.className) {
dom.className = className.join(' ');
} else {
classList = dom.classList;
if (classList) {
for (i = 0; i < len; ++i) {
cls = className[i];
if (cls) {
if (!classList.contains(cls)) {
if (newCls) {
newCls.push(cls);
} else {
newCls = dom.className.replace(trimRe, '');
newCls = newCls ? [newCls, cls] : [cls];
}
}
}
}
if (newCls) {
dom.className = newCls.join(' '); 
}
} else {
addWithoutClassList(origClassName);
}
}
}
return me;
}, addWithoutClassList = function(className) {
var me = this,
dom = me.dom,
elClasses;
if (dom && className && className.length) {
elClasses = Ext.Element.mergeClsList(dom.className, className);
if (elClasses.changed) {
dom.className = elClasses.join(' '); 
}
}
return me;
};
return hasClassList ? addWithClassList : addWithoutClassList;
})(),
removeCls: function(className) {
var me = this,
dom = me.dom,
classList,
len,
elClasses;
if (typeof(className) == 'string') {
className = className.replace(me.trimRe, '').split(spacesRe);
}
if (dom && dom.className && className && !!(len = className.length)) {
classList = dom.classList;
if (len === 1 && classList) {
if (className[0]) {
classList.remove(className[0]); 
}
} else {
elClasses = Ext.Element.removeCls(dom.className, className);
if (elClasses.changed) {
dom.className = elClasses.join(' ');
}
}
}
return me;
},
radioCls: function(className) {
var cn = this.dom.parentNode.childNodes,
v,
i, len;
className = Ext.isArray(className) ? className: [className];
for (i = 0, len = cn.length; i < len; i++) {
v = cn[i];
if (v && v.nodeType == 1) {
internalFly.attach(v).removeCls(className);
}
}
return this.addCls(className);
},
toggleCls: (function(){
var toggleWithClassList = function(className){
var me = this,
dom = me.dom,
classList;
if (dom) {
className = className.replace(me.trimRe, '');
if (className) {
classList = dom.classList;
if (classList) {
classList.toggle(className);
} else {
toggleWithoutClassList(className);
}
}
}
return me;
}, toggleWithoutClassList = function(className){
return this.hasCls(className) ? this.removeCls(className) : this.addCls(className);
};
return hasClassList ? toggleWithClassList :  toggleWithoutClassList;
})(),
hasCls: (function(){
var hasClsWithClassList = function(className) {
var dom = this.dom,
out = false,
classList;
if (dom && className) {
classList = dom.classList;
if (classList) {
out = classList.contains(className);
} else {
out = hasClsWithoutClassList(className);
}
}
return out;
}, hasClsWithoutClassList = function(className){
var dom = this.dom;
return dom ? className && (' '+dom.className+' ').indexOf(' '+className+' ') !== -1 : false;
};
return hasClassList ? hasClsWithClassList : hasClsWithoutClassList;
})(),
replaceCls: function(oldClassName, newClassName){
return this.removeCls(oldClassName).addCls(newClassName);
},
isStyle: function(style, val) {
return this.getStyle(style) == val;
},
getStyle: function (property, inline) {
var me = this,
dom = me.dom,
multiple = typeof property != 'string',
hooks = me.styleHooks,
prop = property,
props = prop,
len = 1,
domStyle, camel, values, hook, out, style, i;
if (multiple) {
values = {};
prop = props[0];
i = 0;
if (!(len = props.length)) {
return values;
}
}
if (!dom || dom.documentElement) {
return values || '';
}
domStyle = dom.style;
if (inline) {
style = domStyle;
} else {
style = dom.ownerDocument.defaultView.getComputedStyle(dom, null);
if (!style) {
inline = true;
style = domStyle;
}
}
do {
hook = hooks[prop];
if (!hook) {
hooks[prop] = hook = { name: Element.normalize(prop) };
}
if (hook.get) {
out = hook.get(dom, me, inline, style);
} else {
camel = hook.name;
out = style[camel];
}
if (!multiple) {
return out;
}
values[prop] = out;
prop = props[++i];
} while (i < len);
return values;
},
getStyles: function () {
var props = Ext.Array.slice(arguments),
len = props.length,
inline;
if (len && typeof props[len-1] == 'boolean') {
inline = props.pop();
}
return this.getStyle(props, inline);
},
isTransparent: function (prop) {
var value = this.getStyle(prop);
return value ? transparentRe.test(value) : false;
},
setStyle: function(prop, value) {
var me = this,
dom = me.dom,
hooks = me.styleHooks,
style = dom.style,
name = prop,
hook;
if (typeof name == 'string') {
hook = hooks[name];
if (!hook) {
hooks[name] = hook = { name: Element.normalize(name) };
}
value = (value == null) ? '' : value;
if (hook.set) {
hook.set(dom, value, me);
} else {
style[hook.name] = value;
}
if (hook.afterSet) {
hook.afterSet(dom, value, me);
}
} else {
for (name in prop) {
if (prop.hasOwnProperty(name)) {
hook = hooks[name];
if (!hook) {
hooks[name] = hook = { name: Element.normalize(name) };
}
value = prop[name];
value = (value == null) ? '' : value;
if (hook.set) {
hook.set(dom, value, me);
} else {
style[hook.name] = value;
}
if (hook.afterSet) {
hook.afterSet(dom, value, me);
}
}
}
}
return me;
},
getHeight: function(contentHeight) {
var dom = this.dom,
height = contentHeight ? (dom.clientHeight - this.getPadding("tb")) : dom.offsetHeight;
return height > 0 ? height: 0;
},
getWidth: function(contentWidth) {
var dom = this.dom,
width = contentWidth ? (dom.clientWidth - this.getPadding("lr")) : dom.offsetWidth;
return width > 0 ? width: 0;
},
setWidth: function(width) {
var me = this;
me.dom.style.width = Element.addUnits(width);
return me;
},
setHeight: function(height) {
var me = this;
me.dom.style.height = Element.addUnits(height);
return me;
},
getBorderWidth: function(side){
return this.addStyles(side, borders);
},
getPadding: function(side){
return this.addStyles(side, paddings);
},
margins : margins,
applyStyles: function(styles) {
if (styles) {
var i,
len,
dom = this.dom;
if (typeof styles == 'function') {
styles = styles.call();
}
if (typeof styles == 'string') {
styles = Ext.util.Format.trim(styles).split(/\s*(?::|;)\s*/);
for (i = 0, len = styles.length; i < len;) {
dom.style[Element.normalize(styles[i++])] = styles[i++];
}
}
else if (typeof styles == 'object') {
this.setStyle(styles);
}
}
},
setSize: function(width, height) {
var me = this,
style = me.dom.style;
if (Ext.isObject(width)) {
height = width.height;
width = width.width;
}
style.width = Element.addUnits(width);
style.height = Element.addUnits(height);
return me;
},
getViewSize: function() {
var doc = document,
dom = this.dom;
if (dom == doc || dom == doc.body) {
return {
width: Element.getViewportWidth(),
height: Element.getViewportHeight()
};
}
else {
return {
width: dom.clientWidth,
height: dom.clientHeight
};
}
},
getSize: function(contentSize) {
var dom = this.dom;
return {
width: Math.max(0, contentSize ? (dom.clientWidth - this.getPadding("lr")) : dom.offsetWidth),
height: Math.max(0, contentSize ? (dom.clientHeight - this.getPadding("tb")) : dom.offsetHeight)
};
},
repaint: function() {
var dom = this.dom;
this.addCls(Ext.baseCSSPrefix + 'repaint');
setTimeout(function(){
internalFly.attach(dom).removeCls(Ext.baseCSSPrefix + 'repaint');
}, 1);
return this;
},
getMargin: function(side){
var me = this,
hash = {t:"top", l:"left", r:"right", b: "bottom"},
key,
o,
margins;
if (!side) {
margins = [];
for (key in me.margins) {
if(me.margins.hasOwnProperty(key)) {
margins.push(me.margins[key]);
}
}
o = me.getStyle(margins);
if(o && typeof o == 'object') {
for (key in me.margins) {
if(me.margins.hasOwnProperty(key)) {
o[hash[key]] = parseFloat(o[me.margins[key]]) || 0;
}
}
}
return o;
} else {
return me.addStyles(side, me.margins);
}
},
mask: function(msg, msgCls, transparent) {
var me = this,
dom = me.dom,
data = (me.$cache || me.getCache()).data,
el = data.mask,
mask,
size,
cls = '',
prefix = Ext.baseCSSPrefix;
me.addCls(prefix + 'masked');
if (me.getStyle("position") == "static") {
me.addCls(prefix + 'masked-relative');
}
if (el) {
el.remove();
}
if (msgCls && typeof msgCls == 'string' ) {
cls = ' ' + msgCls;
}
else {
cls = ' ' + prefix + 'mask-gray';
}
mask = me.createChild({
role: 'presentation',
cls: prefix + 'mask' + ((transparent !== false) ? '' : (' ' + prefix + 'mask-gray')),
html: msg ? ('<div class="' + (msgCls || (prefix + 'mask-message')) + '" role="presentation">' + msg + '</div>') : ''
});
size = me.getSize();
data.mask = mask;
if (dom === document.body) {
size.height = window.innerHeight;
if (me.orientationHandler) {
Ext.EventManager.unOrientationChange(me.orientationHandler, me);
}
me.orientationHandler = function() {
size = me.getSize();
size.height = window.innerHeight;
mask.setSize(size);
};
Ext.EventManager.onOrientationChange(me.orientationHandler, me);
}
mask.setSize(size);
if (Ext.is.iPad) {
Ext.repaint();
}
},
unmask: function() {
var me = this,
data = (me.$cache || me.getCache()).data,
mask = data.mask,
prefix = Ext.baseCSSPrefix;
if (mask) {
mask.remove();
delete data.mask;
}
me.removeCls([prefix + 'masked', prefix + 'masked-relative']);
if (me.dom === document.body) {
Ext.EventManager.unOrientationChange(me.orientationHandler, me);
delete me.orientationHandler;
}
}
});
Ext.onReady(function () {
var supports = Ext.supports,
styleHooks,
colorStyles, i, name, camel;
function fixTransparent (dom, el, inline, style) {
var value = style[this.name] || '';
return transparentRe.test(value) ? 'transparent' : value;
}
function fixRightMargin (dom, el, inline, style) {
var result = style.marginRight,
domStyle, display;
if (result != '0px') {
domStyle = dom.style;
display = domStyle.display;
domStyle.display = 'inline-block';
result = (inline ? style : dom.ownerDocument.defaultView.getComputedStyle(dom, null)).marginRight;
domStyle.display = display;
}
return result;
}
function fixRightMarginAndInputFocus (dom, el, inline, style) {
var result = style.marginRight,
domStyle, cleaner, display;
if (result != '0px') {
domStyle = dom.style;
cleaner = Element.getRightMarginFixCleaner(dom);
display = domStyle.display;
domStyle.display = 'inline-block';
result = (inline ? style : dom.ownerDocument.defaultView.getComputedStyle(dom, '')).marginRight;
domStyle.display = display;
cleaner();
}
return result;
}
styleHooks = Element.prototype.styleHooks;
if (supports.init) {
supports.init();
}
if (!supports.RightMargin) {
styleHooks.marginRight = styleHooks['margin-right'] = {
name: 'marginRight',
get: (supports.DisplayChangeInputSelectionBug || supports.DisplayChangeTextAreaSelectionBug) ?
fixRightMarginAndInputFocus : fixRightMargin
};
}
if (!supports.TransparentColor) {
colorStyles = ['background-color', 'border-color', 'color', 'outline-color'];
for (i = colorStyles.length; i--; ) {
name = colorStyles[i];
camel = Element.normalize(name);
styleHooks[name] = styleHooks[camel] = {
name: camel,
get: fixTransparent
};
}
}
});
});
Ext.define('Ext.dom.AbstractElement_traversal', {
override: 'Ext.dom.AbstractElement',
findParent: function(simpleSelector, limit, returnEl) {
var target = this.dom,
topmost = document.documentElement,
depth = 0,
stopEl;
limit = limit || 50;
if (isNaN(limit)) {
stopEl = Ext.getDom(limit);
limit = Number.MAX_VALUE;
}
while (target && target.nodeType == 1 && depth < limit && target != topmost && target != stopEl) {
if (Ext.DomQuery.is(target, simpleSelector)) {
return returnEl ? Ext.get(target) : target;
}
depth++;
target = target.parentNode;
}
return null;
},
findParentNode: function(simpleSelector, limit, returnEl) {
var p = Ext.fly(this.dom.parentNode, '_internal');
return p ? p.findParent(simpleSelector, limit, returnEl) : null;
},
up: function(simpleSelector, limit, returnDom) {
return this.findParentNode(simpleSelector, limit, !returnDom);
},
select: function(selector, composite) {
return Ext.dom.Element.select(selector, this.dom, composite);
},
query: function(selector) {
return Ext.DomQuery.select(selector, this.dom);
},
down: function(selector, returnDom) {
var n = Ext.DomQuery.selectNode(selector, this.dom);
return returnDom ? n : Ext.get(n);
},
child: function(selector, returnDom) {
var node,
me = this,
id;
id = Ext.id(me.dom);
id = Ext.escapeId(id);
node = Ext.DomQuery.selectNode('#' + id + " > " + selector, me.dom);
return returnDom ? node : Ext.get(node);
},
parent: function(selector, returnDom) {
return this.matchNode('parentNode', 'parentNode', selector, returnDom);
},
next: function(selector, returnDom) {
return this.matchNode('nextSibling', 'nextSibling', selector, returnDom);
},
prev: function(selector, returnDom) {
return this.matchNode('previousSibling', 'previousSibling', selector, returnDom);
},
first: function(selector, returnDom) {
return this.matchNode('nextSibling', 'firstChild', selector, returnDom);
},
last: function(selector, returnDom) {
return this.matchNode('previousSibling', 'lastChild', selector, returnDom);
},
matchNode: function(dir, start, selector, returnDom) {
if (!this.dom) {
return null;
}
var n = this.dom[start];
while (n) {
if (n.nodeType == 1 && (!selector || Ext.DomQuery.is(n, selector))) {
return !returnDom ? Ext.get(n) : n;
}
n = n[dir];
}
return null;
},
isAncestor: function(element) {
return this.self.isAncestor.call(this.self, this.dom, element);
}
});
Ext.define('Ext.dom.AbstractElement', {
trimRe: /^\s+|\s+$/g,
whitespaceRe: /\s/,
inheritableStatics: {
trimRe: /^\s+|\s+$/g,
whitespaceRe: /\s/,
get: function(el) {
var me = this,
document = window.document,
El = Ext.dom.Element,
cacheItem,
docEl,
extEl,
dom,
id;
if (!el) {
return null;
}
if (el.isFly) {
el = el.dom;
}
if (typeof el == "string") { 
if (el == Ext.windowId) {
return El.get(window);
} else if (el == Ext.documentId) {
return El.get(document);
}
cacheItem = Ext.cache[el];
if (cacheItem && cacheItem.skipGarbageCollection) {
extEl = cacheItem.el;
return extEl;
}
if (!(dom = document.getElementById(el))) {
return null;
}
if (cacheItem && cacheItem.el) {
extEl = Ext.updateCacheEntry(cacheItem, dom).el;
} else {
extEl = new El(dom, !!cacheItem);
}
return extEl;
} else if (el.tagName) { 
if (!(id = el.id)) {
id = Ext.id(el);
}
cacheItem = Ext.cache[id];
if (cacheItem && cacheItem.el) {
extEl = Ext.updateCacheEntry(cacheItem, el).el;
} else {
extEl = new El(el, !!cacheItem);
}
return extEl;
} else if (el instanceof me) {
if (el != me.docEl && el != me.winEl) {
id = el.id;
cacheItem = Ext.cache[id];
if (cacheItem) {
Ext.updateCacheEntry(cacheItem, document.getElementById(id) || el.dom);
}
}
return el;
} else if (el.isComposite) {
return el;
} else if (Ext.isArray(el)) {
return me.select(el);
} else if (el === document) {
if (!me.docEl) {
docEl = me.docEl = Ext.Object.chain(El.prototype);
docEl.dom = document;
docEl.el = docEl;
docEl.id = Ext.id(document);
me.addToCache(docEl);
}
return me.docEl;
} else if (el === window) {
if (!me.winEl) {
me.winEl = Ext.Object.chain(El.prototype);
me.winEl.dom = window;
me.winEl.id = Ext.id(window);
me.addToCache(me.winEl);
}
return me.winEl;
}
return null;
},
addToCache: function(el, id) {
if (el) {
Ext.addCacheEntry(id, el);
}
return el;
},
addMethods: function() {
this.override.apply(this, arguments);
},
mergeClsList: function() {
var clsList, clsHash = {},
i, length, j, listLength, clsName, result = [],
changed = false,
trimRe = this.trimRe,
whitespaceRe = this.whitespaceRe;
for (i = 0, length = arguments.length; i < length; i++) {
clsList = arguments[i];
if (Ext.isString(clsList)) {
clsList = clsList.replace(trimRe, '').split(whitespaceRe);
}
if (clsList) {
for (j = 0, listLength = clsList.length; j < listLength; j++) {
clsName = clsList[j];
if (!clsHash[clsName]) {
if (i) {
changed = true;
}
clsHash[clsName] = true;
}
}
}
}
for (clsName in clsHash) {
result.push(clsName);
}
result.changed = changed;
return result;
},
removeCls: function(existingClsList, removeClsList) {
var clsHash = {},
i, length, clsName, result = [],
changed = false,
whitespaceRe = this.whitespaceRe;
if (existingClsList) {
if (Ext.isString(existingClsList)) {
existingClsList = existingClsList.replace(this.trimRe, '').split(whitespaceRe);
}
for (i = 0, length = existingClsList.length; i < length; i++) {
clsHash[existingClsList[i]] = true;
}
}
if (removeClsList) {
if (Ext.isString(removeClsList)) {
removeClsList = removeClsList.split(whitespaceRe);
}
for (i = 0, length = removeClsList.length; i < length; i++) {
clsName = removeClsList[i];
if (clsHash[clsName]) {
changed = true;
delete clsHash[clsName];
}
}
}
for (clsName in clsHash) {
result.push(clsName);
}
result.changed = changed;
return result;
},
VISIBILITY: 1,
DISPLAY: 2,
OFFSETS: 3,
ASCLASS: 4
},
constructor: function(element, forceNew) {
var me = this,
dom = typeof element == 'string'
? document.getElementById(element)
: element,
id;
me.el = me;
if (!dom) {
return null;
}
id = dom.id;
if (!forceNew && id && Ext.cache[id]) {
return Ext.cache[id].el;
}
me.dom = dom;
me.id = id || Ext.id(dom);
me.self.addToCache(me);
},
set: function(o, useSet) {
var el = this.dom,
attr,
value;
for (attr in o) {
if (o.hasOwnProperty(attr)) {
value = o[attr];
if (attr == 'style') {
this.applyStyles(value);
}
else if (attr == 'cls') {
el.className = value;
}
else if (useSet !== false) {
if (value === undefined) {
el.removeAttribute(attr);
} else {
el.setAttribute(attr, value);
}
}
else {
el[attr] = value;
}
}
}
return this;
},
defaultUnit: "px",
is: function(simpleSelector) {
return Ext.DomQuery.is(this.dom, simpleSelector);
},
getValue: function(asNumber) {
var val = this.dom.value;
return asNumber ? parseInt(val, 10) : val;
},
remove: function() {
var me = this,
dom = me.dom;
if (me.isAnimate) {
me.stopAnimation();
}
if (dom) {
Ext.removeNode(dom);
delete me.dom;
}
},
contains: (function () {
var isXpc = function (el) {
var s;
try {
el = el.dom || el;
} catch (e) {
return true;
}
s = HTMLElement.prototype.toString.call(el);
return s === '[xpconnect wrapped native prototype]' || s === '[object XULElement]';
};
return function (el) {
if (!el || (Ext.isGecko3 && isXpc(el))) {
return false;
}
var me = this,
dom = el.dom || el;
return (dom === me.dom) || Ext.dom.AbstractElement.isAncestor(me.dom, dom);
};
}()),
getAttribute: function(name, ns) {
var dom = this.dom;
return dom.getAttributeNS(ns, name) || dom.getAttribute(ns + ":" + name) || dom.getAttribute(name) || dom[name];
},
update: function(html) {
if (this.dom) {
this.dom.innerHTML = html;
}
return this;
},
setHTML: function(html) {
if(this.dom) {
this.dom.innerHTML = html;
}
return this;
},
getHTML: function() {
return this.dom ? this.dom.innerHTML : '';
},
hide: function() {
this.setVisible(false);
return this;
},
show: function() {
this.setVisible(true);
return this;
},
setVisible: function(visible, animate) {
var me = this,
statics = me.self,
mode = me.getVisibilityMode(),
prefix = Ext.baseCSSPrefix;
switch (mode) {
case statics.VISIBILITY:
me.removeCls([prefix + 'hidden-display', prefix + 'hidden-offsets']);
me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-visibility');
break;
case statics.DISPLAY:
me.removeCls([prefix + 'hidden-visibility', prefix + 'hidden-offsets']);
me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-display');
break;
case statics.OFFSETS:
me.removeCls([prefix + 'hidden-visibility', prefix + 'hidden-display']);
me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-offsets');
break;
}
return me;
},
getVisibilityMode: function() {
var data = (this.$cache || this.getCache()).data,
visMode = data.visibilityMode;
if (visMode === undefined) {
data.visibilityMode = visMode = this.self.DISPLAY;
}
return visMode;
},
setVisibilityMode: function(mode) {
(this.$cache || this.getCache()).data.visibilityMode = mode;
return this;
},
getCache: function() {
var me = this,
id = me.dom.id || Ext.id(me.dom);
me.$cache = Ext.cache[id] || Ext.addCacheEntry(id, null, me.dom);
return me.$cache;
}
},
function() {
var AbstractElement = this;
Ext.getDetachedBody = function () {
var detachedEl = AbstractElement.detachedBodyEl;
if (!detachedEl) {
detachedEl = document.createElement('div');
AbstractElement.detachedBodyEl = detachedEl = new AbstractElement.Fly(detachedEl);
detachedEl.isDetachedBody = true;
}
return detachedEl;
};
Ext.getElementById = function (id) {
var el = document.getElementById(id),
detachedBodyEl;
if (!el && (detachedBodyEl = AbstractElement.detachedBodyEl)) {
el = detachedBodyEl.dom.querySelector('#' + Ext.escapeId(id));
}
return el;
};
Ext.get = function(el) {
return Ext.dom.Element.get(el);
};
this.addStatics({
Fly: new Ext.Class({
extend: AbstractElement,
isFly: true,
constructor: function(dom) {
this.dom = dom;
this.el = this;
},
attach: function (dom) {
this.dom = dom;
this.$cache = dom && dom.id ? Ext.cache[dom.id] : null;
return this;
}
}),
_flyweights: {},
fly: function(dom, named) {
var fly = null,
_flyweights = AbstractElement._flyweights;
named = named || '_global';
dom = Ext.getDom(dom);
if (dom) {
fly = _flyweights[named] || (_flyweights[named] = new AbstractElement.Fly());
fly.dom = dom;
fly.$cache = dom.id ? Ext.cache[dom.id] : null;
}
return fly;
}
});
Ext.fly = function() {
return AbstractElement.fly.apply(AbstractElement, arguments);
};
(function (proto) {
proto.destroy = proto.remove;
if (document.querySelector) {
proto.getById = function (id, asDom) {
var dom = document.getElementById(id) ||
this.dom.querySelector('#'+Ext.escapeId(id));
return asDom ? dom : (dom ? Ext.get(dom) : null);
};
} else {
proto.getById = function (id, asDom) {
var dom = document.getElementById(id);
return asDom ? dom : (dom ? Ext.get(dom) : null);
};
}
}(this.prototype));
});
Ext.define('Ext.dom.Helper', (function() {
var afterbegin = 'afterbegin',
afterend = 'afterend',
beforebegin = 'beforebegin',
beforeend = 'beforeend',
ts = '<table>',
te = '</table>',
tbs = ts+'<tbody>',
tbe = '</tbody>'+te,
trs = tbs + '<tr>',
tre = '</tr>'+tbe,
detachedDiv = document.createElement('div'),
bbValues = ['BeforeBegin', 'previousSibling'],
aeValues = ['AfterEnd', 'nextSibling'],
bb_ae_PositionHash = {
beforebegin: bbValues,
afterend: aeValues
},
fullPositionHash = {
beforebegin: bbValues,
afterend: aeValues,
afterbegin: ['AfterBegin', 'firstChild'],
beforeend: ['BeforeEnd', 'lastChild']
};
return {
extend:  Ext.dom.AbstractHelper ,
tableRe: /^(?:table|thead|tbody|tr|td)$/i,
tableElRe: /td|tr|tbody|thead/i,
useDom : false,
createDom: function(o, parentNode){
var el,
doc = document,
useSet,
attr,
val,
cn,
i, l;
if (Ext.isArray(o)) {                       
el = doc.createDocumentFragment(); 
for (i = 0, l = o.length; i < l; i++) {
this.createDom(o[i], el);
}
} else if (typeof o == 'string') {         
el = doc.createTextNode(o);
} else {
el = doc.createElement(o.tag || 'div');
useSet = !!el.setAttribute; 
for (attr in o) {
if (!this.confRe.test(attr)) {
val = o[attr];
if (attr == 'cls') {
el.className = val;
} else {
if (useSet) {
el.setAttribute(attr, val);
} else {
el[attr] = val;
}
}
}
}
Ext.DomHelper.applyStyles(el, o.style);
if ((cn = o.children || o.cn)) {
this.createDom(cn, el);
} else if (o.html) {
el.innerHTML = o.html;
}
}
if (parentNode) {
parentNode.appendChild(el);
}
return el;
},
ieTable: function(depth, openingTags, htmlContent, closingTags){
detachedDiv.innerHTML = [openingTags, htmlContent, closingTags].join('');
var i = -1,
el = detachedDiv,
ns;
while (++i < depth) {
el = el.firstChild;
}
ns = el.nextSibling;
if (ns) {
ns = el;
el = document.createDocumentFragment();
while (ns) {
nx = ns.nextSibling;
el.appendChild(ns);
ns = nx;
}
}
return el;
},
insertIntoTable: function(tag, where, destinationEl, html) {
var node,
before,
bb = where == beforebegin,
ab = where == afterbegin,
be = where == beforeend,
ae = where == afterend;
if (tag == 'td' && (ab || be) || !this.tableElRe.test(tag) && (bb || ae)) {
return null;
}
before = bb ? destinationEl :
ae ? destinationEl.nextSibling :
ab ? destinationEl.firstChild : null;
if (bb || ae) {
destinationEl = destinationEl.parentNode;
}
if (tag == 'td' || (tag == 'tr' && (be || ab))) {
node = this.ieTable(4, trs, html, tre);
} else if (((tag == 'tbody' || tag == 'thead') && (be || ab)) ||
(tag == 'tr' && (bb || ae))) {
node = this.ieTable(3, tbs, html, tbe);
} else {
node = this.ieTable(2, ts, html, te);
}
destinationEl.insertBefore(node, before);
return node;
},
createContextualFragment: function(html) {
var fragment = document.createDocumentFragment(),
length, childNodes;
detachedDiv.innerHTML = html;
childNodes = detachedDiv.childNodes;
length = childNodes.length;
while (length--) {
fragment.appendChild(childNodes[0]);
}
return fragment;
},
applyStyles: function(el, styles) {
if (styles) {
if (typeof styles == "function") {
styles = styles.call();
}
if (typeof styles == "string") {
styles = Ext.dom.Element.parseStyles(styles);
}
if (typeof styles == "object") {
Ext.fly(el, '_applyStyles').setStyle(styles);
}
}
},
createHtml: function(spec) {
return this.markup(spec);
},
doInsert: function(el, o, returnElement, pos, sibling, append) {
el = el.dom || Ext.getDom(el);
var newNode;
if (this.useDom) {
newNode = this.createDom(o, null);
if (append) {
el.appendChild(newNode);
}
else {
(sibling == 'firstChild' ? el : el.parentNode).insertBefore(newNode, el[sibling] || el);
}
} else {
newNode = this.insertHtml(pos, el, this.markup(o));
}
return returnElement ? Ext.get(newNode, true) : newNode;
},
overwrite: function(el, html, returnElement) {
var newNode;
el = Ext.getDom(el);
html = this.markup(html);
if (Ext.isIE && this.tableRe.test(el.tagName)) {
while (el.firstChild) {
el.removeChild(el.firstChild);
}
if (html) {
newNode = this.insertHtml('afterbegin', el, html);
return returnElement ? Ext.get(newNode) : newNode;
}
return null;
}
el.innerHTML = html;
return returnElement ? Ext.get(el.firstChild) : el.firstChild;
},
insertHtml: function(where, el, html) {
var hashVal,
range,
rangeEl,
setStart,
frag;
where = where.toLowerCase();
if (el.insertAdjacentHTML) {
if (Ext.isIE && this.tableRe.test(el.tagName) && (frag = this.insertIntoTable(el.tagName.toLowerCase(), where, el, html))) {
return frag;
}
if ((hashVal = fullPositionHash[where])) {
if (Ext.global.MSApp && Ext.global.MSApp.execUnsafeLocalFunction) {
MSApp.execUnsafeLocalFunction(function () {
el.insertAdjacentHTML(hashVal[0], html);
});
} else {
el.insertAdjacentHTML(hashVal[0], html);
}
return el[hashVal[1]];
}
} else {
if (el.nodeType === 3) {
where = where === 'afterbegin' ? 'beforebegin' : where;
where = where === 'beforeend' ? 'afterend' : where;
}
range = Ext.supports.CreateContextualFragment ? el.ownerDocument.createRange() : undefined;
setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
if (bb_ae_PositionHash[where]) {
if (range) {
range[setStart](el);
frag = range.createContextualFragment(html);
} else {
frag = this.createContextualFragment(html);
}
el.parentNode.insertBefore(frag, where == beforebegin ? el : el.nextSibling);
return el[(where == beforebegin ? 'previous' : 'next') + 'Sibling'];
} else {
rangeEl = (where == afterbegin ? 'first' : 'last') + 'Child';
if (el.firstChild) {
if (range) {
range[setStart](el[rangeEl]);
frag = range.createContextualFragment(html);
} else {
frag = this.createContextualFragment(html);
}
if (where == afterbegin) {
el.insertBefore(frag, el.firstChild);
} else {
el.appendChild(frag);
}
} else {
el.innerHTML = html;
}
return el[rangeEl];
}
}
},
createTemplate: function(o) {
var html = this.markup(o);
return new Ext.Template(html);
}
};
})(), function() {
Ext.ns('Ext.core');
Ext.DomHelper = Ext.core.DomHelper = new this;
});
Ext.define('Ext.Template', {
inheritableStatics: {
from: function(el, config) {
el = Ext.getDom(el);
return new this(el.value || el.innerHTML, config || '');
}
},
constructor: function(html) {
var me = this,
args = arguments,
buffer = [],
i = 0,
length = args.length,
value;
me.initialConfig = {};
if (length === 1 && Ext.isArray(html)) {
args = html;
length = args.length;
}
if (length > 1) {
for (; i < length; i++) {
value = args[i];
if (typeof value == 'object') {
Ext.apply(me.initialConfig, value);
Ext.apply(me, value);
} else {
buffer.push(value);
}
}
} else {
buffer.push(html);
}
me.html = buffer.join('');
if (me.compiled) {
me.compile();
}
},
isTemplate: true,
disableFormats: false,
re: /\{([\w\-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g,
apply: function(values) {
var me = this,
useFormat = me.disableFormats !== true,
fm = Ext.util.Format,
tpl = me,
ret;
if (me.compiled) {
return me.compiled(values).join('');
}
function fn(m, name, format, args) {
if (format && useFormat) {
if (args) {
args = [values[name]].concat(Ext.functionFactory('return ['+ args +'];')());
} else {
args = [values[name]];
}
if (format.substr(0, 5) == "this.") {
return tpl[format.substr(5)].apply(tpl, args);
}
else {
return fm[format].apply(fm, args);
}
}
else {
return values[name] !== undefined ? values[name] : "";
}
}
ret = me.html.replace(me.re, fn);
return ret;
},
applyOut: function(values, out) {
var me = this;
if (me.compiled) {
out.push.apply(out, me.compiled(values));
} else {
out.push(me.apply(values));
}
return out;
},
applyTemplate: function () {
return this.apply.apply(this, arguments);
},
set: function(html, compile) {
var me = this;
me.html = html;
me.compiled = null;
return compile ? me.compile() : me;
},
compileARe: /\\/g,
compileBRe: /(\r\n|\n)/g,
compileCRe: /'/g,
compile: function() {
var me = this,
fm = Ext.util.Format,
useFormat = me.disableFormats !== true,
body, bodyReturn;
function fn(m, name, format, args) {
if (format && useFormat) {
args = args ? ',' + args: "";
if (format.substr(0, 5) != "this.") {
format = "fm." + format + '(';
}
else {
format = 'this.' + format.substr(5) + '(';
}
}
else {
args = '';
format = "(values['" + name + "'] == undefined ? '' : ";
}
return "'," + format + "values['" + name + "']" + args + ") ,'";
}
bodyReturn = me.html.replace(me.compileARe, '\\\\').replace(me.compileBRe, '\\n').replace(me.compileCRe, "\\'").replace(me.re, fn);
body = "this.compiled = function(values){ return ['" + bodyReturn + "'];};";
eval(body);
return me;
},
insertFirst: function(el, values, returnElement) {
return this.doInsert('afterBegin', el, values, returnElement);
},
insertBefore: function(el, values, returnElement) {
return this.doInsert('beforeBegin', el, values, returnElement);
},
insertAfter: function(el, values, returnElement) {
return this.doInsert('afterEnd', el, values, returnElement);
},
append: function(el, values, returnElement) {
return this.doInsert('beforeEnd', el, values, returnElement);
},
doInsert: function(where, el, values, returnElement) {
var newNode = Ext.DomHelper.insertHtml(where, Ext.getDom(el), this.apply(values));
return returnElement ? Ext.get(newNode) : newNode;
},
overwrite: function(el, values, returnElement) {
var newNode = Ext.DomHelper.overwrite(Ext.getDom(el), this.apply(values));
return returnElement ? Ext.get(newNode) : newNode;
}
});
Ext.define('Ext.XTemplateParser', {
constructor: function (config) {
Ext.apply(this, config);
},
doTpl: Ext.emptyFn,
parse: function (str) {
var me = this,
len = str.length,
aliases = { elseif: 'elif' },
topRe = me.topRe,
actionsRe = me.actionsRe,
index, stack, s, m, t, prev, frame, subMatch, begin, end, actions,
prop;
me.level = 0;
me.stack = stack = [];
for (index = 0; index < len; index = end) {
topRe.lastIndex = index;
m = topRe.exec(str);
if (!m) {
me.doText(str.substring(index, len));
break;
}
begin = m.index;
end = topRe.lastIndex;
if (index < begin) {
me.doText(str.substring(index, begin));
}
if (m[1]) {
end = str.indexOf('%}', begin+2);
me.doEval(str.substring(begin+2, end));
end += 2;
} else if (m[2]) {
end = str.indexOf(']}', begin+2);
me.doExpr(str.substring(begin+2, end));
end += 2;
} else if (m[3]) { // if ('{' token)
me.doTag(m[3]);
} else if (m[4]) { // content of a <tpl xxxxxx xxx> tag
actions = null;
while ((subMatch = actionsRe.exec(m[4])) !== null) {
s = subMatch[2] || subMatch[3];
if (s) {
s = Ext.String.htmlDecode(s); // decode attr value
t = subMatch[1];
t = aliases[t] || t;
actions = actions || {};
prev = actions[t];
if (typeof prev == 'string') {
actions[t] = [prev, s];
} else if (prev) {
actions[t].push(s);
} else {
actions[t] = s;
}
}
}
if (!actions) {
if (me.elseRe.test(m[4])) {
me.doElse();
} else if (me.defaultRe.test(m[4])) {
me.doDefault();
} else {
me.doTpl();
stack.push({ type: 'tpl' });
}
}
else if (actions['if']) {
me.doIf(actions['if'], actions);
stack.push({ type: 'if' });
}
else if (actions['switch']) {
me.doSwitch(actions['switch'], actions);
stack.push({ type: 'switch' });
}
else if (actions['case']) {
me.doCase(actions['case'], actions);
}
else if (actions['elif']) {
me.doElseIf(actions['elif'], actions);
}
else if (actions['for']) {
++me.level;
if (prop = me.propRe.exec(m[4])) {
actions.propName = prop[1] || prop[2];
}
me.doFor(actions['for'], actions);
stack.push({ type: 'for', actions: actions });
}
else if (actions['foreach']) {
++me.level;
if (prop = me.propRe.exec(m[4])) {
actions.propName = prop[1] || prop[2];
}
me.doForEach(actions['foreach'], actions);
stack.push({ type: 'foreach', actions: actions });
}
else if (actions.exec) {
me.doExec(actions.exec, actions);
stack.push({ type: 'exec', actions: actions });
}
else {
}
} else if (m[0].length === 5) {
stack.push({ type: 'tpl' });
} else {
frame = stack.pop();
me.doEnd(frame.type, frame.actions);
if (frame.type == 'for' || frame.type == 'foreach') {
--me.level;
}
}
}
},
topRe:     /(?:(\{\%)|(\{\[)|\{([^{}]+)\})|(?:<tpl([^>]*)\>)|(?:<\/tpl>)/g,
actionsRe: /\s*(elif|elseif|if|for|foreach|exec|switch|case|eval|between)\s*\=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g,
propRe:    /prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/,
defaultRe: /^\s*default\s*$/,
elseRe:    /^\s*else\s*$/
});
Ext.define('Ext.XTemplateCompiler', {
extend:  Ext.XTemplateParser ,
useEval: Ext.isGecko,
useIndex: Ext.isIE8m,
useFormat: true,
propNameRe: /^[\w\d\$]*$/,
compile: function (tpl) {
var me = this,
code = me.generate(tpl);
return me.useEval ? me.evalTpl(code) : (new Function('Ext', code))(Ext);
},
generate: function (tpl) {
var me = this,
definitions = 'var fm=Ext.util.Format,ts=Object.prototype.toString;',
code;
me.maxLevel = 0;
me.body = [
'var c0=values, a0=' + me.createArrayTest(0) + ', p0=parent, n0=xcount, i0=xindex, k0, v;\n'
];
if (me.definitions) {
if (typeof me.definitions === 'string') {
me.definitions = [me.definitions, definitions ];
} else {
me.definitions.push(definitions);
}
} else {
me.definitions = [ definitions ];
}
me.switches = [];
me.parse(tpl);
me.definitions.push(
(me.useEval ? '$=' : 'return') + ' function (' + me.fnArgs + ') {',
me.body.join(''),
'}'
);
code = me.definitions.join('\n');
me.definitions.length = me.body.length = me.switches.length = 0;
delete me.definitions;
delete me.body;
delete me.switches;
return code;
},
doText: function (text) {
var me = this,
out = me.body;
text = text.replace(me.aposRe, "\\'").replace(me.newLineRe, '\\n');
if (me.useIndex) {
out.push('out[out.length]=\'', text, '\'\n');
} else {
out.push('out.push(\'', text, '\')\n');
}
},
doExpr: function (expr) {
var out = this.body;
out.push('if ((v=' + expr + ') != null) out');
if (this.useIndex) {
out.push('[out.length]=v+\'\'\n');
} else {
out.push('.push(v+\'\')\n');
}
},
doTag: function (tag) {
var expr = this.parseTag(tag);
if (expr) {
this.doExpr(expr);
} else {
this.doText('{' + tag + '}');
}
},
doElse: function () {
this.body.push('} else {\n');
},
doEval: function (text) {
this.body.push(text, '\n');
},
doIf: function (action, actions) {
var me = this;
if (action === '.') {
me.body.push('if (values) {\n');
} else if (me.propNameRe.test(action)) {
me.body.push('if (', me.parseTag(action), ') {\n');
}
else {
me.body.push('if (', me.addFn(action), me.callFn, ') {\n');
}
if (actions.exec) {
me.doExec(actions.exec);
}
},
doElseIf: function (action, actions) {
var me = this;
if (action === '.') {
me.body.push('else if (values) {\n');
} else if (me.propNameRe.test(action)) {
me.body.push('} else if (', me.parseTag(action), ') {\n');
}
else {
me.body.push('} else if (', me.addFn(action), me.callFn, ') {\n');
}
if (actions.exec) {
me.doExec(actions.exec);
}
},
doSwitch: function (action) {
var me = this;
if (action === '.') {
me.body.push('switch (values) {\n');
} else if (me.propNameRe.test(action)) {
me.body.push('switch (', me.parseTag(action), ') {\n');
}
else {
me.body.push('switch (', me.addFn(action), me.callFn, ') {\n');
}
me.switches.push(0);
},
doCase: function (action) {
var me = this,
cases = Ext.isArray(action) ? action : [action],
n = me.switches.length - 1,
match, i;
if (me.switches[n]) {
me.body.push('break;\n');
} else {
me.switches[n]++;
}
for (i = 0, n = cases.length; i < n; ++i) {
match = me.intRe.exec(cases[i]);
cases[i] = match ? match[1] : ("'" + cases[i].replace(me.aposRe,"\\'") + "'");
}
me.body.push('case ', cases.join(': case '), ':\n');
},
doDefault: function () {
var me = this,
n = me.switches.length - 1;
if (me.switches[n]) {
me.body.push('break;\n');
} else {
me.switches[n]++;
}
me.body.push('default:\n');
},
doEnd: function (type, actions) {
var me = this,
L = me.level-1;
if (type == 'for' || type == 'foreach') {
if (actions.exec) {
me.doExec(actions.exec);
}
me.body.push('}\n');
me.body.push('parent=p',L,';values=r',L+1,';xcount=n'+L+';xindex=i',L,'+1;xkey=k',L,';\n');
} else if (type == 'if' || type == 'switch') {
me.body.push('}\n');
}
},
doFor: function (action, actions) {
var me = this,
s,
L = me.level,
up = L-1,
parentAssignment;
if (action === '.') {
s = 'values';
} else if (me.propNameRe.test(action)) {
s = me.parseTag(action);
}
else {
s = me.addFn(action) + me.callFn;
}
if (me.maxLevel < L) {
me.maxLevel = L;
me.body.push('var ');
}
if (action == '.') {
parentAssignment = 'c' + L;
} else {
parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
}
me.body.push('i',L,'=0,n', L, '=0,c',L,'=',s,',a',L,'=', me.createArrayTest(L),',r',L,'=values,p',L,',k',L,';\n',
'p',L,'=parent=',parentAssignment,'\n',
'if (c',L,'){if(a',L,'){n', L,'=c', L, '.length;}else if (c', L, '.isMixedCollection){c',L,'=c',L,'.items;n',L,'=c',L,'.length;}else if(c',L,'.isStore){c',L,'=c',L,'.data.items;n',L,'=c',L,'.length;}else{c',L,'=[c',L,'];n',L,'=1;}}\n',
'for (xcount=n',L,';i',L,'<n'+L+';++i',L,'){\n',
'values=c',L,'[i',L,']');
if (actions.propName) {
me.body.push('.', actions.propName);
}
me.body.push('\n',
'xindex=i',L,'+1\n');
if (actions.between) {
me.body.push('if(xindex>1){ out.push("',actions.between,'"); } \n');
}
},
doForEach: function (action, actions) {
var me = this,
s,
L = me.level,
up = L-1,
parentAssignment;
if (action === '.') {
s = 'values';
} else if (me.propNameRe.test(action)) {
s = me.parseTag(action);
}
else {
s = me.addFn(action) + me.callFn;
}
if (me.maxLevel < L) {
me.maxLevel = L;
me.body.push('var ');
}
if (action == '.') {
parentAssignment = 'c' + L;
} else {
parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
}
me.body.push('i',L,'=-1,n',L,'=0,c',L,'=',s,',a',L,'=',me.createArrayTest(L),',r',L,'=values,p',L,',k',L,';\n',
'p',L,'=parent=',parentAssignment,'\n',
'for(k',L,' in c',L,'){\n',
'xindex=++i',L,'+1;\n',
'xkey=k',L,';\n',
'values=c',L,'[k',L,'];');
if (actions.propName) {
me.body.push('.', actions.propName);
}
if (actions.between) {
me.body.push('if(xindex>1){ out.push("',actions.between,'"); } \n');
}
},
createArrayTest: ('isArray' in Array) ? function(L) {
return 'Array.isArray(c' + L + ')';
} : function(L) {
return 'ts.call(c' + L + ')==="[object Array]"';
},
doExec: function (action, actions) {
var me = this,
name = 'f' + me.definitions.length;
me.definitions.push('function ' + name + '(' + me.fnArgs + ') {',
' try { with(values) {',
'  ' + action,
' }} catch(e) {',
'}',
'}');
me.body.push(name + me.callFn + '\n');
},
addFn: function (body) {
var me = this,
name = 'f' + me.definitions.length;
if (body === '.') {
me.definitions.push('function ' + name + '(' + me.fnArgs + ') {',
' return values',
'}');
} else if (body === '..') {
me.definitions.push('function ' + name + '(' + me.fnArgs + ') {',
' return parent',
'}');
} else {
me.definitions.push('function ' + name + '(' + me.fnArgs + ') {',
' try { with(values) {',
'  return(' + body + ')',
' }} catch(e) {',
'}',
'}');
}
return name;
},
parseTag: function (tag) {
var me = this,
m = me.tagRe.exec(tag),
name, format, args, math, v;
if (!m) {
return null;
}
name = m[1];
format = m[2];
args = m[3];
math = m[4];
if (name == '.') {
if (!me.validTypes) {
me.definitions.push('var validTypes={string:1,number:1,boolean:1};');
me.validTypes = true;
}
v = 'validTypes[typeof values] || ts.call(values) === "[object Date]" ? values : ""';
}
else if (name == '#') {
v = 'xindex';
}
else if (name == '$') {
v = 'xkey';
}
else if (name.substr(0, 7) == "parent.") {
v = name;
}
else if (isNaN(name) && name.indexOf('-') == -1 && name.indexOf('.') != -1) {
v = "values." + name;
}
else {    
v = "values['" + name + "']";
}
if (math) {
v = '(' + v + math + ')';
}
if (format && me.useFormat) {
args = args ? ',' + args : "";
if (format.substr(0, 5) != "this.") {
format = "fm." + format + '(';
} else {
format += '(';
}
} else {
return v;
}
return format + v + args + ')';
},
evalTpl: function ($) {
eval($);
return $;
},
newLineRe: /\r\n|\r|\n/g,
aposRe: /[']/g,
intRe:  /^\s*(\d+)\s*$/,
tagRe:  /^([\w-\.\#\$]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?$/
}, function () {
var proto = this.prototype;
proto.fnArgs = 'out,values,parent,xindex,xcount,xkey';
proto.callFn = '.call(this,' + proto.fnArgs + ')';
});
Ext.define('Ext.XTemplate', {
extend:  Ext.Template ,
emptyObj: {},
apply: function(values, parent) {
return this.applyOut(values, [], parent).join('');
},
applyOut: function(values, out, parent) {
var me = this,
compiler;
if (!me.fn) {
compiler = new Ext.XTemplateCompiler({
useFormat: me.disableFormats !== true,
definitions: me.definitions
});
me.fn = compiler.compile(me.html);
}
try {
me.fn(out, values, parent || me.emptyObj, 1, 1);
} catch (e) {
}
return out;
},
compile: function() {
return this;
},
statics: {
getTpl: function (instance, name) {
var tpl = instance[name], // go for it! 99% of the time we will get it!
owner;
if (tpl && !tpl.isTemplate) { // tpl is just a configuration (not an instance)
tpl = Ext.ClassManager.dynInstantiate('Ext.XTemplate', tpl);
if (instance.hasOwnProperty(name)) { // the tpl is on the instance
owner = instance;
} else { // must be somewhere in the prototype chain
for (owner = instance.self.prototype; owner && !owner.hasOwnProperty(name); owner = owner.superclass) {
}
}
owner[name] = tpl;
tpl.owner = owner;
}
return tpl || null;
}
}
});
Ext.ns('Ext.core');
Ext.dom.Query = Ext.core.DomQuery = Ext.DomQuery = (function() {
var DQ,
doc = document,
cache = {},
simpleCache = {},
valueCache = {},
useClassList = !!doc.documentElement.classList,
useElementPointer = !!doc.documentElement.firstElementChild,
useChildrenCollection = (function() {
var d = doc.createElement('div');
d.innerHTML = '<!-- -->text<!-- -->';
return d.children && (d.children.length === 0);
})(),
nonSpace = /\S/,
trimRe = /^\s+|\s+$/g,
tplRe = /\{(\d+)\}/g,
modeRe = /^(\s?[\/>+~]\s?|\s|$)/,
tagTokenRe = /^(#)?([\w\-\*\|\\]+)/,
nthRe = /(\d*)n\+?(\d*)/,
nthRe2 = /\D/,
startIdRe = /^\s*#/,
isIE = window.ActiveXObject ? true : false,
key = 30803,
longHex = /\\([0-9a-fA-F]{6})/g,
shortHex = /\\([0-9a-fA-F]{1,6})\s{0,1}/g,
nonHex = /\\([^0-9a-fA-F]{1})/g,
escapes = /\\/g,
num, hasEscapes,
supportsColonNsSeparator = (function () {
var xmlDoc,
xmlString = '<r><a:b xmlns:a="n"></a:b></r>';
if (window.DOMParser) {
xmlDoc = (new DOMParser()).parseFromString(xmlString, "application/xml");
} else {
xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
xmlDoc.loadXML(xmlString);
}
return !!xmlDoc.getElementsByTagName('a:b').length;
})(),
longHexToChar = function($0, $1) {
return String.fromCharCode(parseInt($1, 16));
},
shortToLongHex = function($0, $1) {
while ($1.length < 6) {
$1 = '0' + $1;
}
return '\\' + $1;
},
charToLongHex = function($0, $1) {
num = $1.charCodeAt(0).toString(16);
if (num.length === 1) {
num = '0' + num;
}
return '\\0000' + num;
},
unescapeCssSelector = function(selector) {
return (hasEscapes) ? selector.replace(longHex, longHexToChar) : selector;
},
setupEscapes = function(path) {
hasEscapes = (path.indexOf('\\') > -1);
if (hasEscapes) {
path = path
.replace(shortHex, shortToLongHex)
.replace(nonHex, charToLongHex)
.replace(escapes, '\\\\');  // double the '\' for js compilation
}
return path;
};
eval("var batch = 30803, child, next, prev, byClassName;");
child = useChildrenCollection ?
function child(parent, index) {
return parent.children[index];
} :
function child(parent, index) {
var i = 0,
n = parent.firstChild;
while (n) {
if (n.nodeType == 1) {
if (++i == index) {
return n;
}
}
n = n.nextSibling;
}
return null;
};
next = useElementPointer ?
function(n) {
return n.nextElementSibling;
} :
function(n) {
while ((n = n.nextSibling) && n.nodeType != 1);
return n;
};
prev = useElementPointer ?
function(n) {
return n.previousElementSibling;
} :
function(n) {
while ((n = n.previousSibling) && n.nodeType != 1);
return n;
};
function children(parent) {
var n = parent.firstChild,
nodeIndex = -1,
nextNode;
while (n) {
nextNode = n.nextSibling;
if (n.nodeType == 3 && !nonSpace.test(n.nodeValue)) {
parent.removeChild(n);
} else {
n.nodeIndex = ++nodeIndex;
}
n = nextNode;
}
return this;
}
byClassName = useClassList ? // Use classList API where available: http://jsperf.com/classlist-vs-old-school-check/
function (nodeSet, cls) {
cls = unescapeCssSelector(cls);
if (!cls) {
return nodeSet;
}
var result = [], ri = -1,
i, ci, classList;
for (i = 0; ci = nodeSet[i]; i++) {
classList = ci.classList;
if (classList) {
if (classList.contains(cls)) {
result[++ri] = ci;
}
} else if ((' ' + ci.className + ' ').indexOf(cls) !== -1) {
result[++ri] = ci;
}
}
return result;
} :
function (nodeSet, cls) {
cls = unescapeCssSelector(cls);
if (!cls) {
return nodeSet;
}
var result = [], ri = -1,
i, ci;
for (i = 0; ci = nodeSet[i]; i++) {
if ((' ' + ci.className + ' ').indexOf(cls) !== -1) {
result[++ri] = ci;
}
}
return result;
};
function attrValue(n, attr) {
if (!n.tagName && typeof n.length != "undefined") {
n = n[0];
}
if (!n) {
return null;
}
if (attr == "for") {
return n.htmlFor;
}
if (attr == "class" || attr == "className") {
return n.className;
}
return n.getAttribute(attr) || n[attr];
}
function getNodes(ns, mode, tagName) {
var result = [], ri = -1, cs,
i, ni, j, ci, cn, utag, n, cj;
if (!ns) {
return result;
}
tagName = tagName.replace('|', ':') || "*";
if (typeof ns.getElementsByTagName != "undefined") {
ns = [ns];
}
if (!mode) {
tagName = unescapeCssSelector(tagName);
if (!supportsColonNsSeparator && DQ.isXml(ns[0]) &&
tagName.indexOf(':') !== -1) {
for (i = 0; ni = ns[i]; i++) {
cs = ni.getElementsByTagName(tagName.split(':').pop());
for (j = 0; ci = cs[j]; j++) {
if (ci.tagName === tagName) {
result[++ri] = ci;
}
}
}
} else {
for (i = 0; ni = ns[i]; i++) {
cs = ni.getElementsByTagName(tagName);
for (j = 0; ci = cs[j]; j++) {
result[++ri] = ci;
}
}
}
} else if (mode == "/" || mode == ">") {
utag = tagName.toUpperCase();
for (i = 0; ni = ns[i]; i++) {
cn = ni.childNodes;
for (j = 0; cj = cn[j]; j++) {
if (cj.nodeName == utag || cj.nodeName == tagName || tagName == '*') {
result[++ri] = cj;
}
}
}
} else if (mode == "+") {
utag = tagName.toUpperCase();
for (i = 0; n = ns[i]; i++) {
while ((n = n.nextSibling) && n.nodeType != 1);
if (n && (n.nodeName == utag || n.nodeName == tagName || tagName == '*')) {
result[++ri] = n;
}
}
} else if (mode == "~") {
utag = tagName.toUpperCase();
for (i = 0; n = ns[i]; i++) {
while ((n = n.nextSibling)) {
if (n.nodeName == utag || n.nodeName == tagName || tagName == '*') {
result[++ri] = n;
}
}
}
}
return result;
}
function concat(a, b) {
a.push.apply(a, b);
return a;
}
function byTag(cs, tagName) {
if (cs.tagName || cs === doc) {
cs = [cs];
}
if (!tagName) {
return cs;
}
var result = [], ri = -1,
i, ci;
tagName = tagName.toLowerCase();
for (i = 0; ci = cs[i]; i++) {
if (ci.nodeType == 1 && ci.tagName.toLowerCase() == tagName) {
result[++ri] = ci;
}
}
return result;
}
function byId(cs, id) {
id = unescapeCssSelector(id);
if (cs.tagName || cs === doc) {
cs = [cs];
}
if (!id) {
return cs;
}
var result = [], ri = -1,
i, ci;
for (i = 0; ci = cs[i]; i++) {
if (ci && ci.id == id) {
result[++ri] = ci;
return result;
}
}
return result;
}
function byAttribute(cs, attr, value, op, custom) {
var result = [],
ri = -1,
useGetStyle = custom == "{",
fn = DQ.operators[op],
a,
xml,
hasXml,
i, ci;
value = unescapeCssSelector(value);
for (i = 0; ci = cs[i]; i++) {
if (ci.nodeType === 1) {
if (!hasXml) {
xml = DQ.isXml(ci);
hasXml = true;
}
if (!xml) {
if (useGetStyle) {
a = DQ.getStyle(ci, attr);
} else if (attr == "class" || attr == "className") {
a = ci.className;
} else if (attr == "for") {
a = ci.htmlFor;
} else if (attr == "href") {
a = ci.getAttribute("href", 2);
} else {
a = ci.getAttribute(attr);
}
} else {
a = ci.getAttribute(attr);
}
if ((fn && fn(a, value)) || (!fn && a)) {
result[++ri] = ci;
}
}
}
return result;
}
function byPseudo(cs, name, value) {
value = unescapeCssSelector(value);
return DQ.pseudos[name](cs, value);
}
function nodupIEXml(cs) {
var d = ++key,
r,
i, len, c;
cs[0].setAttribute("_nodup", d);
r = [cs[0]];
for (i = 1, len = cs.length; i < len; i++) {
c = cs[i];
if (!c.getAttribute("_nodup") != d) {
c.setAttribute("_nodup", d);
r[r.length] = c;
}
}
for (i = 0, len = cs.length; i < len; i++) {
cs[i].removeAttribute("_nodup");
}
return r;
}
function nodup(cs) {
if (!cs) {
return [];
}
var len = cs.length, c, i, r = cs, cj, ri = -1, d, j;
if (!len || typeof cs.nodeType != "undefined" || len == 1) {
return cs;
}
if (isIE && typeof cs[0].selectSingleNode != "undefined") {
return nodupIEXml(cs);
}
d = ++key;
cs[0]._nodup = d;
for (i = 1; c = cs[i]; i++) {
if (c._nodup != d) {
c._nodup = d;
} else {
r = [];
for (j = 0; j < i; j++) {
r[++ri] = cs[j];
}
for (j = i + 1; cj = cs[j]; j++) {
if (cj._nodup != d) {
cj._nodup = d;
r[++ri] = cj;
}
}
return r;
}
}
return r;
}
function quickDiffIEXml(c1, c2) {
var d = ++key,
r = [],
i, len;
for (i = 0, len = c1.length; i < len; i++) {
c1[i].setAttribute("_qdiff", d);
}
for (i = 0, len = c2.length; i < len; i++) {
if (c2[i].getAttribute("_qdiff") != d) {
r[r.length] = c2[i];
}
}
for (i = 0, len = c1.length; i < len; i++) {
c1[i].removeAttribute("_qdiff");
}
return r;
}
function quickDiff(c1, c2) {
var len1 = c1.length,
d = ++key,
r = [],
i, len;
if (!len1) {
return c2;
}
if (isIE && typeof c1[0].selectSingleNode != "undefined") {
return quickDiffIEXml(c1, c2);
}
for (i = 0; i < len1; i++) {
c1[i]._qdiff = d;
}
for (i = 0, len = c2.length; i < len; i++) {
if (c2[i]._qdiff != d) {
r[r.length] = c2[i];
}
}
return r;
}
function quickId(ns, mode, root, id) {
if (ns == root) {
id = unescapeCssSelector(id);
var d = root.ownerDocument || root;
return d.getElementById(id);
}
ns = getNodes(ns, mode, "*");
return byId(ns, id);
}
return DQ = {
getStyle: function(el, name) {
return Ext.fly(el, '_DomQuery').getStyle(name);
},
compile: function(path, type) {
type = type || "select";
var fn = ["var f = function(root) {\n var mode; ++batch; var n = root || document;\n"],
lastPath,
matchers = DQ.matchers,
matchersLn = matchers.length,
modeMatch,
lmode = path.match(modeRe),
tokenMatch, matched, j, t, m;
path = setupEscapes(path);
if (lmode && lmode[1]) {
fn[fn.length] = 'mode="' + lmode[1].replace(trimRe, "") + '";';
path = path.replace(lmode[1], "");
}
while (path.substr(0, 1) == "/") {
path = path.substr(1);
}
while (path && lastPath != path) {
lastPath = path;
tokenMatch = path.match(tagTokenRe);
if (type == "select") {
if (tokenMatch) {
if (tokenMatch[1] == "#") {
fn[fn.length] = 'n = quickId(n, mode, root, "' + tokenMatch[2] + '");';
} else {
fn[fn.length] = 'n = getNodes(n, mode, "' + tokenMatch[2] + '");';
}
path = path.replace(tokenMatch[0], "");
} else if (path.substr(0, 1) != '@') {
fn[fn.length] = 'n = getNodes(n, mode, "*");';
}
} else {
if (tokenMatch) {
if (tokenMatch[1] == "#") {
fn[fn.length] = 'n = byId(n, "' + tokenMatch[2] + '");';
} else {
fn[fn.length] = 'n = byTag(n, "' + tokenMatch[2] + '");';
}
path = path.replace(tokenMatch[0], "");
}
}
while (!(modeMatch = path.match(modeRe))) {
matched = false;
for (j = 0; j < matchersLn; j++) {
t = matchers[j];
m = path.match(t.re);
if (m) {
fn[fn.length] = t.select.replace(tplRe, function(x, i) {
return m[i];
});
path = path.replace(m[0], "");
matched = true;
break;
}
}
if (!matched) {
Ext.Error.raise({
sourceClass:'Ext.DomQuery',
sourceMethod:'compile',
msg:'Error parsing selector. Parsing failed at "' + path + '"'
});
}
}
if (modeMatch[1]) {
fn[fn.length] = 'mode="' + modeMatch[1].replace(trimRe, "") + '";';
path = path.replace(modeMatch[1], "");
}
}
fn[fn.length] = "return nodup(n);\n}";
eval(fn.join(""));
return f;
},
jsSelect: function(path, root, type) {
root = root || doc;
if (typeof root == "string") {
root = doc.getElementById(root);
}
var paths = path.split(","),
results = [],
i, len, subPath, result;
for (i = 0, len = paths.length; i < len; i++) {
subPath = paths[i].replace(trimRe, "");
if (!cache[subPath]) {
cache[subPath] = DQ.compile(subPath, type);
if (!cache[subPath]) {
Ext.Error.raise({
sourceClass:'Ext.DomQuery',
sourceMethod:'jsSelect',
msg:subPath + ' is not a valid selector'
});
}
} else {
setupEscapes(subPath);
}
result = cache[subPath](root);
if (result && result !== doc) {
results = results.concat(result);
}
}
if (paths.length > 1) {
return nodup(results);
}
return results;
},
isXml: function(el) {
var docEl = (el ? el.ownerDocument || el : 0).documentElement;
return docEl ? docEl.nodeName !== "HTML" : false;
},
select : doc.querySelectorAll ? function(path, root, type, single) {
root = root || doc;
if (!DQ.isXml(root)) {
try {
if (root.parentNode && (root.nodeType !== 9) && path.indexOf(',') === -1 && !startIdRe.test(path)) {
path = '#' + Ext.escapeId(Ext.id(root)) + ' ' + path;
root = root.parentNode;
}
return single ? [ root.querySelector(path) ]
: Ext.Array.toArray(root.querySelectorAll(path));
}
catch (e) {
}
}
return DQ.jsSelect.call(this, path, root, type);
} : function(path, root, type) {
return DQ.jsSelect.call(this, path, root, type);
},
selectNode : function(path, root){
return Ext.DomQuery.select(path, root, null, true)[0];
},
selectValue: function(path, root, defaultValue) {
path = path.replace(trimRe, "");
if (!valueCache[path]) {
valueCache[path] = DQ.compile(path, "select");
} else {
setupEscapes(path);
}
var n = valueCache[path](root),
v;
n = n[0] ? n[0] : n;
if (typeof n.normalize == 'function') {
n.normalize();
}
v = (n && n.firstChild ? n.firstChild.nodeValue : null);
return ((v === null || v === undefined || v === '') ? defaultValue : v);
},
selectNumber: function(path, root, defaultValue) {
var v = DQ.selectValue(path, root, defaultValue || 0);
return parseFloat(v);
},
is: function(el, ss) {
if (typeof el == "string") {
el = doc.getElementById(el);
}
var isArray = Ext.isArray(el),
result = DQ.filter(isArray ? el : [el], ss);
return isArray ? (result.length == el.length) : (result.length > 0);
},
filter: function(els, ss, nonMatches) {
ss = ss.replace(trimRe, "");
if (!simpleCache[ss]) {
simpleCache[ss] = DQ.compile(ss, "simple");
} else {
setupEscapes(ss);
}
var result = simpleCache[ss](els);
return nonMatches ? quickDiff(result, els) : result;
},
matchers: [{
re: /^\.([\w\-\\]+)/,
select: useClassList ? 'n = byClassName(n, "{1}");' : 'n = byClassName(n, " {1} ");'
}, {
re: /^\:([\w\-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/,
select: 'n = byPseudo(n, "{1}", "{2}");'
},  {
re: /^(?:([\[\{])(?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/,
select: 'n = byAttribute(n, "{2}", "{4}", "{3}", "{1}");'
}, {
re: /^#([\w\-\\]+)/,
select: 'n = byId(n, "{1}");'
}, {
re: /^@([\w\-\.]+)/,
select: 'return {firstChild:{nodeValue:attrValue(n, "{1}")}};'
}],
operators: {
"=": function(a, v) {
return a == v;
},
"!=": function(a, v) {
return a != v;
},
"^=": function(a, v) {
return a && a.substr(0, v.length) == v;
},
"$=": function(a, v) {
return a && a.substr(a.length - v.length) == v;
},
"*=": function(a, v) {
return a && a.indexOf(v) !== -1;
},
"%=": function(a, v) {
return (a % v) === 0;
},
"|=": function(a, v) {
return a && (a == v || a.substr(0, v.length + 1) == v + '-');
},
"~=": function(a, v) {
return a && (' ' + a + ' ').indexOf(' ' + v + ' ') != -1;
}
},
pseudos: {
"first-child": function(c) {
var r = [], ri = -1, n,
i, ci;
for (i = 0; (ci = n = c[i]); i++) {
while ((n = n.previousSibling) && n.nodeType != 1);
if (!n) {
r[++ri] = ci;
}
}
return r;
},
"last-child": function(c) {
var r = [], ri = -1, n,
i, ci;
for (i = 0; (ci = n = c[i]); i++) {
while ((n = n.nextSibling) && n.nodeType != 1);
if (!n) {
r[++ri] = ci;
}
}
return r;
},
"nth-child": function(c, a) {
var r = [], ri = -1,
m = nthRe.exec(a == "even" && "2n" || a == "odd" && "2n+1" || !nthRe2.test(a) && "n+" + a || a),
f = (m[1] || 1) - 0, l = m[2] - 0,
i, n, j, cn, pn;
for (i = 0; n = c[i]; i++) {
pn = n.parentNode;
if (batch != pn._batch) {
j = 0;
for (cn = pn.firstChild; cn; cn = cn.nextSibling) {
if (cn.nodeType == 1) {
cn.nodeIndex = ++j;
}
}
pn._batch = batch;
}
if (f == 1) {
if (l === 0 || n.nodeIndex == l) {
r[++ri] = n;
}
} else if ((n.nodeIndex + l) % f === 0) {
r[++ri] = n;
}
}
return r;
},
"only-child": function(c) {
var r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if (!prev(ci) && !next(ci)) {
r[++ri] = ci;
}
}
return r;
},
"empty": function(c) {
var r = [], ri = -1,
i, ci, cns, j, cn, empty;
for (i = 0; ci = c[i]; i++) {
cns = ci.childNodes;
j = 0;
empty = true;
while (cn = cns[j]) {
++j;
if (cn.nodeType == 1 || cn.nodeType == 3) {
empty = false;
break;
}
}
if (empty) {
r[++ri] = ci;
}
}
return r;
},
"contains": function(c, v) {
var r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if ((ci.textContent || ci.innerText || ci.text || '').indexOf(v) != -1) {
r[++ri] = ci;
}
}
return r;
},
"nodeValue": function(c, v) {
var r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if (ci.firstChild && ci.firstChild.nodeValue == v) {
r[++ri] = ci;
}
}
return r;
},
"checked": function(c) {
var r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if (ci.checked === true) {
r[++ri] = ci;
}
}
return r;
},
"not": function(c, ss) {
return DQ.filter(c, ss, true);
},
"any": function(c, selectors) {
var ss = selectors.split('|'),
r = [], ri = -1, s,
i, ci, j;
for (i = 0; ci = c[i]; i++) {
for (j = 0; s = ss[j]; j++) {
if (DQ.is(ci, s)) {
r[++ri] = ci;
break;
}
}
}
return r;
},
"odd": function(c) {
return this["nth-child"](c, "odd");
},
"even": function(c) {
return this["nth-child"](c, "even");
},
"nth": function(c, a) {
return c[a - 1] || [];
},
"first": function(c) {
return c[0] || [];
},
"last": function(c) {
return c[c.length - 1] || [];
},
"has": function(c, ss) {
var s = DQ.select,
r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if (s(ss, ci).length > 0) {
r[++ri] = ci;
}
}
return r;
},
"next": function(c, ss) {
var is = DQ.is,
r = [], ri = -1,
i, ci, n;
for (i = 0; ci = c[i]; i++) {
n = next(ci);
if (n && is(n, ss)) {
r[++ri] = ci;
}
}
return r;
},
"prev": function(c, ss) {
var is = DQ.is,
r = [], ri = -1,
i, ci, n;
for (i = 0; ci = c[i]; i++) {
n = prev(ci);
if (n && is(n, ss)) {
r[++ri] = ci;
}
}
return r;
},
focusable: function(candidates) {
var len = candidates.length,
results = [],
i = 0,
c;
for (; i < len; i++) {
c = candidates[i];
if (Ext.fly(c, '_DomQuery').isFocusable()) {
results.push(c);
}
}
return results;
},
visible: function(candidates, deep) {
var len = candidates.length,
results = [],
i = 0,
c;
for (; i < len; i++) {
c = candidates[i];
if (Ext.fly(c, '_DomQuery').isVisible(deep)) {
results.push(c);
}
}
return results;
}
}
};
}());
Ext.query = Ext.DomQuery.select;
Ext.define('Ext.dom.Element_anim', {
override: 'Ext.dom.Element',
animate: function(config) {
var me = this,
animId = me.dom.id || Ext.id(me.dom),
listeners,
anim,
end;
if (!Ext.fx.Manager.hasFxBlock(animId)) {
if (config.listeners) {
listeners = config.listeners;
delete config.listeners;
}
if (config.internalListeners) {
config.listeners = config.internalListeners;
delete config.internalListeners;
}
end = config.autoEnd;
delete config.autoEnd;
anim = new Ext.fx.Anim(me.anim(config));
if (listeners) {
anim.on(listeners);
}
Ext.fx.Manager.queueFx(anim);
if (end) {
anim.jumpToEnd();
}
}
return me;
},
anim: function(config) {
if (!Ext.isObject(config)) {
return (config) ? {} : false;
}
var me = this,
duration = config.duration || Ext.fx.Anim.prototype.duration,
easing = config.easing || 'ease',
animConfig;
if (config.stopAnimation) {
me.stopAnimation();
}
Ext.applyIf(config, Ext.fx.Manager.getFxDefaults(me.id));
Ext.fx.Manager.setFxDefaults(me.id, {
delay: 0
});
animConfig = {
target: me.dom,
remove: config.remove,
alternate: config.alternate || false,
duration: duration,
easing: easing,
callback: config.callback,
listeners: config.listeners,
iterations: config.iterations || 1,
scope: config.scope,
block: config.block,
concurrent: config.concurrent,
delay: config.delay || 0,
paused: true,
keyframes: config.keyframes,
from: config.from || {},
to: Ext.apply({}, config)
};
Ext.apply(animConfig.to, config.to);
delete animConfig.to.to;
delete animConfig.to.from;
delete animConfig.to.remove;
delete animConfig.to.alternate;
delete animConfig.to.keyframes;
delete animConfig.to.iterations;
delete animConfig.to.listeners;
delete animConfig.to.target;
delete animConfig.to.paused;
delete animConfig.to.callback;
delete animConfig.to.scope;
delete animConfig.to.duration;
delete animConfig.to.easing;
delete animConfig.to.concurrent;
delete animConfig.to.block;
delete animConfig.to.stopAnimation;
delete animConfig.to.delay;
return animConfig;
},
slideIn: function(anchor, obj, slideOut) {
var me = this,
dom = me.dom,
elStyle = dom.style,
beforeAnim,
wrapAnim,
restoreScroll,
wrapDomParentNode;
anchor = anchor || "t";
obj = obj || {};
beforeAnim = function() {
var animScope = this,
listeners = obj.listeners,
el = Ext.fly(dom, '_anim'),
box, originalStyles, anim, wrap;
if (!slideOut) {
el.fixDisplay();
}
box = el.getBox();
if ((anchor == 't' || anchor == 'b') && box.height === 0) {
box.height = dom.scrollHeight;
}
else if ((anchor == 'l' || anchor == 'r') && box.width === 0) {
box.width = dom.scrollWidth;
}
originalStyles = el.getStyles('width', 'height', 'left', 'right', 'top', 'bottom', 'position', 'z-index', true);
el.setSize(box.width, box.height);
if (obj.preserveScroll) {
restoreScroll = el.cacheScrollValues();
}
wrap = el.wrap({
role: 'presentation',
id: Ext.id() + '-anim-wrap-for-' + el.dom.id,
style: {
visibility: slideOut ? 'visible' : 'hidden'
}
});
wrapDomParentNode = wrap.dom.parentNode;
wrap.setPositioning(el.getPositioning(true));
if (wrap.isStyle('position', 'static')) {
wrap.position('relative');
}
el.clearPositioning('auto');
wrap.clip();
if (restoreScroll) {
restoreScroll();
}
el.setStyle({
visibility: '',
position: 'absolute'
});
if (slideOut) {
wrap.setSize(box.width, box.height);
}
switch (anchor) {
case 't':
anim = {
from: {
width: box.width + 'px',
height: '0px'
},
to: {
width: box.width + 'px',
height: box.height + 'px'
}
};
elStyle.bottom = '0px';
break;
case 'l':
anim = {
from: {
width: '0px',
height: box.height + 'px'
},
to: {
width: box.width + 'px',
height: box.height + 'px'
}
};
me.anchorAnimX(anchor);
break;
case 'r':
anim = {
from: {
x: box.x + box.width,
width: '0px',
height: box.height + 'px'
},
to: {
x: box.x,
width: box.width + 'px',
height: box.height + 'px'
}
};
me.anchorAnimX(anchor);
break;
case 'b':
anim = {
from: {
y: box.y + box.height,
width: box.width + 'px',
height: '0px'
},
to: {
y: box.y,
width: box.width + 'px',
height: box.height + 'px'
}
};
break;
case 'tl':
anim = {
from: {
x: box.x,
y: box.y,
width: '0px',
height: '0px'
},
to: {
width: box.width + 'px',
height: box.height + 'px'
}
};
elStyle.bottom = '0px';
me.anchorAnimX('l');
break;
case 'bl':
anim = {
from: {
y: box.y + box.height,
width: '0px',
height: '0px'
},
to: {
y: box.y,
width: box.width + 'px',
height: box.height + 'px'
}
};
me.anchorAnimX('l');
break;
case 'br':
anim = {
from: {
x: box.x + box.width,
y: box.y + box.height,
width: '0px',
height: '0px'
},
to: {
x: box.x,
y: box.y,
width: box.width + 'px',
height: box.height + 'px'
}
};
me.anchorAnimX('r');
break;
case 'tr':
anim = {
from: {
x: box.x + box.width,
width: '0px',
height: '0px'
},
to: {
x: box.x,
width: box.width + 'px',
height: box.height + 'px'
}
};
elStyle.bottom = '0px';
me.anchorAnimX('r');
break;
}
wrap.show();
wrapAnim = Ext.apply({}, obj);
delete wrapAnim.listeners;
wrapAnim = new Ext.fx.Anim(Ext.applyIf(wrapAnim, {
target: wrap,
duration: 500,
easing: 'ease-out',
from: slideOut ? anim.to : anim.from,
to: slideOut ? anim.from : anim.to
}));
wrapAnim.on('afteranimate', function() {
var el = Ext.fly(dom, '_anim');
el.setStyle(originalStyles);
if (slideOut) {
if (obj.useDisplay) {
el.setDisplayed(false);
} else {
el.hide();
}
}
if (wrap.dom) {
if (wrap.dom.parentNode) {
wrap.dom.parentNode.insertBefore(el.dom, wrap.dom);
} else {
wrapDomParentNode.appendChild(el.dom);
}
wrap.remove();
}
if (restoreScroll) {
restoreScroll();
}
animScope.end();
});
if (listeners) {
wrapAnim.on(listeners);
}
};
me.animate({
duration: obj.duration ? Math.max(obj.duration, 500) * 2 : 1000,
listeners: {
beforeanimate: beforeAnim 
}
});
return me;
},
slideOut: function(anchor, o) {
return this.slideIn(anchor, o, true);
},
puff: function(obj) {
var me = this,
dom = me.dom,
beforeAnim,
box = me.getBox(),
originalStyles = me.getStyles('width', 'height', 'left', 'right', 'top', 'bottom', 'position', 'z-index', 'font-size', 'opacity', true);
obj = Ext.applyIf(obj || {}, {
easing: 'ease-out',
duration: 500,
useDisplay: false
});
beforeAnim = function() {
var el = Ext.fly(dom, '_anim');
el.clearOpacity();
el.show();
this.to = {
width: box.width * 2,
height: box.height * 2,
x: box.x - (box.width / 2),
y: box.y - (box.height /2),
opacity: 0,
fontSize: '200%'
};
this.on('afteranimate',function() {
var el = Ext.fly(dom, '_anim');
if (el) {
if (obj.useDisplay) {
el.setDisplayed(false);
} else {
el.hide();
}
el.setStyle(originalStyles);
Ext.callback(obj.callback, obj.scope);
}
});
};
me.animate({
duration: obj.duration,
easing: obj.easing,
listeners: {
beforeanimate: {
fn: beforeAnim
}
}
});
return me;
},
switchOff: function(obj) {
var me = this,
dom = me.dom,
beforeAnim;
obj = Ext.applyIf(obj || {}, {
easing: 'ease-in',
duration: 500,
remove: false,
useDisplay: false
});
beforeAnim = function() {
var el = Ext.fly(dom, '_anim'),
animScope = this,
size = el.getSize(),
xy = el.getXY(),
keyframe, position;
el.clearOpacity();
el.clip();
position = el.getPositioning();
keyframe = new Ext.fx.Animator({
target: dom,
duration: obj.duration,
easing: obj.easing,
keyframes: {
33: {
opacity: 0.3
},
66: {
height: 1,
y: xy[1] + size.height / 2
},
100: {
width: 1,
x: xy[0] + size.width / 2
}
}
});
keyframe.on('afteranimate', function() {
var el = Ext.fly(dom, '_anim');
if (obj.useDisplay) {
el.setDisplayed(false);
} else {
el.hide();
}
el.clearOpacity();
el.setPositioning(position);
el.setSize(size);
animScope.end();
});
};
me.animate({
duration: (Math.max(obj.duration, 500) * 2),
listeners: {
beforeanimate: {
fn: beforeAnim
}
},
callback: obj.callback,
scope: obj.scope
});
return me;
},
frame : function(color, count, obj){
var me = this,
dom = me.dom,
beforeAnim;
color = color || '#C3DAF9';
count = count || 1;
obj = obj || {};
beforeAnim = function() {
var el = Ext.fly(dom, '_anim'),
animScope = this,
box,
proxy, proxyAnim;
el.show();
box = el.getBox();
proxy = Ext.getBody().createChild({
role: 'presentation',
id: el.dom.id + '-anim-proxy',
style: {
position : 'absolute',
'pointer-events': 'none',
'z-index': 35000,
border : '0px solid ' + color
}
});
proxyAnim = new Ext.fx.Anim({
target: proxy,
duration: obj.duration || 1000,
iterations: count,
from: {
top: box.y,
left: box.x,
borderWidth: 0,
opacity: 1,
height: box.height,
width: box.width
},
to: {
top: box.y - 20,
left: box.x - 20,
borderWidth: 10,
opacity: 0,
height: box.height + 40,
width: box.width + 40
}
});
proxyAnim.on('afteranimate', function() {
proxy.remove();
animScope.end();
});
};
me.animate({
duration: (Math.max(obj.duration, 500) * 2) || 2000,
listeners: {
beforeanimate: {
fn: beforeAnim
}
},
callback: obj.callback,
scope: obj.scope
});
return me;
},
ghost: function(anchor, obj) {
var me = this,
dom = me.dom,
beforeAnim;
anchor = anchor || "b";
beforeAnim = function() {
var el = Ext.fly(dom, '_anim'),
width = el.getWidth(),
height = el.getHeight(),
xy = el.getXY(),
position = el.getPositioning(),
to = {
opacity: 0
};
switch (anchor) {
case 't':
to.y = xy[1] - height;
break;
case 'l':
to.x = xy[0] - width;
break;
case 'r':
to.x = xy[0] + width;
break;
case 'b':
to.y = xy[1] + height;
break;
case 'tl':
to.x = xy[0] - width;
to.y = xy[1] - height;
break;
case 'bl':
to.x = xy[0] - width;
to.y = xy[1] + height;
break;
case 'br':
to.x = xy[0] + width;
to.y = xy[1] + height;
break;
case 'tr':
to.x = xy[0] + width;
to.y = xy[1] - height;
break;
}
this.to = to;
this.on('afteranimate', function () {
var el = Ext.fly(dom, '_anim');
if (el) {
el.hide();
el.clearOpacity();
el.setPositioning(position);
}
});
};
me.animate(Ext.applyIf(obj || {}, {
duration: 500,
easing: 'ease-out',
listeners: {
beforeanimate: beforeAnim
}
}));
return me;
},
highlight: function(color, o) {
var me = this,
dom = me.dom,
from = {},
restore, to, attr, lns, event, fn;
if (dom.tagName.match(me.tableTagRe)) {
return me.select('div').highlight(color, o);
}
o = o || {};
lns = o.listeners || {};
attr = o.attr || 'backgroundColor';
from[attr] = color || 'ffff9c';
if (!o.to) {
to = {};
to[attr] = o.endColor || me.getColor(attr, 'ffffff', '');
}
else {
to = o.to;
}
o.listeners = Ext.apply(Ext.apply({}, lns), {
beforeanimate: function() {
restore = dom.style[attr];
var el = Ext.fly(dom, '_anim');
el.clearOpacity();
el.show();
event = lns.beforeanimate;
if (event) {
fn = event.fn || event;
return fn.apply(event.scope || lns.scope || window, arguments);
}
},
afteranimate: function() {
if (dom) {
dom.style[attr] = restore;
}
event = lns.afteranimate;
if (event) {
fn = event.fn || event;
fn.apply(event.scope || lns.scope || window, arguments);
}
}
});
me.animate(Ext.apply({}, o, {
duration: 1000,
easing: 'ease-in',
from: from,
to: to
}));
return me;
},
pause: function(ms) {
var me = this;
Ext.fx.Manager.setFxDefaults(me.id, {
delay: ms
});
return me;
},
fadeIn: function(o) {
var me = this,
dom = me.dom;
me.animate(Ext.apply({}, o, {
opacity: 1,
internalListeners: {
beforeanimate: function(anim){
var el = Ext.fly(dom, '_anim');
if (el.isStyle('display', 'none')) {
el.setDisplayed('');
} else {
el.show();
} 
}
}
}));
return this;
},
fadeOut: function(o) {
var me = this,
dom = me.dom;
o = Ext.apply({
opacity: 0,
internalListeners: {
afteranimate: function(anim){
if (dom && anim.to.opacity === 0) {
var el = Ext.fly(dom, '_anim');
if (o.useDisplay) {
el.setDisplayed(false);
} else {
el.hide();
}
}         
}
}
}, o);
me.animate(o);
return me;
},
scale: function(w, h, o) {
this.animate(Ext.apply({}, o, {
width: w,
height: h
}));
return this;
},
shift: function(config) {
this.animate(config);
return this;
},
anchorAnimX: function(anchor) {
var xName = (anchor === 'l') ? 'right' : 'left';
this.dom.style[xName] = '0px';
}
});
Ext.define('Ext.dom.Element_dd', {
override: 'Ext.dom.Element',
initDD : function(group, config, overrides){
var dd = new Ext.dd.DD(Ext.id(this.dom), group, config);
return Ext.apply(dd, overrides);
},
initDDProxy : function(group, config, overrides){
var dd = new Ext.dd.DDProxy(Ext.id(this.dom), group, config);
return Ext.apply(dd, overrides);
},
initDDTarget : function(group, config, overrides){
var dd = new Ext.dd.DDTarget(Ext.id(this.dom), group, config);
return Ext.apply(dd, overrides);
}
});
Ext.define('Ext.dom.Element_fx', {
override: 'Ext.dom.Element'
},
function() {
var Element         = Ext.dom.Element,
VISIBILITY      = "visibility",
DISPLAY         = "display",
NONE            = "none",
HIDDEN          = 'hidden',
VISIBLE         = 'visible',
OFFSETS         = "offsets",
ASCLASS         = "asclass",
NOSIZE          = 'nosize',
ORIGINALDISPLAY = 'originalDisplay',
VISMODE         = 'visibilityMode',
ISVISIBLE       = 'isVisible',
OFFSETCLASS     = Ext.baseCSSPrefix + 'hide-offsets',
getDisplay = function(el) {
var data = (el.$cache || el.getCache()).data,
display = data[ORIGINALDISPLAY];
if (display === undefined) {
data[ORIGINALDISPLAY] = display = '';
}
return display;
},
getVisMode = function(el){
var data = (el.$cache || el.getCache()).data,
visMode = data[VISMODE];
if (visMode === undefined) {
data[VISMODE] = visMode = Element.VISIBILITY;
}
return visMode;
};
Element.override({
originalDisplay : "",
visibilityMode : 1,
setVisible : function(visible, animate) {
var me = this,
dom = me.dom,
visMode = getVisMode(me);
if (typeof animate == 'string') {
switch (animate) {
case DISPLAY:
visMode = Element.DISPLAY;
break;
case VISIBILITY:
visMode = Element.VISIBILITY;
break;
case OFFSETS:
visMode = Element.OFFSETS;
break;
case NOSIZE:
case ASCLASS:
visMode = Element.ASCLASS;
break;
}
me.setVisibilityMode(visMode);
animate = false;
}
if (!animate || !me.anim) {
if (visMode == Element.DISPLAY) {
return me.setDisplayed(visible);
} else if (visMode == Element.OFFSETS) {
me[visible?'removeCls':'addCls'](OFFSETCLASS);
} else if (visMode == Element.VISIBILITY) {
me.fixDisplay();
dom.style.visibility = visible ? '' : HIDDEN;
} else if (visMode == Element.ASCLASS) {
me[visible?'removeCls':'addCls'](me.visibilityCls || Element.visibilityCls);
}
} else {
if (visible) {
me.setOpacity(0.01);
me.setVisible(true);
}
if (!Ext.isObject(animate)) {
animate = {
duration: 350,
easing: 'ease-in'
};
}
me.animate(Ext.applyIf({
callback: function() {
if (!visible) {
Ext.fly(dom, '_internal').setVisible(false).setOpacity(1);
}
},
to: {
opacity: (visible) ? 1 : 0
}
}, animate));
}
(me.$cache || me.getCache()).data[ISVISIBLE] = visible;
return me;
},
hasMetrics  : function(){
var visMode = getVisMode(this);
return this.isVisible() || (visMode == Element.OFFSETS) || (visMode == Element.VISIBILITY);
},
toggle : function(animate){
var me = this;
me.setVisible(!me.isVisible(), me.anim(animate));
return me;
},
setDisplayed : function(value) {
if(typeof value == "boolean"){
value = value ? getDisplay(this) : NONE;
}
this.setStyle(DISPLAY, value);
return this;
},
fixDisplay : function(){
var me = this;
if (me.isStyle(DISPLAY, NONE)) {
me.setStyle(VISIBILITY, HIDDEN);
me.setStyle(DISPLAY, getDisplay(me)); 
if (me.isStyle(DISPLAY, NONE)) { 
me.setStyle(DISPLAY, "block");
}
}
},
hide : function(animate){
if (typeof animate == 'string'){
this.setVisible(false, animate);
return this;
}
this.setVisible(false, this.anim(animate));
return this;
},
show : function(animate){
if (typeof animate == 'string'){
this.setVisible(true, animate);
return this;
}
this.setVisible(true, this.anim(animate));
return this;
}
});
});
Ext.define('Ext.dom.Element_position', {
override: 'Ext.dom.Element'
},
function() {
var flyInstance,
Element = this,
LEFT = "left",
RIGHT = "right",
TOP = "top",
BOTTOM = "bottom",
POSITION = "position",
STATIC = "static",
RELATIVE = "relative",
ZINDEX = "z-index",
BODY = 'BODY',
PADDING = 'padding',
BORDER = 'border',
SLEFT = '-left',
SRIGHT = '-right',
STOP = '-top',
SBOTTOM = '-bottom',
SWIDTH = '-width',
borders = {l: BORDER + SLEFT + SWIDTH, r: BORDER + SRIGHT + SWIDTH, t: BORDER + STOP + SWIDTH, b: BORDER + SBOTTOM + SWIDTH},
paddings = {l: PADDING + SLEFT, r: PADDING + SRIGHT, t: PADDING + STOP, b: PADDING + SBOTTOM},
paddingsTLRB = [paddings.l, paddings.r, paddings.t, paddings.b],
bordersTLRB = [borders.l,  borders.r,  borders.t,  borders.b],
round = Math.round,
doc = document,
fly = function (el) {
if (!flyInstance) {
flyInstance = new Ext.Element.Fly();
}
flyInstance.attach(el);
return flyInstance;
};
Element.override({
pxRe: /^\d+(?:\.\d*)?px$/i,
inheritableStatics: {
getX: function(el) {
return Element.getXY(el)[0];
},
getXY: function(el) {
var bd = doc.body,
docEl = doc.documentElement,
leftBorder = 0,
topBorder = 0,
ret = [0,0],
box,
scroll;
el = Ext.getDom(el);
if(el != doc && el != bd){
if (Ext.isIE) {
try {
box = el.getBoundingClientRect();
topBorder = docEl.clientTop || bd.clientTop;
leftBorder = docEl.clientLeft || bd.clientLeft;
} catch (ex) {
box = { left: 0, top: 0 };
}
} else {
box = el.getBoundingClientRect();
}
scroll = fly(doc).getScroll();
ret = [
round(box.left + scroll.left - leftBorder),
round(box.top + scroll.top - topBorder)
];
}
return ret;
},
getY: function(el) {
return Element.getXY(el)[1];
},
setX: function(el, x) {
Element.setXY(el, [x, false]);
},
setXY: function(el, xy) {
(el = Ext.fly(el, '_setXY')).position();
var pts = el.translatePoints(xy),
style = el.dom.style,
pos;
style.right = 'auto';
for (pos in pts) {
if (!isNaN(pts[pos])) {
style[pos] = pts[pos] + "px";
}
}
},
setY: function(el, y) {
Element.setXY(el, [false, y]);
}
},
center: function(centerIn){
return this.alignTo(centerIn || doc, 'c-c');
},
clearPositioning: function(value) {
value = value || '';
return this.setStyle({
left : value,
right : value,
top : value,
bottom : value,
'z-index' : '',
position : STATIC
});
},
getAnchorToXY: function(el, anchor, local, mySize) {
return el.getAnchorXY(anchor, local, mySize);
},
getBottom: function(local) {
return (local ? this.getLocalY() : this.getY()) + this.getHeight();
},
getBorderPadding: function() {
var paddingWidth = this.getStyle(paddingsTLRB),
bordersWidth = this.getStyle(bordersTLRB);
return {
beforeX: (parseFloat(bordersWidth[borders.l]) || 0) + (parseFloat(paddingWidth[paddings.l]) || 0),
afterX: (parseFloat(bordersWidth[borders.r]) || 0) + (parseFloat(paddingWidth[paddings.r]) || 0),
beforeY: (parseFloat(bordersWidth[borders.t]) || 0) + (parseFloat(paddingWidth[paddings.t]) || 0),
afterY: (parseFloat(bordersWidth[borders.b]) || 0) + (parseFloat(paddingWidth[paddings.b]) || 0)
};
},
getCenterXY: function(){
return this.getAlignToXY(doc, 'c-c');
},
getLeft: function(local) {
return local ? this.getLocalX() : this.getX();
},
getLocalX: function() {
var me = this,
offsetParent = me.dom.offsetParent,
x = me.getStyle('left');
if (!x || x === 'auto') {
x = 0;
} else if (me.pxRe.test(x)) {
x = parseFloat(x);
} else {
x = me.getX();
if (offsetParent) {
x -= Element.getX(offsetParent);
}
}
return x;
},
getLocalXY: function() {
var me = this,
offsetParent = me.dom.offsetParent,
style = me.getStyle(['left', 'top']),
x = style.left,
y = style.top;
if (!x || x === 'auto') {
x = 0;
} else if (me.pxRe.test(x)) {
x = parseFloat(x);
} else {
x = me.getX();
if (offsetParent) {
x -= Element.getX(offsetParent);
}
}
if (!y || y === 'auto') {
y = 0;
} else if (me.pxRe.test(y)) {
y = parseFloat(y);
} else {
y = me.getY();
if (offsetParent) {
y -= Element.getY(offsetParent);
}
}
return [x, y];
},
getLocalY: function() {
var me = this,
offsetParent = me.dom.offsetParent,
y = me.getStyle('top');
if (!y || y === 'auto') {
y = 0;
} else if (me.pxRe.test(y)) {
y = parseFloat(y);
} else {
y = me.getY();
if (offsetParent) {
y -= Element.getY(offsetParent);
}
}
return y;
},
getPageBox: function(getRegion) {
var me = this,
dom = me.dom,
isDoc = dom.nodeName == BODY,
w = isDoc ? Ext.Element.getViewWidth() : dom.offsetWidth,
h = isDoc ? Ext.Element.getViewHeight() : dom.offsetHeight,
xy = me.getXY(),
t = xy[1],
r = xy[0] + w,
b = xy[1] + h,
l = xy[0];
if (getRegion) {
return new Ext.util.Region(t, r, b, l);
}
else {
return {
left: l,
top: t,
width: w,
height: h,
right: r,
bottom: b
};
}
},
getPositioning: function(autoPx){
var styles = this.getStyle(['left', 'top', 'position', 'z-index']),
dom = this.dom;
if(autoPx) {
if(styles.left === 'auto') {
styles.left = dom.offsetLeft + 'px';
}
if(styles.top === 'auto') {
styles.top = dom.offsetTop + 'px';
}
}
return styles;
},
getRight: function(local) {
return (local ? this.getLocalX() : this.getX()) + this.getWidth();
},
getTop: function(local) {
return local ? this.getLocalY() : this.getY();
},
getX: function() {
return Element.getX(this.dom);
},
getXY: function() {
return Element.getXY(this.dom);
},
getY: function() {
return Element.getY(this.dom);
},
moveTo: function(x, y, animate) {
return this.setXY([x, y], animate);
},
position: function(pos, zIndex, x, y) {
var me = this;
if (!pos && me.isStyle(POSITION, STATIC)) {
me.setStyle(POSITION, RELATIVE);
} else if (pos) {
me.setStyle(POSITION, pos);
}
if (zIndex) {
me.setStyle(ZINDEX, zIndex);
}
if (x || y) {
me.setXY([x || false, y || false]);
}
},
setBottom: function(bottom) {
this.dom.style[BOTTOM] = this.addUnits(bottom);
return this;
},
setBounds: function(x, y, width, height, animate) {
return this.setBox({
x: x,
y: y,
width: width,
height: height
}, animate);
},
setLeft: function(left) {
this.dom.style[LEFT] = this.addUnits(left); 
return this;
},
setLeftTop: function(left, top) {
var me = this,
style = me.dom.style;
style.left = me.addUnits(left);
style.top = me.addUnits(top);
return me;
},
setLocalX: function(x) {
var style = this.dom.style;
style.right = 'auto';
style.left = (x === null) ? 'auto' : x + 'px';
},
setLocalXY: function(x, y) {
var style = this.dom.style;
style.right = 'auto';
if (x && x.length) {
y = x[1];
x = x[0];
}
if (x === null) {
style.left = 'auto';
} else if (x !== undefined) {
style.left = x + 'px';
}
if (y === null) {
style.top = 'auto';
} else if (y !== undefined) {
style.top = y + 'px';
}
},
setLocalY: function(y) {
this.dom.style.top = (y === null) ? 'auto' : y + 'px';
},
setLocation: function(x, y, animate) {
return this.setXY([x, y], animate);
},
setPositioning: function(pc) {
return this.setStyle(pc);
},
setRight: function(right) {
this.dom.style[RIGHT] = this.addUnits(right);
return this;
},
setTop: function(top) {
this.dom.style[TOP] = this.addUnits(top);
return this;
},
setX: function(x, animate) {
return this.setXY([x, this.getY()], animate);
},
setXY: function(xy, animate) {
var me = this;
if (!animate || !me.anim) {
Element.setXY(me.dom, xy);
} else {
if (!Ext.isObject(animate)) {
animate = {};
}
me.animate(Ext.applyIf({ to: { x: xy[0], y: xy[1] } }, animate));
}
return this;
},
setY: function(y, animate) {
return this.setXY([this.getX(), y], animate);
}
});
Element.getTrueXY = Element.getXY;
});
Ext.define('Ext.dom.Element_scroll', {
override: 'Ext.dom.Element',
isScrollable: function() {
var dom = this.dom;
return dom.scrollHeight > dom.clientHeight || dom.scrollWidth > dom.clientWidth;
},
getScroll: function() {
var me = this,
dom = me.dom,
doc = document,
body = doc.body,
docElement = doc.documentElement,
left, top;
if (dom === doc || dom === body) {
left = docElement.scrollLeft || (body ? body.scrollLeft : 0);
top = docElement.scrollTop || (body ? body.scrollTop : 0);
} else {
left = dom.scrollLeft;
top = dom.scrollTop;
}
return {
left: left,
top: top
};
},
getScrollLeft: function() {
var dom = this.dom,
doc = document;
if (dom === doc || dom === doc.body) {
return this.getScroll().left;
} else {
return dom.scrollLeft;
}
},
getScrollTop: function(){
var dom = this.dom,
doc = document;
if (dom === doc || dom === doc.body) {
return this.getScroll().top;
} else {
return dom.scrollTop;
}
},
setScrollLeft: function(left){
this.dom.scrollLeft = left;
return this;
},
setScrollTop: function(top) {
this.dom.scrollTop = top;
return this;
},
scrollBy: function(deltaX, deltaY, animate) {
var me = this,
dom = me.dom;
if (deltaX.length) {
animate = deltaY;
deltaY = deltaX[1];
deltaX = deltaX[0];
} else if (typeof deltaX != 'number') { 
animate = deltaY;
deltaY = deltaX.y;
deltaX = deltaX.x;
}
if (deltaX) {
me.scrollTo('left', me.constrainScrollLeft(dom.scrollLeft + deltaX), animate);
}
if (deltaY) {
me.scrollTo('top', me.constrainScrollTop(dom.scrollTop + deltaY), animate);
}
return me;
},
scrollTo: function(side, value, animate) {
var top = /top/i.test(side),
me = this,
prop = top ? 'scrollTop' : 'scrollLeft',
dom = me.dom,
animCfg;
if (!animate || !me.anim) {
dom[prop] = value;
dom[prop] = value;
}
else {
animCfg = {
to: {}
};
animCfg.to[prop] = value;
if (Ext.isObject(animate)) {
Ext.applyIf(animCfg, animate);
}
me.animate(animCfg);
}
return me;
},
scrollIntoView: function(container, hscroll, animate, highlight) {
var me = this,
dom = me.dom,
offsets = me.getOffsetsTo(container = Ext.getDom(container) || Ext.getBody().dom),
left = offsets[0] + container.scrollLeft,
top = offsets[1] + container.scrollTop,
bottom = top + dom.offsetHeight,
right = left + dom.offsetWidth,
ctClientHeight = container.clientHeight,
ctScrollTop = parseInt(container.scrollTop, 10),
ctScrollLeft = parseInt(container.scrollLeft, 10),
ctBottom = ctScrollTop + ctClientHeight,
ctRight = ctScrollLeft + container.clientWidth,
newPos;
if (highlight) {
if (animate) {
animate = Ext.apply({
listeners: {
afteranimate: function() {
me.scrollChildFly.attach(dom).highlight();
}
}
}, animate);
} else {
me.scrollChildFly.attach(dom).highlight();
}
}
if (dom.offsetHeight > ctClientHeight || top < ctScrollTop) {
newPos = top;
} else if (bottom > ctBottom) {
newPos = bottom - ctClientHeight;
}
if (newPos != null) {
me.scrollChildFly.attach(container).scrollTo('top', newPos, animate);
}
if (hscroll !== false) {
newPos = null;
if (dom.offsetWidth > container.clientWidth || left < ctScrollLeft) {
newPos = left;
} else if (right > ctRight) {
newPos = right - container.clientWidth;
}
if (newPos != null) {
me.scrollChildFly.attach(container).scrollTo('left', newPos, animate);
}
}
return me;
},
scrollChildIntoView: function(child, hscroll) {
this.scrollChildFly.attach(Ext.getDom(child)).scrollIntoView(this, hscroll);
},
scroll: function(direction, distance, animate) {
if (!this.isScrollable()) {
return false;
}
direction = direction.charAt(0);
var me = this,
dom = me.dom,
side = direction === 'r' || direction === 'l' ? 'left' : 'top',
scrolled = false,
currentScroll, constrainedScroll;
if (direction === 'l' || direction === 't' || direction === 'u') {
distance = -distance;
}
if (side === 'left') {
currentScroll = dom.scrollLeft;
constrainedScroll = me.constrainScrollLeft(currentScroll + distance);
} else {
currentScroll = dom.scrollTop;
constrainedScroll = me.constrainScrollTop(currentScroll + distance);
}
if (constrainedScroll !== currentScroll) {
this.scrollTo(side, constrainedScroll, animate);
scrolled = true;
}
return scrolled;
},
constrainScrollLeft: function(left) {
var dom = this.dom;
return Math.max(Math.min(left, dom.scrollWidth - dom.clientWidth), 0);
},
constrainScrollTop: function(top) {
var dom = this.dom;
return Math.max(Math.min(top, dom.scrollHeight - dom.clientHeight), 0);
}
}, function() {
this.prototype.scrollChildFly = new this.Fly();
this.prototype.scrolltoFly = new this.Fly();
});
Ext.define('Ext.dom.Element_style', {
override: 'Ext.dom.Element'
},
function() {
var Element = this,
view = document.defaultView,
adjustDirect2DTableRe = /table-row|table-.*-group/,
INTERNAL = '_internal',
HIDDEN = 'hidden',
HEIGHT = 'height',
WIDTH = 'width',
ISCLIPPED = 'isClipped',
OVERFLOW = 'overflow',
OVERFLOWX = 'overflow-x',
OVERFLOWY = 'overflow-y',
ORIGINALCLIP = 'originalClip',
DOCORBODYRE = /#document|body/i,
styleHooks, verticalStyleHooks90, verticalStyleHooks270,
edges, k, edge, borderWidth;
if (!view || !view.getComputedStyle) {
Element.prototype.getStyle = function (property, inline) {
var me = this,
dom = me.dom,
multiple = typeof property != 'string',
hooks = me.styleHooks,
prop = property,
props = prop,
len = 1,
isInline = inline,
camel, domStyle, values, hook, out, style, i;
if (multiple) {
values = {};
prop = props[0];
i = 0;
if (!(len = props.length)) {
return values;
}
}
if (!dom || dom.documentElement) {
return values || '';
}
domStyle = dom.style;
if (inline) {
style = domStyle;
} else {
style = dom.currentStyle;
if (!style) {
isInline = true;
style = domStyle;
}
}
do {
hook = hooks[prop];
if (!hook) {
hooks[prop] = hook = { name: Element.normalize(prop) };
}
if (hook.get) {
out = hook.get(dom, me, isInline, style);
} else {
camel = hook.name;
if (hook.canThrow) {
try {
out = style[camel];
} catch (e) {
out = '';
}
} else {
out = style ? style[camel] : '';
}
}
if (!multiple) {
return out;
}
values[prop] = out;
prop = props[++i];
} while (i < len);
return values;
};
}
Element.override({
getHeight: function(contentHeight, preciseHeight) {
var me = this,
hidden = me.isStyle('display', 'none'),
height,
floating;
if (hidden) {
return 0;
}
height = me.dom.offsetHeight;
if (Ext.supports.Direct2DBug) {
floating = me.adjustDirect2DDimension(HEIGHT);
if (preciseHeight) {
height += floating;
}
else if (floating > 0 && floating < 0.5) {
height++;
}
}
if (contentHeight) {
height -= me.getBorderWidth("tb") + me.getPadding("tb");
}
return (height < 0) ? 0 : height;
},
getWidth: function(contentWidth, preciseWidth) {
var me = this,
dom = me.dom,
hidden = me.isStyle('display', 'none'),
rect, width, floating;
if (hidden) {
return 0;
}
if (Ext.supports.BoundingClientRect) {
rect = dom.getBoundingClientRect();
width = (me.vertical && !Ext.isIE9 && !Ext.supports.RotatedBoundingClientRect) ?
(rect.bottom - rect.top) : (rect.right - rect.left);
width = preciseWidth ? width : Math.ceil(width);
} else {
width = dom.offsetWidth;
}
if (Ext.supports.Direct2DBug && !me.vertical) {
floating = me.adjustDirect2DDimension(WIDTH);
if (preciseWidth) {
width += floating;
}
else if (floating > 0 && floating < 0.5) {
width++;
}
}
if (contentWidth) {
width -= me.getBorderWidth("lr") + me.getPadding("lr");
}
return (width < 0) ? 0 : width;
},
setWidth: function(width, animate) {
var me = this;
width = me.adjustWidth(width);
if (!animate || !me.anim) {
me.dom.style.width = me.addUnits(width);
}
else {
if (!Ext.isObject(animate)) {
animate = {};
}
me.animate(Ext.applyIf({
to: {
width: width
}
}, animate));
}
return me;
},
setHeight : function(height, animate) {
var me = this;
height = me.adjustHeight(height);
if (!animate || !me.anim) {
me.dom.style.height = me.addUnits(height);
}
else {
if (!Ext.isObject(animate)) {
animate = {};
}
me.animate(Ext.applyIf({
to: {
height: height
}
}, animate));
}
return me;
},
applyStyles: function(style) {
Ext.DomHelper.applyStyles(this.dom, style);
return this;
},
setSize: function(width, height, animate) {
var me = this;
if (Ext.isObject(width)) { 
animate = height;
height = width.height;
width = width.width;
}
width = me.adjustWidth(width);
height = me.adjustHeight(height);
if (!animate || !me.anim) {
me.dom.style.width = me.addUnits(width);
me.dom.style.height = me.addUnits(height);
}
else {
if (animate === true) {
animate = {};
}
me.animate(Ext.applyIf({
to: {
width: width,
height: height
}
}, animate));
}
return me;
},
getViewSize : function() {
var me = this,
dom = me.dom,
isDoc = DOCORBODYRE.test(dom.nodeName),
ret;
if (isDoc) {
ret = {
width : Element.getViewWidth(),
height : Element.getViewHeight()
};
} else {
ret = {
width : dom.clientWidth,
height : dom.clientHeight
};
}
return ret;
},
getSize: function(contentSize) {
return {width: this.getWidth(contentSize), height: this.getHeight(contentSize)};
},
adjustWidth : function(width) {
var me = this,
isNum = (typeof width == 'number');
if (isNum && me.autoBoxAdjust && !me.isBorderBox()) {
width -= (me.getBorderWidth("lr") + me.getPadding("lr"));
}
return (isNum && width < 0) ? 0 : width;
},
adjustHeight : function(height) {
var me = this,
isNum = (typeof height == "number");
if (isNum && me.autoBoxAdjust && !me.isBorderBox()) {
height -= (me.getBorderWidth("tb") + me.getPadding("tb"));
}
return (isNum && height < 0) ? 0 : height;
},
getColor : function(attr, defaultValue, prefix) {
var v = this.getStyle(attr),
color = prefix || prefix === '' ? prefix : '#',
h, len, i=0;
if (!v || (/transparent|inherit/.test(v))) {
return defaultValue;
}
if (/^r/.test(v)) {
v = v.slice(4, v.length - 1).split(',');
len = v.length;
for (; i<len; i++) {
h = parseInt(v[i], 10);
color += (h < 16 ? '0' : '') + h.toString(16);
}
} else {
v = v.replace('#', '');
color += v.length == 3 ? v.replace(/^(\w)(\w)(\w)$/, '$1$1$2$2$3$3') : v;
}
return(color.length > 5 ? color.toLowerCase() : defaultValue);
},
setOpacity: function(opacity, animate) {
var me = this;
if (!me.dom) {
return me;
}
if (!animate || !me.anim) {
me.setStyle('opacity', opacity);
}
else {
if (typeof animate != 'object') {
animate = {
duration: 350,
easing: 'ease-in'
};
}
me.animate(Ext.applyIf({
to: {
opacity: opacity
}
}, animate));
}
return me;
},
clearOpacity : function() {
return this.setOpacity('');
},
adjustDirect2DDimension: function(dimension) {
var me = this,
dom = me.dom,
display = me.getStyle('display'),
inlineDisplay = dom.style.display,
inlinePosition = dom.style.position,
originIndex = dimension === WIDTH ? 0 : 1,
currentStyle = dom.currentStyle,
floating;
if (display === 'inline') {
dom.style.display = 'inline-block';
}
dom.style.position = display.match(adjustDirect2DTableRe) ? 'absolute' : 'static';
floating = (parseFloat(currentStyle[dimension]) || parseFloat(currentStyle.msTransformOrigin.split(' ')[originIndex]) * 2) % 1;
dom.style.position = inlinePosition;
if (display === 'inline') {
dom.style.display = inlineDisplay;
}
return floating;
},
clip : function() {
var me = this,
data = (me.$cache || me.getCache()).data,
style;
if (!data[ISCLIPPED]) {
data[ISCLIPPED] = true;
style = me.getStyle([OVERFLOW, OVERFLOWX, OVERFLOWY]);
data[ORIGINALCLIP] = {
o: style[OVERFLOW],
x: style[OVERFLOWX],
y: style[OVERFLOWY]
};
me.setStyle(OVERFLOW, HIDDEN);
me.setStyle(OVERFLOWX, HIDDEN);
me.setStyle(OVERFLOWY, HIDDEN);
}
return me;
},
unclip : function() {
var me = this,
data = (me.$cache || me.getCache()).data,
clip;
if (data[ISCLIPPED]) {
data[ISCLIPPED] = false;
clip = data[ORIGINALCLIP];
if (clip.o) {
me.setStyle(OVERFLOW, clip.o);
}
if (clip.x) {
me.setStyle(OVERFLOWX, clip.x);
}
if (clip.y) {
me.setStyle(OVERFLOWY, clip.y);
}
}
return me;
},
boxWrap : function(cls) {
cls = cls || Ext.baseCSSPrefix + 'box';
var el = Ext.get(this.insertHtml("beforeBegin", "<div class='" + cls + "' role='presentation'>" + Ext.String.format(Element.boxMarkup, cls) + "</div>"));
Ext.DomQuery.selectNode('.' + cls + '-mc', el.dom).appendChild(this.dom);
return el;
},
getComputedHeight : function() {
var me = this,
h = Math.max(me.dom.offsetHeight, me.dom.clientHeight);
if (!h) {
h = parseFloat(me.getStyle(HEIGHT)) || 0;
if (!me.isBorderBox()) {
h += me.getFrameWidth('tb');
}
}
return h;
},
getComputedWidth : function() {
var me = this,
w = Math.max(me.dom.offsetWidth, me.dom.clientWidth);
if (!w) {
w = parseFloat(me.getStyle(WIDTH)) || 0;
if (!me.isBorderBox()) {
w += me.getFrameWidth('lr');
}
}
return w;
},
getFrameWidth : function(sides, onlyContentBox) {
return (onlyContentBox && this.isBorderBox()) ? 0 : (this.getPadding(sides) + this.getBorderWidth(sides));
},
addClsOnOver : function(className, testFn, scope) {
var me = this,
dom = me.dom,
hasTest = Ext.isFunction(testFn);
me.hover(
function() {
if (hasTest && testFn.call(scope || me, me) === false) {
return;
}
Ext.fly(dom, INTERNAL).addCls(className);
},
function() {
Ext.fly(dom, INTERNAL).removeCls(className);
}
);
return me;
},
addClsOnFocus : function(className, testFn, scope) {
var me = this,
dom = me.dom,
hasTest = Ext.isFunction(testFn);
me.on("focus", function() {
if (hasTest && testFn.call(scope || me, me) === false) {
return false;
}
Ext.fly(dom, INTERNAL).addCls(className);
});
me.on("blur", function() {
Ext.fly(dom, INTERNAL).removeCls(className);
});
return me;
},
addClsOnClick : function(className, testFn, scope) {
var me = this,
dom = me.dom,
hasTest = Ext.isFunction(testFn);
me.on("mousedown", function() {
if (hasTest && testFn.call(scope || me, me) === false) {
return false;
}
Ext.fly(dom, INTERNAL).addCls(className);
var d = Ext.getDoc(),
fn = function() {
Ext.fly(dom, INTERNAL).removeCls(className);
d.removeListener("mouseup", fn);
};
d.on("mouseup", fn);
});
return me;
},
getStyleSize : function() {
var me = this,
d = this.dom,
isDoc = DOCORBODYRE.test(d.nodeName),
s ,
w, h;
if (isDoc) {
return {
width : Element.getViewWidth(),
height : Element.getViewHeight()
};
}
s = me.getStyle([HEIGHT, WIDTH], true);  
if (s.width && s.width != 'auto') {
w = parseFloat(s.width);
if (me.isBorderBox()) {
w -= me.getFrameWidth('lr');
}
}
if (s.height && s.height != 'auto') {
h = parseFloat(s.height);
if (me.isBorderBox()) {
h -= me.getFrameWidth('tb');
}
}
return {width: w || me.getWidth(true), height: h || me.getHeight(true)};
},
statics: {
selectableCls: Ext.baseCSSPrefix + 'selectable',
unselectableCls: Ext.baseCSSPrefix + 'unselectable'
},
selectable : function() {
var me = this;
me.dom.unselectable = '';
me.removeCls(Element.unselectableCls);
me.addCls(Element.selectableCls);
return me;
},
unselectable : function() {
var me = this;
if (Ext.isOpera) {
me.dom.unselectable = 'on';
}
me.removeCls(Element.selectableCls);
me.addCls(Element.unselectableCls);
return me;
},
setVertical: function(angle, cls) {
var me = this,
proto = Element.prototype,
hooks;
me.vertical = true;
if (cls) {
me.addCls(me.verticalCls = cls);
}
me.setWidth = proto.setHeight;
me.setHeight = proto.setWidth;
if (!Ext.isIE9m) {
me.getWidth = proto.getHeight;
me.getHeight = proto.getWidth;
}
me.styleHooks = (angle === 270) ?
Element.prototype.verticalStyleHooks270 : Element.prototype.verticalStyleHooks90;
},
setHorizontal: function() {
var me = this,
cls = me.verticalCls;
delete me.vertical;
if (cls) {
delete me.verticalCls;
me.removeCls(cls);
}
delete me.setWidth;
delete me.setHeight;
if (!Ext.isIE9m) {
delete me.getWidth;
delete me.getHeight;
}
delete me.styleHooks;
}
});
Element.prototype.styleHooks = styleHooks = Ext.dom.AbstractElement.prototype.styleHooks;
Element.prototype.verticalStyleHooks90 = verticalStyleHooks90 = Ext.Object.chain(Element.prototype.styleHooks);
Element.prototype.verticalStyleHooks270 = verticalStyleHooks270 = Ext.Object.chain(Element.prototype.styleHooks);
verticalStyleHooks90.width = { name: 'height' };
verticalStyleHooks90.height = { name: 'width' };
verticalStyleHooks90['margin-top'] = { name: 'marginLeft' };
verticalStyleHooks90['margin-right'] = { name: 'marginTop' };
verticalStyleHooks90['margin-bottom'] = { name: 'marginRight' };
verticalStyleHooks90['margin-left'] = { name: 'marginBottom' };
verticalStyleHooks90['padding-top'] = { name: 'paddingLeft' };
verticalStyleHooks90['padding-right'] = { name: 'paddingTop' };
verticalStyleHooks90['padding-bottom'] = { name: 'paddingRight' };
verticalStyleHooks90['padding-left'] = { name: 'paddingBottom' };
verticalStyleHooks90['border-top'] = { name: 'borderLeft' };
verticalStyleHooks90['border-right'] = { name: 'borderTop' };
verticalStyleHooks90['border-bottom'] = { name: 'borderRight' };
verticalStyleHooks90['border-left'] = { name: 'borderBottom' };
verticalStyleHooks270.width = { name: 'height' };
verticalStyleHooks270.height = { name: 'width' };
verticalStyleHooks270['margin-top'] = { name: 'marginRight' };
verticalStyleHooks270['margin-right'] = { name: 'marginBottom' };
verticalStyleHooks270['margin-bottom'] = { name: 'marginLeft' };
verticalStyleHooks270['margin-left'] = { name: 'marginTop' };
verticalStyleHooks270['padding-top'] = { name: 'paddingRight' };
verticalStyleHooks270['padding-right'] = { name: 'paddingBottom' };
verticalStyleHooks270['padding-bottom'] = { name: 'paddingLeft' };
verticalStyleHooks270['padding-left'] = { name: 'paddingTop' };
verticalStyleHooks270['border-top'] = { name: 'borderRight' };
verticalStyleHooks270['border-right'] = { name: 'borderBottom' };
verticalStyleHooks270['border-bottom'] = { name: 'borderLeft' };
verticalStyleHooks270['border-left'] = { name: 'borderTop' };
if (Ext.isIE7m) {
styleHooks.fontSize = styleHooks['font-size'] = {
name: 'fontSize',
canThrow: true
};
styleHooks.fontStyle = styleHooks['font-style'] = {
name: 'fontStyle',
canThrow: true
};
styleHooks.fontFamily = styleHooks['font-family'] = {
name: 'fontFamily',
canThrow: true
};
}
if (Ext.isIEQuirks || Ext.isIE && Ext.ieVersion <= 8) {
function getBorderWidth (dom, el, inline, style) {
if (style[this.styleName] == 'none') {
return '0px';
}
return style[this.name];
}
edges = ['Top','Right','Bottom','Left'];
k = edges.length;
while (k--) {
edge = edges[k];
borderWidth = 'border' + edge + 'Width';
styleHooks['border-'+edge.toLowerCase()+'-width'] = styleHooks[borderWidth] = {
name: borderWidth,
styleName: 'border' + edge + 'Style',
get: getBorderWidth
};
}
}
Ext.getDoc().on('selectstart', function(ev, dom) {
var doc = document.documentElement,
selectableCls = Element.selectableCls,
unselectableCls = Element.unselectableCls,
tagName = dom && dom.tagName;
tagName = tagName && tagName.toLowerCase();
if (tagName === 'input' || tagName === 'textarea') {
return;
}
while (dom && dom.nodeType === 1 && dom !== doc) {
var el = Ext.fly(dom);
if (el.hasCls(selectableCls)) {
return;
}
if (el.hasCls(unselectableCls)) {
ev.stopEvent();
return;
}
dom = dom.parentNode;
}
});
});
Ext.onReady(function () {
var opacityRe = /alpha\(opacity=(.*)\)/i,
trimRe = /^\s+|\s+$/g,
hooks = Ext.dom.Element.prototype.styleHooks;
hooks.opacity = {
name: 'opacity',
afterSet: function(dom, value, el) {
if (el.isLayer) {
el.onOpacitySet(value);
}
}
};
if (!Ext.supports.Opacity && Ext.isIE) {
Ext.apply(hooks.opacity, {
get: function (dom) {
var filter = dom.style.filter,
match, opacity;
if (filter.match) {
match = filter.match(opacityRe);
if (match) {
opacity = parseFloat(match[1]);
if (!isNaN(opacity)) {
return opacity ? opacity / 100 : 0;
}
}
}
return 1;
},
set: function (dom, value) {
var style = dom.style,
val = style.filter.replace(opacityRe, '').replace(trimRe, '');
style.zoom = 1; 
if (typeof(value) == 'number' && value >= 0 && value < 1) {
value *= 100;
style.filter = val + (val.length ? ' ' : '') + 'alpha(opacity='+value+')';
} else {
style.filter = val;
}
}  
});
}
});
Ext.define('Ext.util.Positionable', {
_positionTopLeft: ['position', 'top', 'left'],
_alignRe: /^([a-z]+)-([a-z]+)(\?)?$/,
afterSetPosition: Ext.emptyFn,
adjustForConstraints: function(xy, parent) {
var vector = this.getConstrainVector(parent, xy);
if (vector) {
xy[0] += vector[0];
xy[1] += vector[1];
}
return xy;
},
alignTo: function(element, position, offsets, animate) {
var me = this,
el = me.el;
return me.setXY(me.getAlignToXY(element, position, offsets),
el.anim && !!animate ? el.anim(animate) : false);
},
anchorTo: function(anchorToEl, alignment, offsets, animate, monitorScroll, callback) {
var me = this,
scroll = !Ext.isEmpty(monitorScroll),
action = function() {
me.alignTo(anchorToEl, alignment, offsets, animate);
Ext.callback(callback, me);
},
anchor = me.getAnchor();
me.removeAnchor();
Ext.apply(anchor, {
fn: action,
scroll: scroll
});
Ext.EventManager.onWindowResize(action, null);
if (scroll) {
Ext.EventManager.on(window, 'scroll', action, null,
{buffer: !isNaN(monitorScroll) ? monitorScroll : 50});
}
action(); 
return me;
},
calculateAnchorXY: function(anchor, extraX, extraY, mySize) {
var me = this,
el = me.el,
doc = document,
isViewport = el.dom == doc.body || el.dom == doc,
round = Math.round,
xy, myWidth, myHeight;
anchor = (anchor || "tl").toLowerCase();
mySize = mySize || {};
myWidth = mySize.width || isViewport ? Ext.Element.getViewWidth() : me.getWidth();
myHeight = mySize.height || isViewport ? Ext.Element.getViewHeight() : me.getHeight();
switch (anchor) {
case 'tl' : xy = [0, 0];
break;
case 'bl' : xy = [0, myHeight];
break;
case 'tr' : xy = [myWidth, 0];
break;
case 'c'  : xy = [round(myWidth * 0.5), round(myHeight * 0.5)];
break;
case 't'  : xy = [round(myWidth * 0.5), 0];
break;
case 'l'  : xy = [0, round(myHeight * 0.5)];
break;
case 'r'  : xy = [myWidth, round(myHeight * 0.5)];
break;
case 'b'  : xy = [round(myWidth * 0.5), myHeight];
break;
case 'tc' : xy = [round(myWidth * 0.5), 0];
break;
case 'bc' : xy = [round(myWidth * 0.5), myHeight];
break;
case 'br' : xy = [myWidth, myHeight];
}
return [xy[0] + extraX, xy[1] + extraY];
},
convertPositionSpec: Ext.identityFn,
getAlignToXY: function(alignToEl, posSpec, offset) {
var me = this,
viewportWidth = Ext.Element.getViewWidth() - 10, 
viewportHeight = Ext.Element.getViewHeight() - 10, 
doc = document,
docElement = doc.documentElement,
docBody = doc.body,
scrollX = (docElement.scrollLeft || docBody.scrollLeft || 0),
scrollY = (docElement.scrollTop  || docBody.scrollTop  || 0),
alignMatch, myPosition, alignToElPosition, myWidth, myHeight,
alignToElRegion, swapY, swapX, constrain, align1, align2,
p1y, p1x, p2y, p2x, x, y;
alignToEl = Ext.get(alignToEl.el || alignToEl);
if (!alignToEl || !alignToEl.dom) {
}
offset = offset || [0,0];
posSpec = (!posSpec || posSpec == "?" ? "tl-bl?" :
(!(/-/).test(posSpec) && posSpec !== "" ? "tl-" + posSpec : posSpec || "tl-bl")).toLowerCase();
posSpec = me.convertPositionSpec(posSpec);
alignMatch = posSpec.match(me._alignRe);
align1 = alignMatch[1];
align2 = alignMatch[2];
constrain = !!alignMatch[3];
myPosition = me.getAnchorXY(align1, true);
alignToElPosition = me.getAnchorToXY(alignToEl, align2, false);
x = alignToElPosition[0] - myPosition[0] + offset[0];
y = alignToElPosition[1] - myPosition[1] + offset[1];
if (constrain) {
myWidth = me.getWidth();
myHeight = me.getHeight();
alignToElRegion = alignToEl.getRegion();
p1y = align1.charAt(0);
p1x = align1.charAt(align1.length - 1);
p2y = align2.charAt(0);
p2x = align2.charAt(align2.length - 1);
swapY = ((p1y == "t" && p2y == "b") || (p1y == "b" && p2y == "t"));
swapX = ((p1x == "r" && p2x == "l") || (p1x == "l" && p2x == "r"));
if (x + myWidth > viewportWidth + scrollX) {
x = swapX ? alignToElRegion.left - myWidth : viewportWidth + scrollX - myWidth;
}
if (x < scrollX) {
x = swapX ? alignToElRegion.right : scrollX;
}
if (y + myHeight > viewportHeight + scrollY) {
y = swapY ? alignToElRegion.top - myHeight : viewportHeight + scrollY - myHeight;
}
if (y < scrollY) {
y = swapY ? alignToElRegion.bottom : scrollY;
}
}
return [x,y];
},
getAnchor: function(){
var el = this.el,
data = (el.$cache || el.getCache()).data,
anchor;
if (!el.dom) {
return;
}
anchor = data._anchor;
if(!anchor){
anchor = data._anchor = {};
}
return anchor;
},
getAnchorXY: function(anchor, local, mySize) {
var me = this,
myPos = me.getXY(),
el = me.el,
doc = document,
isViewport = el.dom == doc.body || el.dom == doc,
scroll = el.getScroll(),
extraX = isViewport ? scroll.left : local ? 0 : myPos[0],
extraY = isViewport ? scroll.top : local ? 0 : myPos[1];
return me.calculateAnchorXY(anchor, extraX, extraY, mySize);
},
getBox: function(contentBox, local) {
var me = this,
xy = local ? me.getLocalXY() : me.getXY(),
x = xy[0],
y = xy[1],
w = me.getWidth(),
h = me.getHeight(),
borderPadding, beforeX, beforeY;
if (contentBox) {
borderPadding = me.getBorderPadding();
beforeX = borderPadding.beforeX;
beforeY = borderPadding.beforeY;
x += beforeX;
y += beforeY;
w -= (beforeX + borderPadding.afterX);
h -= (beforeY + borderPadding.afterY);
}
return {
x: x,
left: x,
0: x,
y: y,
top: y,
1: y,
width: w,
height: h,
right: x + w,
bottom: y + h
};
},
calculateConstrainedPosition: function(constrainTo, proposedPosition, local, proposedSize) {
var me = this,
vector,
fp = me.floatParent,
parentNode = fp ? fp.getTargetEl() : null,
parentOffset,
borderPadding,
proposedConstrainPosition,
xy = false;
if (local && fp) {
parentOffset = parentNode.getXY();
borderPadding = parentNode.getBorderPadding();
parentOffset[0] += borderPadding.beforeX;
parentOffset[1] += borderPadding.beforeY;
if (proposedPosition) {
proposedConstrainPosition = [proposedPosition[0] + parentOffset[0], proposedPosition[1] + parentOffset[1]];
}
} else {
proposedConstrainPosition = proposedPosition;
}
constrainTo = constrainTo || me.constrainTo || parentNode || me.container || me.el.parent();
vector = (me.constrainHeader ? me.header : me).getConstrainVector(constrainTo, proposedConstrainPosition, proposedSize);
if (vector) {
xy = proposedPosition || me.getPosition(local);
xy[0] += vector[0];
xy[1] += vector[1];
}
return xy;
},
getConstrainVector: function(constrainTo, proposedPosition, proposedSize) {
var thisRegion = this.getRegion(),
vector = [0, 0],
shadowSize = (this.shadow && this.constrainShadow && !this.shadowDisabled) ? this.shadow.getShadowSize() : undefined,
overflowed = false,
constraintInsets = this.constraintInsets;
if (!(constrainTo instanceof Ext.util.Region)) {
constrainTo = Ext.get(constrainTo.el || constrainTo).getViewRegion();
}
if (constraintInsets) {
constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.length);
}
if (proposedPosition) {
thisRegion.translateBy(proposedPosition[0] - thisRegion.x, proposedPosition[1] - thisRegion.y);
}
if (proposedSize) {
thisRegion.right = thisRegion.left + proposedSize[0];
thisRegion.bottom = thisRegion.top + proposedSize[1];
}
if (shadowSize) {
constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
}
if (thisRegion.right > constrainTo.right) {
overflowed = true;
vector[0] = (constrainTo.right - thisRegion.right);    
}
if (thisRegion.left + vector[0] < constrainTo.left) {
overflowed = true;
vector[0] = (constrainTo.left - thisRegion.left);      
}
if (thisRegion.bottom > constrainTo.bottom) {
overflowed = true;
vector[1] = (constrainTo.bottom - thisRegion.bottom);  
}
if (thisRegion.top + vector[1] < constrainTo.top) {
overflowed = true;
vector[1] = (constrainTo.top - thisRegion.top);        
}
return overflowed ? vector : false;
},
getOffsetsTo: function(offsetsTo) {
var o = this.getXY(),
e = Ext.fly(offsetsTo.el || offsetsTo, '_internal').getXY();
return [o[0] - e[0],o[1] - e[1]];
},
getRegion: function() {
var box = this.getBox();
return new Ext.util.Region(box.top, box.right, box.bottom, box.left);
},
getViewRegion: function() {
var me = this,
el = me.el,
isBody = el.dom.nodeName === 'BODY',
borderPadding, scroll, pos, top, left, width, height;
if (isBody) {
scroll = el.getScroll();
left = scroll.left;
top = scroll.top;
width = Ext.dom.AbstractElement.getViewportWidth();
height = Ext.dom.AbstractElement.getViewportHeight();
}
else {
borderPadding = me.getBorderPadding();
pos = me.getXY();
left = pos[0] + borderPadding.beforeX;
top = pos[1] + borderPadding.beforeY;
width = me.getWidth(true);
height = me.getHeight(true);
}
return new Ext.util.Region(top, left + width, top + height, left);
},
move: function(direction, distance, animate) {
var me = this,
xy = me.getXY(),
x = xy[0],
y = xy[1],
left = [x - distance, y],
right = [x + distance, y],
top = [x, y - distance],
bottom = [x, y + distance],
hash = {
l: left,
left: left,
r: right,
right: right,
t: top,
top: top,
up: top,
b: bottom,
bottom: bottom,
down: bottom
};
direction = direction.toLowerCase();
me.setXY([hash[direction][0], hash[direction][1]], animate);
},
removeAnchor: function() {
var anchor = this.getAnchor();
if (anchor && anchor.fn) {
Ext.EventManager.removeResizeListener(anchor.fn);
if (anchor.scroll) {
Ext.EventManager.un(window, 'scroll', anchor.fn);
}
delete anchor.fn;
}
return this;
},
setBox: function(box, animate) {
var me = this,
el = me.el,
x = box.x,
y = box.y,
xy = [x, y],
w = box.width,
h = box.height,
doConstrain = (me.constrain || me.constrainHeader),
constrainedPos = doConstrain && me.calculateConstrainedPosition(null, [x, y], false, [w, h]);
if (constrainedPos) {
x = constrainedPos[0];
y = constrainedPos[1];
}
if (!animate || !el.anim) {
me.setSize(w, h);
me.setXY([x, y]);
me.afterSetPosition(x, y);
} else {
me.animate(Ext.applyIf({
to: {
x: x,
y: y,
width: el.adjustWidth(w),
height: el.adjustHeight(h)
},
listeners: {
afteranimate: Ext.Function.bind(me.afterSetPosition, me, [x, y])
}
}, animate));
}
return me;
},
setRegion: function(region, animate) {
return this.setBox({
x: region.left,
y: region.top,
width: region.right - region.left,
height: region.bottom - region.top
}, animate);
},
translatePoints: function(x, y) {
var pos = this.translateXY(x, y);
return {
left: pos.x,
top: pos.y
};
},
translateXY: function(x, y) {
var me = this,
el = me.el,
styles = el.getStyle(me._positionTopLeft),
relative = styles.position == 'relative',
left = parseFloat(styles.left),
top = parseFloat(styles.top),
xy = me.getXY();
if (Ext.isArray(x)) {
y = x[1];
x = x[0];
}
if (isNaN(left)) {
left = relative ? 0 : el.dom.offsetLeft;
}
if (isNaN(top)) {
top = relative ? 0 : el.dom.offsetTop;
}
left = (typeof x == 'number') ? x - xy[0] + left : undefined;
top = (typeof y == 'number') ? y - xy[1] + top : undefined;
return {
x: left,
y: top
};
}
});
Ext.define('Ext.dom.Element', function(Element) {
var HIDDEN          = 'hidden',
DOC             = document,
VISIBILITY      = "visibility",
DISPLAY         = "display",
NONE            = "none",
XMASKED         = Ext.baseCSSPrefix + "masked",
XMASKEDRELATIVE = Ext.baseCSSPrefix + "masked-relative",
EXTELMASKMSG    = Ext.baseCSSPrefix + "mask-msg",
bodyRe          = /^body/i,
visFly,
noBoxAdjust = Ext.isStrict ? {
select: 1
}: {
input: 1,
select: 1,
textarea: 1
},
isScrolled = function(c) {
var r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if (ci.scrollTop > 0 || ci.scrollLeft > 0) {
r[++ri] = ci;
}
}
return r;
};
return {
extend:  Ext.dom.AbstractElement ,
alternateClassName: ['Ext.Element', 'Ext.core.Element'],
tableTagRe: /^(?:tr|td|table|tbody)$/i,
mixins: [
Ext.util.Positionable 
],
addUnits: function() {
return Element.addUnits.apply(Element, arguments);
},
focus: function(defer,  dom) {
var me = this;
dom = dom || me.dom;
try {
if (Number(defer)) {
Ext.defer(me.focus, defer, me, [null, dom]);
} else {
dom.focus();
}
} catch(e) {
}
return me;
},
blur: function() {
var me = this,
dom = me.dom;
if (dom !== document.body) {
try {
dom.blur();
} catch(e) {
}
return me;
} else {
return me.focus(undefined, dom);
}
},
isBorderBox: function() {
var box = Ext.isBorderBox;
if (box && Ext.isIE7m) {
box = !((this.dom.tagName || "").toLowerCase() in noBoxAdjust);
}
return box;
},
hover: function(overFn, outFn, scope, options) {
var me = this;
me.on('mouseenter', overFn, scope || me.dom, options);
me.on('mouseleave', outFn, scope || me.dom, options);
return me;
},
getAttributeNS: function(ns, name) {
return this.getAttribute(name, ns);
},
getAttribute: (Ext.isIE && !(Ext.isIE9p && DOC.documentMode >= 9)) ?
function(name, ns) {
var d = this.dom,
type;
if (ns) {
type = typeof d[ns + ":" + name];
if (type != 'undefined' && type != 'unknown') {
return d[ns + ":" + name] || null;
}
return null;
}
if (name === "for") {
name = "htmlFor";
}
return d[name] || null;
} : function(name, ns) {
var d = this.dom;
if (ns) {
return d.getAttributeNS(ns, name) || d.getAttribute(ns + ":" + name);
}
return  d.getAttribute(name) || d[name] || null;
},
cacheScrollValues: function() {
var me = this,
scrolledDescendants,
el, i,
scrollValues = [],
result = function() {
for (i = 0; i < scrolledDescendants.length; i++) {
el = scrolledDescendants[i];
el.scrollLeft = scrollValues[i][0];
el.scrollTop  = scrollValues[i][1];
}
};
if (!Ext.DomQuery.pseudos.isScrolled) {
Ext.DomQuery.pseudos.isScrolled = isScrolled;
}
scrolledDescendants = me.query(':isScrolled');
for (i = 0; i < scrolledDescendants.length; i++) {
el = scrolledDescendants[i];
scrollValues[i] = [el.scrollLeft, el.scrollTop];
}
return result;
},
autoBoxAdjust: true,
isVisible : function(deep) {
var me = this,
dom = me.dom,
stopNode = dom.ownerDocument.documentElement;
if (!visFly) {
visFly = new Element.Fly();
}
while (dom !== stopNode) {
if (!dom || dom.nodeType === 11 || (visFly.attach(dom)).isStyle(VISIBILITY, HIDDEN) || visFly.isStyle(DISPLAY, NONE)) {
return false;
}
if (!deep) {
break;
}
dom = dom.parentNode;
}
return true;
},
isDisplayed : function() {
return !this.isStyle(DISPLAY, NONE);
},
enableDisplayMode : function(display) {
var me = this;
me.setVisibilityMode(Element.DISPLAY);
if (!Ext.isEmpty(display)) {
(me.$cache || me.getCache()).data.originalDisplay = display;
}
return me;
},
mask : function(msg, msgCls , elHeight) {
var me            = this,
dom           = me.dom,
setExpression = dom.style.setExpression,
data          = (me.$cache || me.getCache()).data,
maskShimEl    = data.maskShimEl,
maskEl        = data.maskEl,
maskMsg       = data.maskMsg,
widthExpression, heightExpression, docElem, ie6DocElHeight;
if (!(bodyRe.test(dom.tagName) && me.getStyle('position') == 'static')) {
me.addCls(XMASKEDRELATIVE);
}
if (maskEl) {
maskEl.remove();
}
if (maskMsg) {
maskMsg.remove();
}
if (maskShimEl) {
maskShimEl.remove();
}
if (Ext.isIE6) {
maskShimEl = Ext.DomHelper.append(dom, {
tag: 'iframe',
role: 'presentation',
cls : Ext.baseCSSPrefix + 'shim ' + Ext.baseCSSPrefix + 'mask-shim'
}, true);
data.maskShimEl = maskShimEl;
maskShimEl.setDisplayed(true);
}
Ext.DomHelper.append(dom, [{
role: 'presentation',
cls : Ext.baseCSSPrefix + "mask",
style: 'top:0;left:0;'
}, {
role: 'presentation',
cls : msgCls ? EXTELMASKMSG + " " + msgCls : EXTELMASKMSG,
cn  : {
tag: 'div',
role: 'presentation',
cls: Ext.baseCSSPrefix + 'mask-msg-inner',
cn: {
tag: 'div',
role: 'presentation',
cls: Ext.baseCSSPrefix + 'mask-msg-text',
html: msg || ''
}
}
}]);
maskMsg = Ext.get(dom.lastChild);
maskEl = Ext.get(maskMsg.dom.previousSibling);
data.maskMsg = maskMsg;
data.maskEl = maskEl;
me.addCls(XMASKED);
maskEl.setDisplayed(true);
if (typeof msg == 'string') {
maskMsg.setDisplayed(true);
maskMsg.center(me);
} else {
maskMsg.setDisplayed(false);
}
if (Ext.isStrict && !Ext.isIE6) {
if (dom === DOC.body) {
maskEl.addCls(Ext.baseCSSPrefix + 'mask-fixed');
}
}
if (dom !== DOC.body || Ext.isIE6 || Ext.isIEQuirks) {
if (!Ext.supports.IncludePaddingInWidthCalculation && setExpression) {
try {
maskEl.dom.style.setExpression('width', 'this.parentNode.clientWidth + "px"');
widthExpression = 'this.parentNode.clientWidth + "px"';
if (maskShimEl) {
maskShimEl.dom.style.setExpression('width', widthExpression);
}
maskEl.dom.style.setExpression('width', widthExpression);
} catch (e) {}
}
if (!Ext.supports.IncludePaddingInHeightCalculation && setExpression) {
try {
heightExpression = 'this.parentNode.' + (dom == DOC.body ? 'scrollHeight' : 'offsetHeight') + ' + "px"';
if (maskShimEl) {
maskShimEl.dom.style.setExpression('height', heightExpression);
}
maskEl.dom.style.setExpression('height', heightExpression);
} catch (e) {}
}
else if (Ext.isIE9m && !(Ext.isIE7 && Ext.isStrict) && me.getStyle('height') == 'auto') {
if (Ext.isIE6 && Ext.isStrict) {
docElem = dom.parentNode;
ie6DocElHeight = Math.max(docElem.clientHeight, docElem.scrollHeight);
}
if (maskShimEl) {
maskShimEl.setSize(undefined, elHeight || ie6DocElHeight || me.getHeight());
}
maskEl.setSize(undefined, elHeight || ie6DocElHeight || me.getHeight());
}
}
return maskEl;
},
unmask : function() {
var me      = this,
data    = (me.$cache || me.getCache()).data,
maskEl  = data.maskEl,
maskShimEl = data.maskShimEl,
maskMsg = data.maskMsg,
style;
if (maskEl) {
style = maskEl.dom.style;
if (style.clearExpression) {
style.clearExpression('width');
style.clearExpression('height');
}
if (maskEl) {
maskEl.remove();
delete data.maskEl;
}
if (maskMsg) {
maskMsg.remove();
delete data.maskMsg;
}
me.removeCls([XMASKED, XMASKEDRELATIVE]);
if (maskShimEl) {
style = maskShimEl.dom.style;
if (style.clearExpression) {
style.clearExpression('width');
style.clearExpression('height');
}
maskShimEl.remove();
delete data.maskShimEl;
}
}
},
isMasked : function() {
var me      = this,
data    = (me.$cache || me.getCache()).data,
maskEl  = data.maskEl,
maskMsg = data.maskMsg,
hasMask = false; 
if (maskEl && maskEl.isVisible()) {
if (maskMsg) {
maskMsg.center(me);
}
hasMask = true;
}
return hasMask;
},
createShim : function() {
var el = DOC.createElement('iframe'),
shim;
el.frameBorder = '0';
el.className = Ext.baseCSSPrefix + 'shim';
el.src = Ext.SSL_SECURE_URL;
el.setAttribute('role', 'presentation');
shim = Ext.get(this.dom.parentNode.insertBefore(el, this.dom));
shim.autoBoxAdjust = false;
return shim;
},
addKeyListener : function(key, fn, scope){
var config;
if(typeof key != 'object' || Ext.isArray(key)){
config = {
target: this,
key: key,
fn: fn,
scope: scope
};
}else{
config = {
target: this,
key : key.key,
shift : key.shift,
ctrl : key.ctrl,
alt : key.alt,
fn: fn,
scope: scope
};
}
return new Ext.util.KeyMap(config);
},
addKeyMap : function(config) {
return new Ext.util.KeyMap(Ext.apply({
target: this
}, config));
},
on: function(eventName, fn, scope, options) {
Ext.EventManager.on(this, eventName, fn, scope || this, options);
return this;
},
un: function(eventName, fn, scope) {
Ext.EventManager.un(this, eventName, fn, scope || this);
return this;
},
removeAllListeners: function() {
Ext.EventManager.removeAll(this);
return this;
},
purgeAllListeners: function() {
Ext.EventManager.purgeElement(this);
return this;
},
select: function(selector) {
return Element.select(selector, false,  this.dom);
}
};
}, function() {
var DOC             = document,
EC              = Ext.cache,
Element         = this,
AbstractElement = Ext.dom.AbstractElement,
focusRe         = /^a|button|embed|iframe|input|object|select|textarea$/i,
nonSpaceRe      = /\S/,
scriptTagRe     = /(?:<script([^>]*)?>)((\n|\r|.)*?)(?:<\/script>)/ig,
replaceScriptTagRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig,
srcRe           = /\ssrc=([\'\"])(.*?)\1/i,
typeRe          = /\stype=([\'\"])(.*?)\1/i,
useDocForId     = !Ext.isIE8m,
internalFly;
Element.boxMarkup = [
'<div class="{0}-tl" role="presentation">',
'<div class="{0}-tr" role="presentation">',
'<div class="{0}-tc" role="presentation"></div>',
'</div>',
'</div>',
'<div class="{0}-ml" role="presentation">',
'<div class="{0}-mr" role="presentation">',
'<div class="{0}-mc" role="presentation"></div>',
'</div>',
'</div>',
'<div class="{0}-bl" role="presentation">',
'<div class="{0}-br" role="presentation">',
'<div class="{0}-bc" role="presentation"></div>',
'</div>',
'</div>'
].join('');
function garbageCollect() {
if (!Ext.enableGarbageCollector) {
clearInterval(Element.collectorThreadId);
} else {
var eid,
d,
o,
t;
for (eid in EC) {
if (!EC.hasOwnProperty(eid)) {
continue;
}
o = EC[eid];
if (o.skipGarbageCollection) {
continue;
}
d = o.dom;
if (d && (!d.parentNode || (!d.offsetParent && !Ext.getElementById(eid)))) {
if (Ext.enableListenerCollection) {
Ext.EventManager.removeAll(d);
}
delete EC[eid];
}
}
if (Ext.isIE) {
t = {};
for (eid in EC) {
if (!EC.hasOwnProperty(eid)) {
continue;
}
t[eid] = EC[eid];
}
EC = Ext.cache = t;
}
}
}
Element.collectorThreadId = setInterval(garbageCollect, 30000);
Element.addMethods({
monitorMouseLeave: function(delay, handler, scope) {
var me = this,
timer,
listeners = {
mouseleave: function(e) {
timer = setTimeout(Ext.Function.bind(handler, scope||me, [e]), delay);
},
mouseenter: function() {
clearTimeout(timer);
},
freezeEvent: true
};
me.on(listeners);
return listeners;
},
swallowEvent : function(eventName, preventDefault) {
var me = this,
e, eLen,
fn = function(e) {
e.stopPropagation();
if (preventDefault) {
e.preventDefault();
}
};
if (Ext.isArray(eventName)) {
eLen = eventName.length;
for (e = 0; e < eLen; e++) {
me.on(eventName[e], fn);
}
return me;
}
me.on(eventName, fn);
return me;
},
relayEvent : function(eventName, observable) {
this.on(eventName, function(e) {
observable.fireEvent(eventName, e);
});
},
clean : function(forceReclean) {
var me   = this,
dom  = me.dom,
data = (me.$cache || me.getCache()).data,
n    = dom.firstChild,
ni   = -1,
nx;
if (data.isCleaned && forceReclean !== true) {
return me;
}
while (n) {
nx = n.nextSibling;
if (n.nodeType == 3) {
if (!(nonSpaceRe.test(n.nodeValue))) {
dom.removeChild(n);
} else if (nx && nx.nodeType == 3) {
n.appendData(Ext.String.trim(nx.data));
dom.removeChild(nx);
nx = n.nextSibling;
n.nodeIndex = ++ni;
}
} else {
internalFly.attach(n).clean();
n.nodeIndex = ++ni;
}
n = nx;
}
data.isCleaned = true;
return me;
},
load : function(options) {
this.getLoader().load(options);
return this;
},
getLoader : function() {
var me = this,
data = (me.$cache || me.getCache()).data,
loader = data.loader;
if (!loader) {
data.loader = loader = new Ext.ElementLoader({
target: me
});
}
return loader;
},
syncContent: function(source) {
source = Ext.getDom(source);
if(!source) return;
var sourceNodes = source.childNodes,
sourceLen = sourceNodes.length,
dest = this.dom,
destNodes = dest.childNodes,
destLen = destNodes.length,
i,  destNode, sourceNode,
nodeType, newAttrs, attLen, attName;
if (Ext.isIE9m && dest.mergeAttributes) {
dest.mergeAttributes(source, true);
dest.src = source.src;
} else {
newAttrs = source.attributes;
attLen = newAttrs.length;
for (i = 0; i < attLen; i++) {
attName = newAttrs[i].name;
if (attName !== 'id') {
dest.setAttribute(attName, newAttrs[i].value);
}
}
}
if (sourceLen !== destLen) {
dest.innerHTML = source.innerHTML;
return;
}
for (i = 0; i < sourceLen; i++) {
sourceNode = sourceNodes[i];
destNode = destNodes[i];
nodeType = sourceNode.nodeType;
if (nodeType !== destNode.nodeType || (nodeType === 1 && sourceNode.tagName !== destNode.tagName)) {
dest.innerHTML = source.innerHTML;
return;
}
if (nodeType === 3) {
destNode.data = sourceNode.data;
}
else {
if (sourceNode.id && destNode.id !== sourceNode.id) {
destNode.id = sourceNode.id;
}
destNode.style.cssText = sourceNode.style.cssText;
destNode.className = sourceNode.className;
internalFly.attach(destNode).syncContent(sourceNode);
}
}
},
update : function(html, loadScripts, callback) {
var me = this,
id,
dom,
interval;
if (!me.dom) {
return me;
}
html = html || '';
dom = me.dom;
if (loadScripts !== true) {
dom.innerHTML = html;
Ext.callback(callback, me);
return me;
}
id  = Ext.id();
html += '<span id="' + id + '" role="presentation"></span>';
interval = setInterval(function() {
var hd,
match,
attrs,
srcMatch,
typeMatch,
el,
s;
if (!(el = DOC.getElementById(id))) {
return false;
}
clearInterval(interval);
Ext.removeNode(el);
hd = Ext.getHead().dom;
while ((match = scriptTagRe.exec(html))) {
attrs = match[1];
srcMatch = attrs ? attrs.match(srcRe) : false;
if (srcMatch && srcMatch[2]) {
s = DOC.createElement("script");
s.src = srcMatch[2];
typeMatch = attrs.match(typeRe);
if (typeMatch && typeMatch[2]) {
s.type = typeMatch[2];
}
hd.appendChild(s);
} else if (match[2] && match[2].length > 0) {
if (window.execScript) {
window.execScript(match[2]);
} else {
window.eval(match[2]);
}
}
}
Ext.callback(callback, me);
}, 20);
dom.innerHTML = html.replace(replaceScriptTagRe, '');
return me;
},
removeAllListeners : function() {
this.removeAnchor();
Ext.EventManager.removeAll(this.dom);
return this;
},
createProxy : function(config, renderTo, matchBox) {
config = (typeof config == 'object') ? config : { tag: "div", role: 'presentation', cls: config };
var me = this,
proxy = renderTo ? Ext.DomHelper.append(renderTo, config, true) :
Ext.DomHelper.insertBefore(me.dom, config, true);
proxy.setVisibilityMode(Element.DISPLAY);
proxy.hide();
if (matchBox && me.setBox && me.getBox) { 
proxy.setBox(me.getBox());
}
return proxy;
},
needsTabIndex: function() {
if (this.dom) {
if ((this.dom.nodeName === 'a') && (!this.dom.href)) {
return true;
}
return !focusRe.test(this.dom.nodeName);
}
},
isFocusable: function ( asFocusEl) {
var dom = this.dom,
tabIndexAttr = dom.getAttributeNode('tabIndex'),
tabIndex,
nodeName = dom.nodeName,
canFocus = false;
if (tabIndexAttr) {
tabIndex = tabIndexAttr.value;
}
if (dom && !dom.disabled) {
if (tabIndex == -1) { 
canFocus = Ext.FocusManager && Ext.FocusManager.enabled && asFocusEl;
}
else {
if (focusRe.test(nodeName)) {
if ((nodeName !== 'a') || dom.href) {
canFocus = true;
}
}
else {
canFocus = tabIndex != null && tabIndex >= 0;
}
}
canFocus = canFocus && this.isVisible(true);
}
return canFocus;
}
});
if (Ext.isIE9m) {
Element.prototype.getById = function (id, asDom) {
var dom = this.dom,
cacheItem, el, ret;
if (dom) {
el = (useDocForId && DOC.getElementById(id)) || dom.all[id];
if (el) {
if (asDom) {
ret = el;
} else {
cacheItem = EC[id];
if (cacheItem && cacheItem.el) {
ret = Ext.updateCacheEntry(cacheItem, el).el;
} else {
ret = new Element(el);
}
}
return ret;
}
}
return asDom ? Ext.getDom(id) : Element.get(id);
};
}
Element.createAlias({
addListener: 'on',
removeListener: 'un',
clearListeners: 'removeAllListeners',
focusable: 'isFocusable'
});
Element.Fly = AbstractElement.Fly = new Ext.Class({
extend: Element,
isFly: true,
constructor: function(dom) {
this.dom = dom;
this.el = this;
},
attach: AbstractElement.Fly.prototype.attach
});
internalFly = new Element.Fly();
if (Ext.isIE9m) {
Ext.getElementById = function (id) {
var el = DOC.getElementById(id),
detachedBodyEl;
if (!el && (detachedBodyEl = AbstractElement.detachedBodyEl)) {
el = detachedBodyEl.dom.all[id];
}
return el;
};
} else if (!DOC.querySelector) {
Ext.getDetachedBody = Ext.getBody;
Ext.getElementById = function (id) {
return DOC.getElementById(id);
};
}
});
Ext.define('Ext.dom.CompositeElementLite', {
alternateClassName: 'Ext.CompositeElementLite',
statics: {
importElementMethods: function() {
var name,
elementPrototype = Ext.dom.Element.prototype,
prototype = this.prototype;
for (name in elementPrototype) {
if (typeof elementPrototype[name] == 'function'){
(function(key) {
prototype[key] = prototype[key] || function() {
return this.invoke(key, arguments);
};
}).call(prototype, name);
}
}
}
},
constructor: function(elements, root) {
this.elements = [];
this.add(elements, root);
this.el = new Ext.dom.AbstractElement.Fly();
},
isComposite: true,
getElement: function(el) {
return this.el.attach(el);
},
transformElement: function(el) {
return Ext.getDom(el);
},
getCount: function() {
return this.elements.length;
},
add: function(els, root) {
var elements = this.elements,
i, ln;
if (!els) {
return this;
}
if (typeof els == "string") {
els = Ext.dom.Element.selectorFunction(els, root);
}
else if (els.isComposite) {
els = els.elements;
}
else if (!Ext.isIterable(els)) {
els = [els];
}
for (i = 0, ln = els.length; i < ln; ++i) {
elements.push(this.transformElement(els[i]));
}
return this;
},
invoke: function(fn, args) {
var elements = this.elements,
ln = elements.length,
element,
i;
fn = Ext.dom.Element.prototype[fn];
for (i = 0; i < ln; i++) {
element = elements[i];
if (element) {
fn.apply(this.getElement(element), args);
}
}
return this;
},
item: function(index) {
var el = this.elements[index],
out = null;
if (el) {
out = this.getElement(el);
}
return out;
},
slice: function() {
return this.elements.slice.apply(this.elements, arguments);
},
addListener: function(eventName, handler, scope, opt) {
var els = this.elements,
len = els.length,
i, e;
for (i = 0; i < len; i++) {
e = els[i];
if (e) {
Ext.EventManager.on(e, eventName, handler, scope || e, opt);
}
}
return this;
},
each: function(fn, scope) {
var me  = this,
els = me.elements,
len = els.length,
i, e;
for (i = 0; i < len; i++) {
e = els[i];
if (e) {
e = this.getElement(e);
if (fn.call(scope || e, e, me, i) === false) {
break;
}
}
}
return me;
},
fill: function(els) {
var me = this;
me.elements = [];
me.add(els);
return me;
},
insert: function(index, nodes) {
Ext.Array.insert(this.elements, index, nodes);
},
filter: function(selector) {
var me  = this,
els = me.elements,
len = els.length,
out = [],
i = 0,
isFunc = typeof selector == 'function',
add,
el;
for (; i < len; i++) {
el = els[i];
add = false;
if (el) {
el = me.getElement(el);
if (isFunc) {
add = selector.call(el, el, me, i) !== false;
} else {
add = el.is(selector);
}
if (add) {
out.push(me.transformElement(el));
}
}
}
me.elements = out;
return me;
},
indexOf: function(el) {
return Ext.Array.indexOf(this.elements, this.transformElement(el));
},
replaceElement: function(el, replacement, domReplace) {
var index = !isNaN(el) ? el : this.indexOf(el),
d;
if (index > -1) {
replacement = Ext.getDom(replacement);
if (domReplace) {
d = this.elements[index];
d.parentNode.insertBefore(replacement, d);
Ext.removeNode(d);
}
Ext.Array.splice(this.elements, index, 1, replacement);
}
return this;
},
clear: function(removeDom) {
var me  = this,
els = me.elements,
i = els.length - 1;
if (removeDom) {
for (; i >= 0; i--) {
Ext.removeNode(els[i]);
}
}
this.elements = [];
},
addElements: function(els, root) {
if (!els) {
return this;
}
if (typeof els == "string") {
els = Ext.dom.Element.selectorFunction(els, root);
}
var yels = this.elements,
eLen = els.length,
e;
for (e = 0; e < eLen; e++) {
yels.push(Ext.get(els[e]));
}
return this;
},
first: function() {
return this.item(0);
},
last: function() {
return this.item(this.getCount() - 1);
},
contains: function(el) {
return this.indexOf(el) != -1;
},
removeElement: function(keys, removeDom) {
keys = [].concat(keys);
var me       = this,
elements = me.elements,
kLen     = keys.length,
val, el, k;
for (k = 0; k < kLen; k++) {
val = keys[k];
if ((el = (elements[val] || elements[val = me.indexOf(val)]))) {
if (removeDom) {
if (el.dom) {
el.remove();
} else {
Ext.removeNode(el);
}
}
Ext.Array.erase(elements, val, 1);
}
}
return me;
}
}, function() {
this.importElementMethods();
this.prototype.on = this.prototype.addListener;
if (Ext.DomQuery){
Ext.dom.Element.selectorFunction = Ext.DomQuery.select;
}
Ext.dom.Element.select = function(selector, root) {
var elements;
if (typeof selector == "string") {
elements = Ext.dom.Element.selectorFunction(selector, root);
}
else if (selector.length !== undefined) {
elements = selector;
}
else {
}
return new Ext.CompositeElementLite(elements);
};
Ext.select = function() {
return Ext.dom.Element.select.apply(Ext.dom.Element, arguments);
};
});
Ext.define('Ext.dom.CompositeElement', {
alternateClassName: 'Ext.CompositeElement',
extend:  Ext.dom.CompositeElementLite ,
getElement: function(el) {
return el;
},
transformElement: function(el) {
return Ext.get(el);
}
}, function() {
Ext.dom.Element.select = function(selector, unique, root) {
var elements;
if (typeof selector == "string") {
elements = Ext.dom.Element.selectorFunction(selector, root);
}
else if (selector.length !== undefined) {
elements = selector;
}
else {
}
return (unique === true) ? new Ext.CompositeElement(elements) : new Ext.CompositeElementLite(elements);
};
});
Ext.select = Ext.Element.select;
Ext.define('Ext.util.HashMap', {
mixins: {
observable:  Ext.util.Observable 
},
generation: 0,
constructor: function(config) {
config = config || {};
var me = this,
keyFn = config.keyFn;
me.initialConfig = config;
me.addEvents(
'add',
'clear',
'remove',
'replace'
);
me.mixins.observable.constructor.call(me, config);
me.clear(true);
if (keyFn) {
me.getKey = keyFn;
}
},
getCount: function() {
return this.length;
},
getData: function(key, value) {
if (value === undefined) {
value = key;
key = this.getKey(value);
}
return [key, value];
},
getKey: function(o) {
return o.id;
},
add: function(key, value) {
var me = this;
if (arguments.length === 1) {
value = key;
key = me.getKey(value);
}
if (me.containsKey(key)) {
return me.replace(key, value);
}
me.map[key] = value;
++me.length;
me.generation++;
if (me.hasListeners.add) {
me.fireEvent('add', me, key, value);
}
return value;
},
replace: function(key, value) {
var me = this,
map = me.map,
old;
if (arguments.length === 1) {
value = key;
key = me.getKey(value);
}
if (!me.containsKey(key)) {
me.add(key, value);
}
old = map[key];
map[key] = value;
me.generation++;
if (me.hasListeners.replace) {
me.fireEvent('replace', me, key, value, old);
}
return value;
},
remove: function(o) {
var key = this.findKey(o);
if (key !== undefined) {
return this.removeAtKey(key);
}
return false;
},
removeAtKey: function(key) {
var me = this,
value;
if (me.containsKey(key)) {
value = me.map[key];
delete me.map[key];
--me.length;
me.generation++;
if (me.hasListeners.remove) {
me.fireEvent('remove', me, key, value);
}
return true;
}
return false;
},
get: function(key) {
var map = this.map;
return map.hasOwnProperty(key) ? map[key] : undefined;
},
clear: function( initial) {
var me = this;
if (initial || me.generation) {
me.map = {};
me.length = 0;
me.generation = initial ? 0 : me.generation + 1;
}
if (initial !== true && me.hasListeners.clear) {
me.fireEvent('clear', me);
}
return me;
},
containsKey: function(key) {
var map = this.map;
return map.hasOwnProperty(key) && map[key] !== undefined;
},
contains: function(value) {
return this.containsKey(this.findKey(value));
},
getKeys: function() {
return this.getArray(true);
},
getValues: function() {
return this.getArray(false);
},
getArray: function(isKey) {
var arr = [],
key,
map = this.map;
for (key in map) {
if (map.hasOwnProperty(key)) {
arr.push(isKey ? key: map[key]);
}
}
return arr;
},
each: function(fn, scope) {
var items = Ext.apply({}, this.map),
key,
length = this.length;
scope = scope || this;
for (key in items) {
if (items.hasOwnProperty(key)) {
if (fn.call(scope, key, items[key], length) === false) {
break;
}
}
}
return this;
},
clone: function() {
var hash = new this.self(this.initialConfig),
map = this.map,
key;
hash.suspendEvents();
for (key in map) {
if (map.hasOwnProperty(key)) {
hash.add(key, map[key]);
}
}
hash.resumeEvents();
return hash;
},
findKey: function(value) {
var key,
map = this.map;
for (key in map) {
if (map.hasOwnProperty(key) && map[key] === value) {
return key;
}
}
return undefined;
}
});
Ext.define('Ext.AbstractManager', {
typeName: 'type',
constructor: function(config) {
Ext.apply(this, config || {});
this.all = new Ext.util.HashMap();
this.types = {};
},
get : function(id) {
return this.all.get(id);
},
register: function(item) {
this.all.add(item);
},
unregister: function(item) {
this.all.remove(item);
},
registerType : function(type, cls) {
this.types[type] = cls;
cls[this.typeName] = type;
},
isRegistered : function(type){
return this.types[type] !== undefined;
},
create: function(config, defaultType) {
var type        = config[this.typeName] || config.type || defaultType,
Constructor = this.types[type];
return new Constructor(config);
},
onAvailable : function(id, fn, scope){
var all = this.all,
item,
callback;
if (all.containsKey(id)) {
item = all.get(id);
fn.call(scope || item, item);
} else {
callback = function(map, key, item){
if (key == id) {
fn.call(scope || item, item);
all.un('add', callback);
}
}; 
all.on('add', callback);
}
},
each: function(fn, scope){
this.all.each(fn, scope || this);    
},
getCount: function(){
return this.all.getCount();
}
});
Ext.define('Ext.ComponentManager', {
extend:  Ext.AbstractManager ,
alternateClassName: 'Ext.ComponentMgr',
singleton: true,
typeName: 'xtype',
create: function(component, defaultType){
if (typeof component == 'string') {
return Ext.widget(component);
}
if (component.isComponent) {
return component;
}
return Ext.widget(component.xtype || defaultType, component);
},
registerType: function(type, cls) {
this.types[type] = cls;
cls[this.typeName] = type;
cls.prototype[this.typeName] = type;
}
},
function () {
Ext.getCmp = function(id) {
return Ext.ComponentManager.get(id);
};
});
Ext.define('Ext.ComponentQuery', {
singleton: true 
}, function() {
var cq = this,
domQueryOperators = Ext.dom.Query.operators,
nthRe = /(\d*)n\+?(\d*)/,
nthRe2 = /\D/,
filterFnPattern = [
'var r = [],',
'i = 0,',
'it = items,',
'l = it.length,',
'c;',
'for (; i < l; i++) {',
'c = it[i];',
'if (c.{0}) {',
'r.push(c);',
'}',
'}',
'return r;'
].join(''),
filterItems = function(items, operation) {
return operation.method.apply(this, [ items ].concat(operation.args));
},
getItems = function(items, mode) {
var result = [],
i = 0,
length = items.length,
candidate,
deep = mode !== '>';
for (; i < length; i++) {
candidate = items[i];
if (candidate.getRefItems) {
result = result.concat(candidate.getRefItems(deep));
}
}
return result;
},
getAncestors = function(items) {
var result = [],
i = 0,
length = items.length,
candidate;
for (; i < length; i++) {
candidate = items[i];
while (!!(candidate = candidate.getRefOwner())) {
result.push(candidate);
}
}
return result;
},
filterByXType = function(items, xtype, shallow) {
if (xtype === '*') {
return items.slice();
}
else {
var result = [],
i = 0,
length = items.length,
candidate;
for (; i < length; i++) {
candidate = items[i];
if (candidate.isXType(xtype, shallow)) {
result.push(candidate);
}
}
return result;
}
},
filterByClassName = function(items, className) {
var result = [],
i = 0,
length = items.length,
candidate;
for (; i < length; i++) {
candidate = items[i];
if (candidate.hasCls(className)) {
result.push(candidate);
}
}
return result;
},
filterByAttribute = function(items, property, operator, compareTo) {
var result = [],
i = 0,
length = items.length,
mustBeOwnProperty,
presenceOnly,
candidate, propValue,
j, propLen;
if (property.charAt(0) === '@') {
mustBeOwnProperty = true;
property = property.substr(1);
}
if (property.charAt(0) === '?') {
mustBeOwnProperty = true;
presenceOnly = true;
property = property.substr(1);
}
for (; i < length; i++) {
candidate = items[i];
if (!mustBeOwnProperty || candidate.hasOwnProperty(property)) {
propValue = candidate[property];
if (presenceOnly) {
result.push(candidate);
}
else if (operator === '~=') {
if (propValue) {
if (!Ext.isArray(propValue)) {
propValue = propValue.split(' ');
}
for (j = 0, propLen = propValue.length; j < propLen; j++) {
if (domQueryOperators[operator](Ext.coerce(propValue[j], compareTo), compareTo)) {
result.push(candidate);
break;
}
}
}
} else if (!compareTo ? !!candidate[property] : domQueryOperators[operator](Ext.coerce(propValue, compareTo), compareTo)) {
result.push(candidate);
}
}
}
return result;
},
filterById = function(items, id) {
var result = [],
i = 0,
length = items.length,
candidate;
for (; i < length; i++) {
candidate = items[i];
if (candidate.getItemId() === id) {
result.push(candidate);
}
}
return result;
},
filterByPseudo = function(items, name, value) {
return cq.pseudos[name](items, value);
},
modeRe = /^(\s?([>\^])\s?|\s|$)/,
tokenRe = /^(#)?([\w\-]+|\*)(?:\((true|false)\))?/,
matchers = [{
re: /^\.([\w\-]+)(?:\((true|false)\))?/,
method: filterByXType
}, {
re: /^(?:\[((?:[@?$])?[\w\-]*)\s*(?:([\^$*~%!]?=)\s*['"]?(.*?)["']?)?\])/,
method: filterByAttribute
}, {
re: /^#([\w\-]+)/,
method: filterById
}, {
re: /^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/,
method: filterByPseudo
}, {
re: /^(?:\{([^\}]+)\})/,
method: filterFnPattern
}];
cq.Query = Ext.extend(Object, {
constructor: function(cfg) {
cfg = cfg || {};
Ext.apply(this, cfg);
},
execute : function(root) {
var operations = this.operations,
i = 0,
length = operations.length,
operation,
workingItems;
if (!root) {
workingItems = Ext.ComponentManager.all.getArray();
}
else if (Ext.isIterable(root)) {
workingItems = root;
}
else if (root.isMixedCollection) {
workingItems = root.items;
}
for (; i < length; i++) {
operation = operations[i];
if (operation.mode === '^') {
workingItems = getAncestors(workingItems || [root]);
}
else if (operation.mode) {
workingItems = getItems(workingItems || [root], operation.mode);
}
else {
workingItems = filterItems(workingItems || getItems([root]), operation);
}
if (i === length -1) {
return workingItems;
}
}
return [];
},
is: function(component) {
var operations = this.operations,
len = operations.length,
active = [component],
operation, i, j, mode, matches, items, item;
for (i = len - 1; i >= 0; --i) {
operation = operations[i];
mode = operation.mode;
if (mode) {
if (mode === '^') {
active = getItems(active, ' ');
} else if (mode === '>') {
items = [];
for (j = 0, len = active.length; j < len; ++j) {
item = active[j].getRefOwner();
if (item) {
items.push(item);
}
}
active = items;
} else {
active = getAncestors(active);
}
if (active.length === 0) {
return false;
}
} else {
active = filterItems(active, operation);
if (active.length === 0) {
return false;
}
}
}
return true;
},
getMatches: function(components, operations) {
var len = operations.length,
i;
for (i = 0; i < len; ++i) {
components = filterItems(components, operations[i]);
if (components.length === 0) {
break;
}  
}
return components;
}
});
Ext.apply(this, {
cache: {},
pseudos: {
not: function(components, selector){
var CQ = Ext.ComponentQuery,
i = 0,
length = components.length,
results = [],
index = -1,
component;
for(; i < length; ++i) {
component = components[i];
if (!CQ.is(component, selector)) {
results[++index] = component;
}
}
return results;
},
first: function(components) {
var ret = [];
if (components.length > 0) {
ret.push(components[0]);
}
return ret;       
},
last: function(components) {
var len = components.length,
ret = [];
if (len > 0) {
ret.push(components[len - 1]);
}
return ret;
},
focusable: function(cmps) {
var len = cmps.length,
results = [],
i = 0,
c;
for (; i < len; i++) {
c = cmps[i];
if (c.isFocusable()) {
results.push(c);
}
}
return results;
},
"nth-child" : function(c, a) {
var result = [],
m = nthRe.exec(a == "even" && "2n" || a == "odd" && "2n+1" || !nthRe2.test(a) && "n+" + a || a),
f = (m[1] || 1) - 0, l = m[2] - 0,
i, n, nodeIndex;
for (i = 0; n = c[i]; i++) {
nodeIndex = i + 1;
if (f == 1) {
if (l == 0 || nodeIndex == l) {
result.push(n);
}
} else if ((nodeIndex + l) % f == 0){
result.push(n);
}
}
return result;
}
},
query: function(selector, root) {
var selectors = selector.split(','),
length = selectors.length,
i = 0,
results = [],
noDupResults = [], 
dupMatcher = {}, 
query, resultsLn, cmp;
for (; i < length; i++) {
selector = Ext.String.trim(selectors[i]);
query = this.cache[selector] || (this.cache[selector] = this.parse(selector));
results = results.concat(query.execute(root));
}
if (length > 1) {
resultsLn = results.length;
for (i = 0; i < resultsLn; i++) {
cmp = results[i];
if (!dupMatcher[cmp.id]) {
noDupResults.push(cmp);
dupMatcher[cmp.id] = true;
}
}
results = noDupResults;
}
return results;
},
is: function(component, selector) {
if (!selector) {
return true;
}
var selectors = selector.split(','),
length = selectors.length,
i = 0,
query;
for (; i < length; i++) {
selector = Ext.String.trim(selectors[i]);
query = this.cache[selector] || (this.cache[selector] = this.parse(selector));
if (query.is(component)) {
return true;
}
}
return false;
},
parse: function(selector) {
var operations = [],
length = matchers.length,
lastSelector,
tokenMatch,
matchedChar,
modeMatch,
selectorMatch,
i, matcher, method;
while (selector && lastSelector !== selector) {
lastSelector = selector;
tokenMatch = selector.match(tokenRe);
if (tokenMatch) {
matchedChar = tokenMatch[1];
if (matchedChar === '#') {
operations.push({
method: filterById,
args: [Ext.String.trim(tokenMatch[2])]
});
}
else if (matchedChar === '.') {
operations.push({
method: filterByClassName,
args: [Ext.String.trim(tokenMatch[2])]
});
}
else {
operations.push({
method: filterByXType,
args: [Ext.String.trim(tokenMatch[2]), Boolean(tokenMatch[3])]
});
}
selector = selector.replace(tokenMatch[0], '');
}
while (!(modeMatch = selector.match(modeRe))) {
for (i = 0; selector && i < length; i++) {
matcher = matchers[i];
selectorMatch = selector.match(matcher.re);
method = matcher.method;
if (selectorMatch) {
operations.push({
method: Ext.isString(matcher.method)
? Ext.functionFactory('items', Ext.String.format.apply(Ext.String, [method].concat(selectorMatch.slice(1))))
: matcher.method,
args: selectorMatch.slice(1)
});
selector = selector.replace(selectorMatch[0], '');
break; 
}
if (i === (length - 1)) {
Ext.Error.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"');
}
}
}
if (modeMatch[1]) { 
operations.push({
mode: modeMatch[2]||modeMatch[1]
});
selector = selector.replace(modeMatch[0], '');
}
}
return new cq.Query({
operations: operations
});
}
});
});
Ext.define('Ext.util.ProtoElement', (function () {
var splitWords = Ext.String.splitWords,
toMap = Ext.Array.toMap;
return {
isProtoEl: true,
clsProp: 'cls',
styleProp: 'style',
removedProp: 'removed',
styleIsText: false,
constructor: function (config) {
var me = this;
Ext.apply(me, config);
me.classList = splitWords(me.cls);
me.classMap = toMap(me.classList);
delete me.cls;
if (Ext.isFunction(me.style)) {
me.styleFn = me.style;
delete me.style;
} else if (typeof me.style == 'string') {
me.style = Ext.Element.parseStyles(me.style);
} else if (me.style) {
me.style = Ext.apply({}, me.style); 
}
},
flush: function(){
this.flushClassList = [];
this.removedClasses = {};
delete this.style;
delete this.unselectableAttr;
},
addCls: function (cls) {
var me = this,
add = (typeof cls === 'string') ? splitWords(cls) : cls,
length = add.length,
list = me.classList,
map = me.classMap,
flushList = me.flushClassList,
i = 0,
c;
for (; i < length; ++i) {
c = add[i];
if (!map[c]) {
map[c] = true;
list.push(c);
if (flushList) {
flushList.push(c);
delete me.removedClasses[c];
}
}
}
return me;
},
hasCls: function (cls) {
return cls in this.classMap;
},
removeCls: function (cls) {
var me = this,
list = me.classList,
newList = (me.classList = []),
remove = toMap(splitWords(cls)),
length = list.length,
map = me.classMap,
removedClasses = me.removedClasses,
i, c;
for (i = 0; i < length; ++i) {
c = list[i];
if (remove[c]) {
if (removedClasses) {
if (map[c]) {
removedClasses[c] = true;
Ext.Array.remove(me.flushClassList, c);
}
}
delete map[c];
} else {
newList.push(c);
}
}
return me;
},
setStyle: function (prop, value) {
var me = this,
style = me.style || (me.style = {});
if (typeof prop == 'string') {
if (arguments.length === 1) {
me.setStyle(Ext.Element.parseStyles(prop));
} else {
style[prop] = value;
}
} else {
Ext.apply(style, prop);
}
return me;
},
unselectable: function() {
this.addCls(Ext.dom.Element.unselectableCls);
if (Ext.isOpera) {
this.unselectableAttr = true;
}
},
writeTo: function (to) {
var me = this,
classList = me.flushClassList || me.classList,
removedClasses = me.removedClasses,
style;
if (me.styleFn) {
style = Ext.apply({}, me.styleFn());
Ext.apply(style, me.style);
} else {
style = me.style;
}
to[me.clsProp] = classList.join(' ');
if (style) {
to[me.styleProp] = me.styleIsText ? Ext.DomHelper.generateStyles(style, null, true) : style;
}
if (removedClasses) {
removedClasses = Ext.Object.getKeys(removedClasses);
if (removedClasses.length) {
to[me.removedProp] = removedClasses.join(' ');
}
}
if (me.unselectableAttr) {
to.unselectable = 'on';
}
return to;
}
};
}()));
Ext.define('Ext.PluginManager', {
extend:  Ext.AbstractManager ,
alternateClassName: 'Ext.PluginMgr',
singleton: true,
typeName: 'ptype',
create : function(config, defaultType, host) {
var result;
if (config.init) {
result = config;
} else {
if (host) {
config = Ext.apply({}, config); 
config.cmp = host;
}
else {
host = config.cmp;
}
if (config.xclass) {
result = Ext.create(config);
} else {
result = Ext.ClassManager.getByAlias(('plugin.' + (config.ptype || defaultType)));
if (typeof result === 'function') {
result = new result(config);
}
}
}
if (result && host && result.setCmp && !result.setCmpCalled) {
result.setCmp(host);
result.setCmpCalled = true;
}
return result;
},
findByType: function(type, defaultsOnly) {
var matches = [],
types   = this.types,
name,
item;
for (name in types) {
if (!types.hasOwnProperty(name)) {
continue;
}
item = types[name];
if (item.type == type && (!defaultsOnly || (defaultsOnly === true && item.isDefault))) {
matches.push(item);
}
}
return matches;
}
}, function() {
Ext.preg = function() {
return Ext.PluginManager.registerType.apply(Ext.PluginManager, arguments);
};
});
Ext.define('Ext.util.Filter', {
id: null,
anyMatch: false,
exactMatch: false,
caseSensitive: false,
disabled: false,
operator: null,
statics: {
createFilterFn: function(filters) {
return filters && filters.length ? function(candidate) {
var isMatch = true,
length = filters.length,
i, filter;
for (i = 0; isMatch && i < length; i++) {
filter = filters[i];
if (!filter.disabled) {
isMatch = isMatch && filter.filterFn.call(filter.scope || filter, candidate);
}
}
return isMatch;
} : function() {
return true;
};
}
},
operatorFns: {
"<": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) < this.value;
},
"<=": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) <= this.value;
},
"=": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) == this.value;
},
">=": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) >= this.value;
},
">": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) > this.value;
},
"!=": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) != this.value;
}
},
constructor: function(config) {
var me = this;
me.initialConfig = config;
Ext.apply(me, config);
me.filter = me.filter || me.filterFn;
if (me.filter === undefined) {
me.setValue(config.value);
}
},
setValue: function(value) {
var me = this;
me.value = value;
if (me.property === undefined || me.value === undefined) {
} else {
me.filter = me.createFilterFn();
}
me.filterFn = me.filter;
},
setFilterFn: function(filterFn) {
this.filterFn = this.filter = filterFn;
},
createFilterFn: function() {
var me       = this,
matcher  = me.createValueMatcher(),
property = me.property;
if (me.operator) {
return me.operatorFns[me.operator];
} else {
return function(item) {
var value = me.getRoot(item)[property];
return matcher === null ? value === null : matcher.test(value);
};
}
},
getRoot: function(item) {
var root = this.root;
return root === undefined ? item : item[root];
},
createValueMatcher : function() {
var me            = this,
value         = me.value,
anyMatch      = me.anyMatch,
exactMatch    = me.exactMatch,
caseSensitive = me.caseSensitive,
escapeRe      = Ext.String.escapeRegex;
if (value === null) {
return value;
}
if (!value.exec) { 
value = String(value);
if (anyMatch === true) {
value = escapeRe(value);
} else {
value = '^' + escapeRe(value);
if (exactMatch === true) {
value += '$';
}
}
value = new RegExp(value, caseSensitive ? '' : 'i');
}
return value;
},
serialize: function() {
var me = this,
result = Ext.apply({}, me.initialConfig);
result.value = me.value;
return result;
}
}, function() {
this.prototype.operatorFns['=='] = this.prototype.operatorFns['='];
});
Ext.define('Ext.util.AbstractMixedCollection', {
mixins: {
observable:  Ext.util.Observable 
},
isMixedCollection: true,
generation: 0,
indexGeneration: 0,
constructor: function(allowFunctions, keyFn) {
var me = this;
if (arguments.length === 1 && Ext.isObject(allowFunctions)) {
me.initialConfig = allowFunctions;
Ext.apply(me, allowFunctions);
}
else {
me.allowFunctions = allowFunctions === true;
if (keyFn) {
me.getKey = keyFn;
}
me.initialConfig = {
allowFunctions: me.allowFunctions,
getKey: me.getKey
};
}
me.items = [];
me.map = {};
me.keys = [];
me.indexMap = {};
me.length = 0;
me.mixins.observable.constructor.call(me);
},
allowFunctions : false,
add : function(key, obj) {
var len = this.length,
out;
if (arguments.length === 1) {
out = this.insert(len, key);
} else {
out = this.insert(len, key, obj);
}
return out;
},
getKey : function(o) {
return o.id;
},
replace : function(key, o) {
var me = this,
old,
index;
if (arguments.length == 1) {
o = arguments[0];
key = me.getKey(o);
}
old = me.map[key];
if (typeof key == 'undefined' || key === null || typeof old == 'undefined') {
return me.add(key, o);
}
me.generation++;
index = me.indexOfKey(key);
me.items[index] = o;
me.map[key] = o;
if (me.hasListeners.replace) {
me.fireEvent('replace', key, old, o);
}
return o;
},
updateKey: function(oldKey, newKey) {
var me = this,
map = me.map,
index = me.indexOfKey(oldKey),
indexMap = me.indexMap,
item;
if (index > -1) {
item = map[oldKey];
delete map[oldKey];
delete indexMap[oldKey];
map[newKey] = item;
indexMap[newKey] = index;
me.keys[index] = newKey;
me.indexGeneration = ++me.generation;
}
},
addAll : function(objs) {
var me = this,
key;
if (arguments.length > 1 || Ext.isArray(objs)) {
me.insert(me.length, arguments.length > 1 ? arguments : objs);
} else {
for (key in objs) {
if (objs.hasOwnProperty(key)) {
if (me.allowFunctions || typeof objs[key] != 'function') {
me.add(key, objs[key]);
}
}
}
}
},
each : function(fn, scope){
var items = Ext.Array.push([], this.items), 
i = 0,
len = items.length,
item;
for (; i < len; i++) {
item = items[i];
if (fn.call(scope || item, item, i, len) === false) {
break;
}
}
},
eachKey : function(fn, scope){
var keys = this.keys,
items = this.items,
i = 0,
len = keys.length;
for (; i < len; i++) {
fn.call(scope || window, keys[i], items[i], i, len);
}
},
findBy : function(fn, scope) {
var keys = this.keys,
items = this.items,
i = 0,
len = items.length;
for (; i < len; i++) {
if (fn.call(scope || window, items[i], keys[i])) {
return items[i];
}
}
return null;
},
find : function() {
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.warn('Ext.util.MixedCollection: find has been deprecated. Use findBy instead.');
}
return this.findBy.apply(this, arguments);
},
insert : function(index, key, obj) {
var out;
if (Ext.isIterable(key)) {
out = this.doInsert(index, key, obj);
} else {
if (arguments.length > 2) {
out = this.doInsert(index, [key], [obj]);
} else {
out = this.doInsert(index, [key]);
}
out = out[0];
}
return out;
},
doInsert : function(index, keys, objects) {
var me = this,
itemKey,
removeIndex,
i, len = keys.length,
deDupedLen = len,
fireAdd = me.hasListeners.add,
syncIndices,
newKeys = {},
passedDuplicates,
oldKeys, oldObjects;
if (objects != null) {
me.useLinearSearch = true;
}
else {
objects = keys;
keys = new Array(len);
for (i = 0; i < len; i++) {
keys[i] = this.getKey(objects[i]);
}
}
me.suspendEvents();
for (i = 0; i < len; i++) {
itemKey = keys[i];
removeIndex = me.indexOfKey(itemKey);
if (removeIndex !== -1) {
if (removeIndex < index) {
index--;
}
me.removeAt(removeIndex);
}
if (itemKey != null) {
if (newKeys[itemKey] != null) {
passedDuplicates = true;
deDupedLen--;
}
newKeys[itemKey] = i;
}
}
me.resumeEvents();
if (passedDuplicates) {
oldKeys = keys;
oldObjects = objects;
keys = new Array(deDupedLen);
objects = new Array(deDupedLen);
i = 0;
for (itemKey in newKeys) {
keys[i] = oldKeys[newKeys[itemKey]];
objects[i] = oldObjects[newKeys[itemKey]];
i++;
}
len = deDupedLen;
}
syncIndices = index === me.length && me.indexGeneration === me.generation;
Ext.Array.insert(me.items, index, objects);
Ext.Array.insert(me.keys,  index, keys);
me.length += len;
me.generation++;
if (syncIndices) {
me.indexGeneration = me.generation;
}
for (i = 0; i < len; i++, index++) {
itemKey = keys[i];
if (itemKey != null) {
me.map[itemKey] = objects[i];
if (syncIndices) {
me.indexMap[itemKey] = index;
}
}
if (fireAdd) {
me.fireEvent('add', index, objects[i], itemKey);
}
}
return objects;
},
remove : function(o) {
var me = this,
removeKey,
index;
if (!me.useLinearSearch && (removeKey = me.getKey(o))) {
index = me.indexOfKey(removeKey);
}
else {
index = Ext.Array.indexOf(me.items, o);
}
return (index === -1) ? false : me.removeAt(index);
},
removeAll : function(items) {
var me = this, 
i;
if (items || me.hasListeners.remove) {
if (items) {
for (i = items.length - 1; i >= 0; --i) {
me.remove(items[i]);
}
} else {
while (me.length) {
me.removeAt(0);
}
}
} else {
me.length = me.items.length = me.keys.length = 0;
me.map = {};
me.indexMap = {};
me.generation++;
me.indexGeneration = me.generation;
}
},
removeAt : function(index) {
var me = this,
o,
key;
if (index < me.length && index >= 0) {
me.length--;
o = me.items[index];
Ext.Array.erase(me.items, index, 1);
key = me.keys[index];
if (typeof key != 'undefined') {
delete me.map[key];
}
Ext.Array.erase(me.keys, index, 1);
if (me.hasListeners.remove) {
me.fireEvent('remove', o, key);
}
me.generation++;
return o;
}
return false;
},
removeRange : function(index, removeCount) {
var me = this,
o,
key,
i,
limit,
syncIndices,
trimming;
if (index < me.length && index >= 0) {
if (!removeCount) {
removeCount = 1;
}
limit = Math.min(index + removeCount, me.length);
removeCount = limit - index;
trimming = limit === me.length;
syncIndices = trimming && me.indexGeneration === me.generation;
for (i = index; i < limit; i++) {
key = me.keys[i];
if (key != null) {
delete me.map[key];
if (syncIndices) {
delete me.indexMap[key];
}
}
}
o = me.items[i - 1];
me.length -= removeCount;
me.generation++;
if (syncIndices) {
me.indexGeneration = me.generation;
}
if (trimming) {
me.items.length = me.keys.length = me.length;
} else {
me.items.splice(index, removeCount);
me.keys.splice(index, removeCount);
}
return o;
}
return false;
},
removeAtKey : function(key) {
var me = this,
keys = me.keys,
i;
if (key == null) {
for (i = keys.length - 1; i >=0; i--) {
if (keys[i] == null) {
me.removeAt(i);
}
}
}
else {
return me.removeAt(me.indexOfKey(key));
}
},
getCount : function() {
return this.length;
},
indexOf : function(o) {
var me = this,
key;
if (o != null) {
if (!me.useLinearSearch && (key = me.getKey(o))) {
return this.indexOfKey(key);
}
return Ext.Array.indexOf(me.items, o);
}
return -1;
},
indexOfKey : function(key) {
if (!this.map.hasOwnProperty(key)) {
return -1;
}
if (this.indexGeneration !== this.generation) {
this.rebuildIndexMap();
}
return this.indexMap[key];
},
rebuildIndexMap: function() {
var me = this,
indexMap = me.indexMap = {},
keys = me.keys,
len = keys.length,
i;
for (i = 0; i < len; i++) {
indexMap[keys[i]] = i;
}
me.indexGeneration = me.generation;
},
get : function(key) {
var me = this,
mk = me.map[key],
item = mk !== undefined ? mk : (typeof key == 'number') ? me.items[key] : undefined;
return typeof item != 'function' || me.allowFunctions ? item : null; 
},
getAt : function(index) {
return this.items[index];
},
getByKey : function(key) {
return this.map[key];
},
contains : function(o) {
var me = this,
key;
if (o != null) {
if (!me.useLinearSearch && (key = me.getKey(o))) {
return this.map[key] != null;
}
return Ext.Array.indexOf(this.items, o) !== -1;
}
return false;
},
containsKey : function(key) {
return this.map.hasOwnProperty(key);
},
clear : function() {
var me = this;
if (me.generation) {
me.length = 0;
me.items = [];
me.keys = [];
me.map = {};
me.indexMap = {};
me.generation++;
me.indexGeneration = me.generation;
}
if (me.hasListeners.clear) {
me.fireEvent('clear');
}
},
first : function() {
return this.items[0];
},
last : function() {
return this.items[this.length - 1];
},
sum: function(property, root, start, end) {
var values = this.extractValues(property, root),
length = values.length,
sum    = 0,
i;
start = start || 0;
end   = (end || end === 0) ? end : length - 1;
for (i = start; i <= end; i++) {
sum += values[i];
}
return sum;
},
collect: function(property, root, allowNull) {
var values = this.extractValues(property, root),
length = values.length,
hits   = {},
unique = [],
value, strValue, i;
for (i = 0; i < length; i++) {
value = values[i];
strValue = String(value);
if ((allowNull || !Ext.isEmpty(value)) && !hits[strValue]) {
hits[strValue] = true;
unique.push(value);
}
}
return unique;
},
extractValues: function(property, root) {
var values = this.items;
if (root) {
values = Ext.Array.pluck(values, root);
}
return Ext.Array.pluck(values, property);
},
hasRange: function(start, end) {
return (end < this.length);
},
getRange : function(start, end){
var me = this,
items = me.items,
range = [],
len = items.length,
tmp, reverse;
if (len < 1) {
return range;
}
if (start > end) {
reverse = true;
tmp = start;
start = end;
end = tmp;
}
if (start < 0) {
start = 0;
}
if (end == null || end >= len) {
end = len - 1;    
}
range = items.slice(start, end + 1);
if (reverse && range.length) {
range.reverse();
}
return range;
},
filter : function(property, value, anyMatch, caseSensitive) {
var filters = [];
if (Ext.isString(property)) {
filters.push(new Ext.util.Filter({
property     : property,
value        : value,
anyMatch     : anyMatch,
caseSensitive: caseSensitive
}));
} else if (Ext.isArray(property) || property instanceof Ext.util.Filter) {
filters = filters.concat(property);
}
return this.filterBy(Ext.util.Filter.createFilterFn(filters));
},
filterBy : function(fn, scope) {
var me = this,
newMC  = new me.self(me.initialConfig),
keys   = me.keys,
items  = me.items,
length = items.length,
i;
newMC.getKey = me.getKey;
for (i = 0; i < length; i++) {
if (fn.call(scope || me, items[i], keys[i])) {
newMC.add(keys[i], items[i]);
}
}
newMC.useLinearSearch = me.useLinearSearch;
return newMC;
},
findIndex : function(property, value, start, anyMatch, caseSensitive){
if(Ext.isEmpty(value, false)){
return -1;
}
value = this.createValueMatcher(value, anyMatch, caseSensitive);
return this.findIndexBy(function(o){
return o && value.test(o[property]);
}, null, start);
},
findIndexBy : function(fn, scope, start){
var me = this,
keys = me.keys,
items = me.items,
i = start || 0,
len = items.length;
for (; i < len; i++) {
if (fn.call(scope || me, items[i], keys[i])) {
return i;
}
}
return -1;
},
createValueMatcher : function(value, anyMatch, caseSensitive, exactMatch) {
if (!value.exec) { 
var er = Ext.String.escapeRegex;
value = String(value);
if (anyMatch === true) {
value = er(value);
} else {
value = '^' + er(value);
if (exactMatch === true) {
value += '$';
}
}
value = new RegExp(value, caseSensitive ? '' : 'i');
}
return value;
},
clone : function() {
var me = this,
copy = new me.self(me.initialConfig);
copy.add(me.keys, me.items);
copy.useLinearSearch = me.useLinearSearch;
return copy;
}
});
Ext.define('Ext.util.Sorter', {
direction: "ASC",
constructor: function(config) {
var me = this;
Ext.apply(me, config);
me.updateSortFunction();
},
createSortFunction: function(sorterFn) {
var me        = this,
direction = me.direction || "ASC",
modifier  = direction.toUpperCase() == "DESC" ? -1 : 1;
return function(o1, o2) {
return modifier * sorterFn.call(me, o1, o2);
};
},
defaultSorterFn: function(o1, o2) {
var me = this,
transform = me.transform,
v1 = me.getRoot(o1)[me.property],
v2 = me.getRoot(o2)[me.property];
if (transform) {
v1 = transform(v1);
v2 = transform(v2);
}
return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
},
getRoot: function(item) {
return this.root === undefined ? item : item[this.root];
},
setDirection: function(direction) {
var me = this;
me.direction = direction ? direction.toUpperCase() : direction;
me.updateSortFunction();
},
toggle: function() {
var me = this;
me.direction = Ext.String.toggle(me.direction, "ASC", "DESC");
me.updateSortFunction();
},
updateSortFunction: function(fn) {
var me = this;
fn = fn || me.sorterFn || me.defaultSorterFn;
me.sort = me.createSortFunction(fn);
},
serialize: function() {
return {
root: this.root,
property: this.property,
direction: this.direction
};
}
});
Ext.define("Ext.util.Sortable", {
isSortable: true,
defaultSortDirection: "ASC",
statics: {
createComparator: function(sorters) {
return sorters && sorters.length ? function(r1, r2) {
var result = sorters[0].sort(r1, r2),
length = sorters.length,
i = 1;
for (; i < length; i++) {
result = result || sorters[i].sort.call(this, r1, r2);
}
return result;
}: function() {
return 0;
};
}
},
initSortable: function() {
var me = this,
sorters = me.sorters;
me.sorters = new Ext.util.AbstractMixedCollection(false, function(item) {
return item.id || item.property;
});
if (sorters) {
me.sorters.addAll(me.decodeSorters(sorters));
}
},
sort: function(sorters, direction, where, doSort) {
var me = this,
sorter,
newSorters;
if (Ext.isArray(sorters)) {
doSort = where;
where = direction;
newSorters = sorters;
}
else if (Ext.isObject(sorters)) {
doSort = where;
where = direction;
newSorters = [sorters];
}
else if (Ext.isString(sorters)) {
sorter = me.sorters.get(sorters);
if (!sorter) {
sorter = {
property : sorters,
direction: direction
};
newSorters = [sorter];
}
else if (direction === undefined) {
sorter.toggle();
}
else {
sorter.setDirection(direction);
}
}
if (newSorters && newSorters.length) {
newSorters = me.decodeSorters(newSorters);
if (Ext.isString(where)) {
if (where === 'prepend') {
me.sorters.insert(0, newSorters);
}
else {
me.sorters.addAll(newSorters);
}
}
else {
me.sorters.clear();
me.sorters.addAll(newSorters);
}
}
if (doSort !== false) {
me.fireEvent('beforesort', me, newSorters);
me.onBeforeSort(newSorters);
sorters = me.sorters.items;
if (sorters.length) {
me.doSort(me.generateComparator());
}
}
return sorters;
},
generateComparator: function() {
var sorters = this.sorters.getRange();
return sorters.length ? this.createComparator(sorters) : this.emptyComparator;
},
emptyComparator: function(){
return 0;
},
onBeforeSort: Ext.emptyFn,
decodeSorters: function(sorters) {
if (!Ext.isArray(sorters)) {
if (sorters === undefined) {
sorters = [];
} else {
sorters = [sorters];
}
}
var length = sorters.length,
Sorter = Ext.util.Sorter,
fields = this.model ? this.model.prototype.fields : null,
field,
config, i;
for (i = 0; i < length; i++) {
config = sorters[i];
if (!(config instanceof Sorter)) {
if (Ext.isString(config)) {
config = {
property: config
};
}
Ext.applyIf(config, {
root     : this.sortRoot,
direction: "ASC"
});
if (config.fn) {
config.sorterFn = config.fn;
}
if (typeof config == 'function') {
config = {
sorterFn: config
};
}
if (fields && !config.transform) {
field = fields.get(config.property);
config.transform = field && field.sortType !== Ext.identityFn ? field.sortType : undefined;
}
sorters[i] = new Ext.util.Sorter(config);
}
}
return sorters;
},
getSorters: function() {
return this.sorters.items;
},
getFirstSorter: function(){
var sorters = this.sorters.items,
len = sorters.length,
i = 0,
sorter;
for (; i < len; ++i) {
sorter = sorters[i];
if (!sorter.isGrouper) {
return sorter;    
}
}
return null;
}
}, function() {
this.prototype.createComparator = this.createComparator;
});
Ext.define('Ext.util.MixedCollection', {
extend:  Ext.util.AbstractMixedCollection ,
mixins: {
sortable:  Ext.util.Sortable 
},
constructor: function() {
var me = this;
me.callParent(arguments);
me.addEvents('sort');
me.mixins.sortable.initSortable.call(me);
},
doSort: function(sorterFn) {
this.sortBy(sorterFn);
},
_sort : function(property, dir, fn) {
var me = this,
i, len,
dsc   = String(dir).toUpperCase() == 'DESC' ? -1 : 1,
c     = [],
keys  = me.keys,
items = me.items,
o;
fn = fn || function(a, b) {
return a - b;
};
for (i = 0, len = items.length; i < len; i++) {
c[c.length] = {
key  : keys[i],
value: items[i],
index: i
};
}
Ext.Array.sort(c, function(a, b) {
return fn(a[property], b[property]) * dsc ||
(a.index < b.index ? -1 : 1);
});
for (i = 0, len = c.length; i < len; i++) {
o = c[i];
items[i] = o.value;
keys[i]  = o.key;
me.indexMap[o.key] = i;
}
me.generation++;
me.indexGeneration = me.generation;
me.fireEvent('sort', me);
},
sortBy: function(sorterFn) {
var me     = this,
items  = me.items,
item,
keys   = me.keys,
key,
length = items.length,
i;
for (i = 0; i < length; i++) {
items[i].$extCollectionIndex = i;
}
Ext.Array.sort(items, function(a, b) {
return sorterFn(a, b) ||
(a.$extCollectionIndex < b.$extCollectionIndex ? -1 : 1);
});
for (i = 0; i < length; i++) {
item = items[i];
key = me.getKey(item);
keys[i] = key;
me.indexMap[key] = i;
delete items.$extCollectionIndex;
}
me.generation++;
me.indexGeneration = me.generation;
me.fireEvent('sort', me, items, keys);
},
findInsertionIndex: function(newItem, sorterFn) {
var me    = this,
items = me.items,
start = 0,
end   = items.length - 1,
middle,
comparison;
if (!sorterFn) {
sorterFn = me.generateComparator();
}
while (start <= end) {
middle = (start + end) >> 1;
comparison = sorterFn(newItem, items[middle]);
if (comparison >= 0) {
start = middle + 1;
} else if (comparison < 0) {
end = middle - 1;
}
}
return start;
},
reorder: function(mapping) {
var me = this,
items = me.items,
index = 0,
length = items.length,
order = [],
remaining = [],
oldIndex;
me.suspendEvents();
for (oldIndex in mapping) {
order[mapping[oldIndex]] = items[oldIndex];
}
for (index = 0; index < length; index++) {
if (mapping[index] == undefined) {
remaining.push(items[index]);
}
}
for (index = 0; index < length; index++) {
if (order[index] == undefined) {
order[index] = remaining.shift();
}
}
me.clear();
me.addAll(order);
me.resumeEvents();
me.fireEvent('sort', me);
},
sortByKey : function(dir, fn){
this._sort('key', dir, fn || function(a, b){
var v1 = String(a).toUpperCase(), v2 = String(b).toUpperCase();
return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
});
}
});
Ext.define('Ext.fx.target.Target', {
isAnimTarget: true,
constructor: function(target) {
this.target = target;
this.id = this.getId();
},
getId: function() {
return this.target.id;
},
remove: function() {
Ext.destroy(this.target);
}
});
Ext.define('Ext.fx.target.Element', {
extend:  Ext.fx.target.Target ,
type: 'element',
getElVal: function(el, attr, val) {
if (val == undefined) {
if (attr === 'x') {
val = el.getX();
} else if (attr === 'y') {
val = el.getY();
} else if (attr === 'scrollTop') {
val = el.getScroll().top;
} else if (attr === 'scrollLeft') {
val = el.getScroll().left;
} else if (attr === 'height') {
val = el.getHeight();
} else if (attr === 'width') {
val = el.getWidth();
} else {
val = el.getStyle(attr);
}
}
return val;
},
getAttr: function(attr, val) {
var el = this.target;
return [[ el, this.getElVal(el, attr, val)]];
},
setAttr: function(targetData) {
var target = this.target,
ln = targetData.length,
attrs, attr, o, i, j, ln2;
for (i = 0; i < ln; i++) {
attrs = targetData[i].attrs;
for (attr in attrs) {
if (attrs.hasOwnProperty(attr)) {
ln2 = attrs[attr].length;
for (j = 0; j < ln2; j++) {
o = attrs[attr][j];
this.setElVal(o[0], attr, o[1]);
}
}
}
}
},
setElVal: function(element, attr, value){
if (attr === 'x') {
element.setX(value);
} else if (attr === 'y') {
element.setY(value);
} else if (attr === 'scrollTop') {
element.scrollTo('top', value);
} else if (attr === 'scrollLeft') {
element.scrollTo('left',value);
} else if (attr === 'width') {
element.setWidth(value);
} else if (attr === 'height') {
element.setHeight(value);
} else {
element.setStyle(attr, value);
}
}
});
Ext.define('Ext.fx.target.ElementCSS', {
extend:  Ext.fx.target.Element ,
setAttr: function(targetData, isFirstFrame) {
var cssArr = {
attrs: [],
duration: [],
easing: []
},
ln = targetData.length,
attributes,
attrs,
attr,
easing,
duration,
o,
i,
j,
ln2;
for (i = 0; i < ln; i++) {
attrs = targetData[i];
duration = attrs.duration;
easing = attrs.easing;
attrs = attrs.attrs;
for (attr in attrs) {
if (Ext.Array.indexOf(cssArr.attrs, attr) == -1) {
cssArr.attrs.push(attr.replace(/[A-Z]/g, function(v) {
return '-' + v.toLowerCase();
}));
cssArr.duration.push(duration + 'ms');
cssArr.easing.push(easing);
}
}
}
attributes = cssArr.attrs.join(',');
duration = cssArr.duration.join(',');
easing = cssArr.easing.join(', ');
for (i = 0; i < ln; i++) {
attrs = targetData[i].attrs;
for (attr in attrs) {
ln2 = attrs[attr].length;
for (j = 0; j < ln2; j++) {
o = attrs[attr][j];
o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionProperty', isFirstFrame ? '' : attributes);
o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionDuration', isFirstFrame ? '' : duration);
o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionTimingFunction', isFirstFrame ? '' : easing);
o[0].setStyle(attr, o[1]);
if (isFirstFrame) {
o = o[0].dom.offsetWidth;
}
else {
o[0].on(Ext.supports.CSS3TransitionEnd, function() {
this.setStyle(Ext.supports.CSS3Prefix + 'TransitionProperty', null);
this.setStyle(Ext.supports.CSS3Prefix + 'TransitionDuration', null);
this.setStyle(Ext.supports.CSS3Prefix + 'TransitionTimingFunction', null);
}, o[0], { single: true });
}
}
}
}
}
});
Ext.define('Ext.fx.target.CompositeElement', {
extend:  Ext.fx.target.Element ,
isComposite: true,
constructor: function(target) {
target.id = target.id || Ext.id(null, 'ext-composite-');
this.callParent([target]);
},
getAttr: function(attr, val) {
var out      = [],
target = this.target,
elements = target.elements,
length   = elements.length,
i,
el;
for (i = 0; i < length; i++) {
el = elements[i];
if (el) {
el = target.getElement(el);
out.push([el, this.getElVal(el, attr, val)]);
}
}
return out;
},
setAttr: function(targetData){
var target = this.target,
ln = targetData.length,
elements = target.elements,
ln3 = elements.length,
value, k,
attrs, attr, o, i, j, ln2;
for (i = 0; i < ln; i++) {
attrs = targetData[i].attrs;
for (attr in attrs) {
if (attrs.hasOwnProperty(attr)) {
ln2 = attrs[attr].length;
for (j = 0; j < ln2; j++) {
value = attrs[attr][j][1];
for (k = 0; k < ln3; ++k) {
el = elements[k];
if (el) {
el = target.getElement(el);
this.setElVal(el, attr, value);
}
}
}
}
}
}
},
remove: function() {
this.target.remove();
}
});
Ext.define('Ext.fx.target.CompositeElementCSS', {
extend:  Ext.fx.target.CompositeElement ,
setAttr: function() {
return Ext.fx.target.ElementCSS.prototype.setAttr.apply(this, arguments);
}
});
Ext.define('Ext.fx.target.Sprite', {
extend:  Ext.fx.target.Target ,
type: 'draw',
getFromPrim: function (sprite, attr) {
var obj;
switch (attr) {
case 'rotate':
case 'rotation':
obj = sprite.attr.rotation;
return {
x: obj.x || 0,
y: obj.y || 0,
degrees: obj.degrees || 0
};
case 'scale':
case 'scaling':
obj = sprite.attr.scaling;
return {
x: obj.x || 1,
y: obj.y || 1,
cx: obj.cx || 0,
cy: obj.cy || 0
};
case 'translate':
case 'translation':
obj = sprite.attr.translation;
return {
x: obj.x || 0,
y: obj.y || 0
};
default:
return sprite.attr[attr];
}
},
getAttr: function (attr, val) {
return [
[this.target, val != undefined ? val : this.getFromPrim(this.target, attr)]
];
},
setAttr: function (targetData) {
var ln = targetData.length,
spriteArr = [],
attrsConf, attr, attrArr, attrs, sprite, idx, value, i, j, x, y, ln2;
for (i = 0; i < ln; i++) {
attrsConf = targetData[i].attrs;
for (attr in attrsConf) {
attrArr = attrsConf[attr];
ln2 = attrArr.length;
for (j = 0; j < ln2; j++) {
sprite = attrArr[j][0];
attrs = attrArr[j][1];
if (attr === 'translate' || attr === 'translation') {
value = {
x: attrs.x,
y: attrs.y
};
}
else if (attr === 'rotate' || attr === 'rotation') {
x = attrs.x;
if (isNaN(x)) {
x = null;
}
y = attrs.y;
if (isNaN(y)) {
y = null;
}
value = {
degrees: attrs.degrees,
x: x,
y: y
};
} else if (attr === 'scale' || attr === 'scaling') {
x = attrs.x;
if (isNaN(x)) {
x = null;
}
y = attrs.y;
if (isNaN(y)) {
y = null;
}
value = {
x: x,
y: y,
cx: attrs.cx,
cy: attrs.cy
};
}
else if (attr === 'width' || attr === 'height' || attr === 'x' || attr === 'y') {
value = parseFloat(attrs);
}
else {
value = attrs;
}
idx = Ext.Array.indexOf(spriteArr, sprite);
if (idx == -1) {
spriteArr.push([sprite, {}]);
idx = spriteArr.length - 1;
}
spriteArr[idx][1][attr] = value;
}
}
}
ln = spriteArr.length;
for (i = 0; i < ln; i++) {
spriteArr[i][0].setAttributes(spriteArr[i][1]);
}
this.target.redraw();
}
});
Ext.define('Ext.fx.target.CompositeSprite', {
extend:  Ext.fx.target.Sprite ,
getAttr: function(attr, val) {
var out     = [],
sprites = [].concat(this.target.items),
length  = sprites.length,
i,
sprite;
for (i = 0; i < length; i++) {
sprite = sprites[i];
out.push([sprite, val != undefined ? val : this.getFromPrim(sprite, attr)]);
}
return out;
}
});
Ext.define('Ext.fx.target.Component', {
extend:  Ext.fx.target.Target ,
type: 'component',
getPropMethod: {
top: function() {
return this.getPosition(true)[1];
},
left: function() {
return this.getPosition(true)[0];
},
x: function() {
return this.getPosition()[0];
},
y: function() {
return this.getPosition()[1];
},
height: function() {
return this.getHeight();
},
width: function() {
return this.getWidth();
},
opacity: function() {
return this.el.getStyle('opacity');
}
},
setMethods: {
top:     'setPosition',
left:    'setPosition',
x:       'setPagePosition',
y:       'setPagePosition',
height:  'setSize',
width:   'setSize',
opacity: 'setOpacity'
},
getAttr: function(attr, val) {
return [[this.target, val !== undefined ? val : this.getPropMethod[attr].call(this.target)]];
},
setAttr: function(targetData, isFirstFrame, isLastFrame) {
var me = this,
ln = targetData.length,
attrs, attr, o, i, j, targets, left, top, w, h,
methodsToCall = {},
methodProps;
for (i = 0; i < ln; i++) {
attrs = targetData[i].attrs;
for (attr in attrs) {
targets = attrs[attr].length;
for (j = 0; j < targets; j++) {
o = attrs[attr][j];
methodProps = methodsToCall[me.setMethods[attr]] || (methodsToCall[me.setMethods[attr]] = {});
methodProps.target = o[0];
methodProps[attr] = o[1];
}
}
if (methodsToCall.setPosition) {
o = methodsToCall.setPosition;
left = (o.left === undefined) ? undefined : parseFloat(o.left);
top = (o.top === undefined) ? undefined : parseFloat(o.top);
o.target.setPosition(left, top);
}
if (methodsToCall.setPagePosition) {
o = methodsToCall.setPagePosition;
o.target.setPagePosition(o.x, o.y);
}
if (methodsToCall.setSize) {
o = methodsToCall.setSize;
w = (o.width === undefined) ? o.target.getWidth() : parseFloat(o.width);
h = (o.height === undefined) ? o.target.getHeight() : parseFloat(o.height);
o.target.el.setSize(w, h);
if (isLastFrame || me.dynamic) {
Ext.globalEvents.on({
idle: Ext.Function.bind(o.target.setSize, o.target, [w, h]),
single: true
});
}
}
if (methodsToCall.setOpacity) {
o = methodsToCall.setOpacity;
o.target.el.setStyle('opacity', o.opacity);
}
}
}
});
Ext.define('Ext.fx.Queue', {
constructor: function() {
this.targets = new Ext.util.HashMap();
this.fxQueue = {};
},
getFxDefaults: function(targetId) {
var target = this.targets.get(targetId);
if (target) {
return target.fxDefaults;
}
return {};
},
setFxDefaults: function(targetId, obj) {
var target = this.targets.get(targetId);
if (target) {
target.fxDefaults = Ext.apply(target.fxDefaults || {}, obj);
}
},
stopAnimation: function(targetId) {
var me = this,
queue = me.getFxQueue(targetId),
ln = queue.length;
while (ln) {
queue[ln - 1].end();
ln--;
}
},
getActiveAnimation: function(targetId) {
var queue = this.getFxQueue(targetId);
return (queue && !!queue.length) ? queue[0] : false;
},
hasFxBlock: function(targetId) {
var queue = this.getFxQueue(targetId);
return queue && queue[0] && queue[0].block;
},
getFxQueue: function(targetId) {
if (!targetId) {
return false;
}
var me = this,
queue = me.fxQueue[targetId],
target = me.targets.get(targetId);
if (!target) {
return false;
}
if (!queue) {
me.fxQueue[targetId] = [];
if (target.type != 'element') {
target.target.on('destroy', function() {
me.fxQueue[targetId] = [];
});
}
}
return me.fxQueue[targetId];
},
queueFx: function(anim) {
var me = this,
target = anim.target,
queue, ln;
if (!target) {
return;
}
queue = me.getFxQueue(target.getId());
ln = queue.length;
if (ln) {
if (anim.concurrent) {
anim.paused = false;
}
else {
queue[ln - 1].on('afteranimate', function() {
anim.paused = false;
});
}
}
else {
anim.paused = false;
}
anim.on('afteranimate', function() {
Ext.Array.remove(queue, anim);
me.removeAnim(anim);
if (queue.length === 0) {
me.targets.remove(anim.target);
}
if (anim.remove) {
if (target.type == 'element') {
var el = Ext.get(target.id);
if (el) {
el.remove();
}
}
}
}, me, {
single: true
});
queue.push(anim);
}
});
Ext.define('Ext.fx.Manager', {
singleton: true,
mixins: {
queue:  Ext.fx.Queue 
},
constructor: function() {
var me = this;
me.items = new Ext.util.MixedCollection();
me.targetArr = {};
me.mixins.queue.constructor.call(me);
me.taskRunner = new Ext.util.TaskRunner(me.interval);
},
interval: 16,
forceJS: true,
createTarget: function(target) {
var me = this,
useCSS3 = !me.forceJS && Ext.supports.Transitions,
targetObj;
me.useCSS3 = useCSS3;
if (target) {
if (target.tagName || Ext.isString(target) || target.isFly) {
target = Ext.get(target);
targetObj = new Ext.fx.target['Element' + (useCSS3 ? 'CSS' : '')](target);
}
else if (target.dom) {
targetObj = new Ext.fx.target['Element' + (useCSS3 ? 'CSS' : '')](target);
}
else if (target.isComposite) {
targetObj = new Ext.fx.target['CompositeElement' + (useCSS3 ? 'CSS' : '')](target);
}
else if (target.isSprite) {
targetObj = new Ext.fx.target.Sprite(target);
}
else if (target.isCompositeSprite) {
targetObj = new Ext.fx.target.CompositeSprite(target);
}
else if (target.isComponent) {
targetObj = new Ext.fx.target.Component(target);
}
else if (target.isAnimTarget) {
return target;
}
else {
return null;
}
me.targets.add(targetObj);
return targetObj;
}
else {
return null;
}
},
addAnim: function(anim) {
var me = this,
items = me.items,
task = me.task;
items.add(anim.id, anim);
if (!task && items.length) {
task = me.task = {
run: me.runner,
interval: me.interval,
scope: me
};
me.taskRunner.start(task);
}
},
removeAnim: function(anim) {
var me = this,
items = me.items,
task = me.task;
items.removeAtKey(anim.id);
if (task && !items.length) {
me.taskRunner.stop(task);
delete me.task;
}
},
runner: function() {
var me = this,
items = me.items.getRange(),
i = 0,
len = items.length,
anim;
me.targetArr = {};
me.timestamp = new Date();
for (; i < len; i++) {
anim = items[i];
if (anim.isReady()) {
me.startAnim(anim);
}
}
for (i = 0; i < len; i++) {
anim = items[i];
if (anim.isRunning()) {
me.runAnim(anim);
}
}
me.applyPendingAttrs();
},
startAnim: function(anim) {
anim.start(this.timestamp);
},
runAnim: function(anim, forceEnd) {
if (!anim) {
return;
}
var me = this,
useCSS3 = me.useCSS3 && anim.target.type == 'element',
elapsedTime = me.timestamp - anim.startTime,
lastFrame = (elapsedTime >= anim.duration),
target, o;
if (forceEnd) {
elapsedTime = anim.duration;
lastFrame = true;
}
target = this.collectTargetData(anim, elapsedTime, useCSS3, lastFrame);
if (useCSS3) {
anim.target.setAttr(target.anims[anim.id].attributes, true);
me.collectTargetData(anim, anim.duration, useCSS3, lastFrame);
anim.paused = true;
target = anim.target.target;
if (anim.target.isComposite) {
target = anim.target.target.last();
}
o = {};
o[Ext.supports.CSS3TransitionEnd] = anim.lastFrame;
o.scope = anim;
o.single = true;
target.on(o);
}
return target;
},
jumpToEnd: function(anim) {
var target = this.runAnim(anim, true);
this.applyAnimAttrs(target, target.anims[anim.id]);
},
collectTargetData: function(anim, elapsedTime, useCSS3, isLastFrame) {
var targetId = anim.target.getId(),
target = this.targetArr[targetId];
if (!target) {
target = this.targetArr[targetId] = {
id: targetId,
el: anim.target,
anims: {}
};
}
target.anims[anim.id] = {
id: anim.id,
anim: anim,
elapsed: elapsedTime,
isLastFrame: isLastFrame,
attributes: [{
duration: anim.duration,
easing: (useCSS3 && anim.reverse) ? anim.easingFn.reverse().toCSS3() : anim.easing,
attrs: anim.runAnim(elapsedTime)
}]
};
return target;
},
applyAnimAttrs: function(target, animWrap) {
var anim = animWrap.anim;
if (animWrap.attributes && anim.isRunning()) {
target.el.setAttr(animWrap.attributes, false, animWrap.isLastFrame);
if (animWrap.isLastFrame) {
anim.lastFrame();
}
}
},
applyPendingAttrs: function() {
var targetArr = this.targetArr,
target, targetId, animWrap, anim, animId;
for (targetId in targetArr) {
if (targetArr.hasOwnProperty(targetId)) {
target = targetArr[targetId];
for (animId in target.anims) {
if (target.anims.hasOwnProperty(animId)) {
animWrap = target.anims[animId];
anim = animWrap.anim;
if (animWrap.attributes && anim.isRunning()) {
target.el.setAttr(animWrap.attributes, false, animWrap.isLastFrame);
if (animWrap.isLastFrame) {
anim.lastFrame();
}
}
}
}
}
}
}
});
Ext.define('Ext.fx.Animator', {
mixins: {
observable:  Ext.util.Observable 
},
isAnimator: true,
duration: 250,
delay: 0,
delayStart: 0,
dynamic: false,
easing: 'ease',
running: false,
paused: false,
damper: 1,
iterations: 1,
currentIteration: 0,
keyframeStep: 0,
animKeyFramesRE: /^(from|to|\d+%?)$/,
constructor: function(config) {
var me = this;
config = Ext.apply(me, config || {});
me.config = config;
me.id = Ext.id(null, 'ext-animator-');
me.addEvents(
'beforeanimate',
'keyframe',
'afteranimate'
);
me.mixins.observable.constructor.call(me, config);
me.timeline = [];
me.createTimeline(me.keyframes);
if (me.target) {
me.applyAnimator(me.target);
Ext.fx.Manager.addAnim(me);
}
},
sorter: function (a, b) {
return a.pct - b.pct;
},
createTimeline: function(keyframes) {
var me = this,
attrs = [],
to = me.to || {},
duration = me.duration,
prevMs, ms, i, ln, pct, attr;
for (pct in keyframes) {
if (keyframes.hasOwnProperty(pct) && me.animKeyFramesRE.test(pct)) {
attr = {attrs: Ext.apply(keyframes[pct], to)};
if (pct == "from") {
pct = 0;
}
else if (pct == "to") {
pct = 100;
}
attr.pct = parseInt(pct, 10);
attrs.push(attr);
}
}
Ext.Array.sort(attrs, me.sorter);
ln = attrs.length;
for (i = 0; i < ln; i++) {
prevMs = (attrs[i - 1]) ? duration * (attrs[i - 1].pct / 100) : 0;
ms = duration * (attrs[i].pct / 100);
me.timeline.push({
duration: ms - prevMs,
attrs: attrs[i].attrs
});
}
},
applyAnimator: function(target) {
var me = this,
anims = [],
timeline = me.timeline,
ln = timeline.length,
anim, easing, damper, attrs, i;
if (me.fireEvent('beforeanimate', me) !== false) {
for (i = 0; i < ln; i++) {
anim = timeline[i];
attrs = anim.attrs;
easing = attrs.easing || me.easing;
damper = attrs.damper || me.damper;
delete attrs.easing;
delete attrs.damper;
anim = new Ext.fx.Anim({
target: target,
easing: easing,
damper: damper,
duration: anim.duration,
paused: true,
to: attrs
});
anims.push(anim);
}
me.animations = anims;
me.target = anim.target;
for (i = 0; i < ln - 1; i++) {
anim = anims[i];
anim.nextAnim = anims[i + 1];
anim.on('afteranimate', function() {
this.nextAnim.paused = false;
});
anim.on('afteranimate', function() {
this.fireEvent('keyframe', this, ++this.keyframeStep);
}, me);
}
anims[ln - 1].on('afteranimate', function() {
this.lastFrame();
}, me);
}
},
start: function(startTime) {
var me = this,
delay = me.delay,
delayStart = me.delayStart,
delayDelta;
if (delay) {
if (!delayStart) {
me.delayStart = startTime;
return;
}
else {
delayDelta = startTime - delayStart;
if (delayDelta < delay) {
return;
}
else {
startTime = new Date(delayStart.getTime() + delay);
}
}
}
if (me.fireEvent('beforeanimate', me) !== false) {
me.startTime = startTime;
me.running = true;
me.animations[me.keyframeStep].paused = false;
}
},
lastFrame: function() {
var me = this,
iter = me.iterations,
iterCount = me.currentIteration;
iterCount++;
if (iterCount < iter) {
me.startTime = new Date();
me.currentIteration = iterCount;
me.keyframeStep = 0;
me.applyAnimator(me.target);
me.animations[me.keyframeStep].paused = false;
}
else {
me.currentIteration = 0;
me.end();
}
},
end: function() {
var me = this;
me.fireEvent('afteranimate', me, me.startTime, new Date() - me.startTime);
},
isReady: function() {
return this.paused === false && this.running === false && this.iterations > 0;
},
isRunning: function() {
return false;
}
});
Ext.define('Ext.fx.CubicBezier', {
singleton: true,
cubicBezierAtTime: function(t, p1x, p1y, p2x, p2y, duration) {
var cx = 3 * p1x,
bx = 3 * (p2x - p1x) - cx,
ax = 1 - cx - bx,
cy = 3 * p1y,
by = 3 * (p2y - p1y) - cy,
ay = 1 - cy - by;
function sampleCurveX(t) {
return ((ax * t + bx) * t + cx) * t;
}
function solve(x, epsilon) {
var t = solveCurveX(x, epsilon);
return ((ay * t + by) * t + cy) * t;
}
function solveCurveX(x, epsilon) {
var t0, t1, t2, x2, d2, i;
for (t2 = x, i = 0; i < 8; i++) {
x2 = sampleCurveX(t2) - x;
if (Math.abs(x2) < epsilon) {
return t2;
}
d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
if (Math.abs(d2) < 1e-6) {
break;
}
t2 = t2 - x2 / d2;
}
t0 = 0;
t1 = 1;
t2 = x;
if (t2 < t0) {
return t0;
}
if (t2 > t1) {
return t1;
}
while (t0 < t1) {
x2 = sampleCurveX(t2);
if (Math.abs(x2 - x) < epsilon) {
return t2;
}
if (x > x2) {
t0 = t2;
} else {
t1 = t2;
}
t2 = (t1 - t0) / 2 + t0;
}
return t2;
}
return solve(t, 1 / (200 * duration));
},
cubicBezier: function(x1, y1, x2, y2) {
var fn = function(pos) {
return Ext.fx.CubicBezier.cubicBezierAtTime(pos, x1, y1, x2, y2, 1);
};
fn.toCSS3 = function() {
return 'cubic-bezier(' + [x1, y1, x2, y2].join(',') + ')';
};
fn.reverse = function() {
return Ext.fx.CubicBezier.cubicBezier(1 - x2, 1 - y2, 1 - x1, 1 - y1);
};
return fn;
}
});
Ext.require('Ext.fx.CubicBezier', function() {
var math = Math,
pi = math.PI,
pow = math.pow,
sin = math.sin,
sqrt = math.sqrt,
abs = math.abs,
backInSeed = 1.70158;
Ext.define('Ext.fx.Easing', {
singleton: true,
linear: Ext.identityFn,
ease: function(n) {
var q = 0.07813 - n / 2,
alpha = -0.25,
Q = sqrt(0.0066 + q * q),
x = Q - q,
X = pow(abs(x), 1/3) * (x < 0 ? -1 : 1),
y = -Q - q,
Y = pow(abs(y), 1/3) * (y < 0 ? -1 : 1),
t = X + Y + 0.25;
return pow(1 - t, 2) * 3 * t * 0.1 + (1 - t) * 3 * t * t + t * t * t;
},
easeIn: function (n) {
return pow(n, 1.7);
},
easeOut: function (n) {
return pow(n, 0.48);
},
easeInOut: function(n) {
var q = 0.48 - n / 1.04,
Q = sqrt(0.1734 + q * q),
x = Q - q,
X = pow(abs(x), 1/3) * (x < 0 ? -1 : 1),
y = -Q - q,
Y = pow(abs(y), 1/3) * (y < 0 ? -1 : 1),
t = X + Y + 0.5;
return (1 - t) * 3 * t * t + t * t * t;
},
backIn: function (n) {
return n * n * ((backInSeed + 1) * n - backInSeed);
},
backOut: function (n) {
n = n - 1;
return n * n * ((backInSeed + 1) * n + backInSeed) + 1;
},
elasticIn: function (n) {
if (n === 0 || n === 1) {
return n;
}
var p = 0.3,
s = p / 4;
return pow(2, -10 * n) * sin((n - s) * (2 * pi) / p) + 1;
},
elasticOut: function (n) {
return 1 - Ext.fx.Easing.elasticIn(1 - n);
},
bounceIn: function (n) {
return 1 - Ext.fx.Easing.bounceOut(1 - n);
},
bounceOut: function (n) {
var s = 7.5625,
p = 2.75,
l;
if (n < (1 / p)) {
l = s * n * n;
} else {
if (n < (2 / p)) {
n -= (1.5 / p);
l = s * n * n + 0.75;
} else {
if (n < (2.5 / p)) {
n -= (2.25 / p);
l = s * n * n + 0.9375;
} else {
n -= (2.625 / p);
l = s * n * n + 0.984375;
}
}
}
return l;
}
}, function(){
var easing = Ext.fx.Easing.self,
proto = easing.prototype;
easing.implement({
'back-in': proto.backIn,
'back-out': proto.backOut,
'ease-in': proto.easeIn,
'ease-out': proto.easeOut,
'elastic-in': proto.elasticIn,
'elastic-out': proto.elasticOut,
'bounce-in': proto.bounceIn,
'bounce-out': proto.bounceOut,
'ease-in-out': proto.easeInOut
});        
});
});
Ext.define('Ext.fx.PropertyHandler', {
statics: {
defaultHandler: {
pixelDefaultsRE: /width|height|top$|bottom$|left$|right$/i,
unitRE: /^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/,
scrollRE: /^scroll/i,
computeDelta: function(from, end, damper, initial, attr) {
damper = (typeof damper == 'number') ? damper : 1;
var unitRE = this.unitRE,
match = unitRE.exec(from),
start, units;
if (match) {
from = match[1];
units = match[2];
if (!this.scrollRE.test(attr) && !units && this.pixelDefaultsRE.test(attr)) {
units = 'px';
}
}
from = +from || 0;
match = unitRE.exec(end);
if (match) {
end = match[1];
units = match[2] || units;
}
end = +end || 0;
start = (initial != null) ? initial : from;
return {
from: from,
delta: (end - start) * damper,
units: units
};
},
get: function(from, end, damper, initialFrom, attr) {
var ln = from.length,
out = [],
i, initial, res, j, len;
for (i = 0; i < ln; i++) {
if (initialFrom) {
initial = initialFrom[i][1].from;
}
if (Ext.isArray(from[i][1]) && Ext.isArray(end)) {
res = [];
j = 0;
len = from[i][1].length;
for (; j < len; j++) {
res.push(this.computeDelta(from[i][1][j], end[j], damper, initial, attr));
}
out.push([from[i][0], res]);
}
else {
out.push([from[i][0], this.computeDelta(from[i][1], end, damper, initial, attr)]);
}
}
return out;
},
set: function(values, easing) {
var ln = values.length,
out = [],
i, val, res, len, j;
for (i = 0; i < ln; i++) {
val  = values[i][1];
if (Ext.isArray(val)) {
res = [];
j = 0;
len = val.length;
for (; j < len; j++) {
res.push(val[j].from + val[j].delta * easing + (val[j].units || 0));
}
out.push([values[i][0], res]);
} else {
out.push([values[i][0], val.from + val.delta * easing + (val.units || 0)]);
}
}
return out;
}
},
stringHandler: {
computeDelta: function(from, end, damper, initial, attr) {
return {
from: from,
delta: end
};
},
get: function(from, end, damper, initialFrom, attr) {
var ln = from.length,
out = [],
i, initial, res, j, len;
for (i = 0; i < ln; i++) {
out.push([from[i][0], this.computeDelta(from[i][1], end, damper, initial, attr)]);
}
return out;
},
set: function(values, easing) {
var ln = values.length,
out = [],
i, val, res, len, j;
for (i = 0; i < ln; i++) {
val  = values[i][1];
out.push([values[i][0], val.delta]);
}
return out;
}
},
color: {
rgbRE: /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,
hexRE: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,
hex3RE: /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i,
parseColor : function(color, damper) {
damper = (typeof damper == 'number') ? damper : 1;
var out    = false,
reList = [this.hexRE, this.rgbRE, this.hex3RE],
length = reList.length,
match, base, re, i;
for (i = 0; i < length; i++) {
re = reList[i];
base = (i % 2 === 0) ? 16 : 10;
match = re.exec(color);
if (match && match.length === 4) {
if (i === 2) {
match[1] += match[1];
match[2] += match[2];
match[3] += match[3];
}
out = {
red: parseInt(match[1], base),
green: parseInt(match[2], base),
blue: parseInt(match[3], base)
};
break;
}
}
return out || color;
},
computeDelta: function(from, end, damper, initial) {
from = this.parseColor(from);
end = this.parseColor(end, damper);
var start = initial ? initial : from,
tfrom = typeof start,
tend = typeof end;
if (tfrom == 'string' ||  tfrom == 'undefined'
|| tend == 'string' || tend == 'undefined') {
return end || start;
}
return {
from:  from,
delta: {
red: Math.round((end.red - start.red) * damper),
green: Math.round((end.green - start.green) * damper),
blue: Math.round((end.blue - start.blue) * damper)
}
};
},
get: function(start, end, damper, initialFrom) {
var ln = start.length,
out = [],
i, initial;
for (i = 0; i < ln; i++) {
if (initialFrom) {
initial = initialFrom[i][1].from;
}
out.push([start[i][0], this.computeDelta(start[i][1], end, damper, initial)]);
}
return out;
},
set: function(values, easing) {
var ln = values.length,
out = [],
i, val, parsedString, from, delta;
for (i = 0; i < ln; i++) {
val = values[i][1];
if (val) {
from = val.from;
delta = val.delta;
val = (typeof val == 'object' && 'red' in val)? 
'rgb(' + val.red + ', ' + val.green + ', ' + val.blue + ')' : val;
val = (typeof val == 'object' && val.length)? val[0] : val;
if (typeof val == 'undefined') {
return [];
}
parsedString = typeof val == 'string'? val :
'rgb(' + [
(from.red + Math.round(delta.red * easing)) % 256,
(from.green + Math.round(delta.green * easing)) % 256,
(from.blue + Math.round(delta.blue * easing)) % 256
].join(',') + ')';
out.push([
values[i][0],
parsedString
]);
}
}
return out;
}
},
object: {
interpolate: function(prop, damper) {
damper = (typeof damper == 'number') ? damper : 1;
var out = {},
p;
for(p in prop) {
out[p] = parseFloat(prop[p]) * damper;
}
return out;
},
computeDelta: function(from, end, damper, initial) {
from = this.interpolate(from);
end = this.interpolate(end, damper);
var start = initial ? initial : from,
delta = {},
p;
for(p in end) {
delta[p] = end[p] - start[p];
}
return {
from:  from,
delta: delta
};
},
get: function(start, end, damper, initialFrom) {
var ln = start.length,
out = [],
i, initial;
for (i = 0; i < ln; i++) {
if (initialFrom) {
initial = initialFrom[i][1].from;
}
out.push([start[i][0], this.computeDelta(start[i][1], end, damper, initial)]);
}
return out;
},
set: function(values, easing) {
var ln = values.length,
out = [],
outObject = {},
i, from, delta, val, p;
for (i = 0; i < ln; i++) {
val  = values[i][1];
from = val.from;
delta = val.delta;
for (p in from) {
outObject[p] = from[p] + delta[p] * easing;
}
out.push([
values[i][0],
outObject
]);
}
return out;
}
},
path: {
computeDelta: function(from, end, damper, initial) {
damper = (typeof damper == 'number') ? damper : 1;
var start;
from = +from || 0;
end = +end || 0;
start = (initial != null) ? initial : from;
return {
from: from,
delta: (end - start) * damper
};
},
forcePath: function(path) {
if (!Ext.isArray(path) && !Ext.isArray(path[0])) {
path = Ext.draw.Draw.parsePathString(path);
}
return path;
},
get: function(start, end, damper, initialFrom) {
var endPath = this.forcePath(end),
out = [],
startLn = start.length,
startPathLn, pointsLn, i, deltaPath, initial, j, k, path, startPath;
for (i = 0; i < startLn; i++) {
startPath = this.forcePath(start[i][1]);
deltaPath = Ext.draw.Draw.interpolatePaths(startPath, endPath);
startPath = deltaPath[0];
endPath = deltaPath[1];
startPathLn = startPath.length;
path = [];
for (j = 0; j < startPathLn; j++) {
deltaPath = [startPath[j][0]];
pointsLn = startPath[j].length;
for (k = 1; k < pointsLn; k++) {
initial = initialFrom && initialFrom[0][1][j][k].from;
deltaPath.push(this.computeDelta(startPath[j][k], endPath[j][k], damper, initial));
}
path.push(deltaPath);
}
out.push([start[i][0], path]);
}
return out;
},
set: function(values, easing) {
var ln = values.length,
out = [],
i, j, k, newPath, calcPath, deltaPath, deltaPathLn, pointsLn;
for (i = 0; i < ln; i++) {
deltaPath = values[i][1];
newPath = [];
deltaPathLn = deltaPath.length;
for (j = 0; j < deltaPathLn; j++) {
calcPath = [deltaPath[j][0]];
pointsLn = deltaPath[j].length;
for (k = 1; k < pointsLn; k++) {
calcPath.push(deltaPath[j][k].from + deltaPath[j][k].delta * easing);
}
newPath.push(calcPath.join(','));
}
out.push([values[i][0], newPath.join(',')]);
}
return out;
}
}
}
}, function() {
var props  = [
'outlineColor',
'backgroundColor',
'borderColor',
'borderTopColor',
'borderRightColor',
'borderBottomColor',
'borderLeftColor',
'fill',
'stroke'
],
length = props.length,
i      = 0,
prop;
for (; i<length; i++) {
prop = props[i];
this[prop] = this.color;
}
props  = ['cursor'];
length = props.length;
i      = 0;
for (; i<length; i++) {
prop = props[i];
this[prop] = this.stringHandler;
}
});
Ext.define('Ext.fx.Anim', {
mixins: {
observable:  Ext.util.Observable 
},
isAnimation: true,
duration: 250,
delay: 0,
delayStart: 0,
dynamic: false,
easing: 'ease',
damper: 1,
bezierRE: /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
reverse: false,
running: false,
paused: false,
iterations: 1,
autoEnd: false,
alternate: false,
currentIteration: 0,
startTime: 0,
frameCount: 0,
constructor: function(config) {
var me = this,
curve;
config = config || {};
if (config.keyframes) {
return new Ext.fx.Animator(config);
}
Ext.apply(me, config);
if (me.from === undefined) {
me.from = {};
}
me.propHandlers = {};
me.config = config;
me.target = Ext.fx.Manager.createTarget(me.target);
me.easingFn = Ext.fx.Easing[me.easing];
me.target.dynamic = me.dynamic;
if (!me.easingFn) {
me.easingFn = String(me.easing).match(me.bezierRE);
if (me.easingFn && me.easingFn.length == 5) {
curve = me.easingFn;
me.easingFn = Ext.fx.CubicBezier.cubicBezier(+curve[1], +curve[2], +curve[3], +curve[4]);
}
}
me.id = Ext.id(null, 'ext-anim-');
me.addEvents(
'beforeanimate',
'afteranimate',
'lastframe'
);
me.mixins.observable.constructor.call(me);
Ext.fx.Manager.addAnim(me);
if (config.autoEnd) {
me.running = true;
me.jumpToEnd();
}
},
setAttr: function(attr, value) {
return Ext.fx.Manager.items.get(this.id).setAttr(this.target, attr, value);
},
initAttrs: function() {
var me = this,
from = me.from,
to = me.to,
initialFrom = me.initialFrom || {},
out = {},
start, end, propHandler, attr;
for (attr in to) {
if (to.hasOwnProperty(attr)) {
start = me.target.getAttr(attr, from[attr]);
end = to[attr];
if (!Ext.fx.PropertyHandler[attr]) {
if (Ext.isObject(end)) {
propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler.object;
} else {
propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler.defaultHandler;
}
}
else {
propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler[attr];
}
out[attr] = propHandler.get(start, end, me.damper, initialFrom[attr], attr);
}
}
me.currentAttrs = out;
},
start: function(startTime) {
var me = this,
delay = me.delay,
delayStart = me.delayStart,
delayDelta;
if (delay) {
if (!delayStart) {
me.delayStart = startTime;
return;
}
else {
delayDelta = startTime - delayStart;
if (delayDelta < delay) {
return;
}
else {
startTime = new Date(delayStart.getTime() + delay);
}
}
}
if (me.fireEvent('beforeanimate', me) !== false) {
me.startTime = startTime;
if (!me.paused && !me.currentAttrs) {
me.initAttrs();
}
me.running = true;
me.frameCount = 0;
}
},
jumpToEnd: function(){
var me = this;
if (!me.endWasCalled) {
if (!me.currentAttrs) {
me.initAttrs();
}
Ext.fx.Manager.jumpToEnd(me);
me.end();
}
},
runAnim: function(elapsedTime) {
var me = this,
attrs = me.currentAttrs,
duration = me.duration,
easingFn = me.easingFn,
propHandlers = me.propHandlers,
ret = {},
easing, values, attr, lastFrame;
if (elapsedTime >= duration) {
elapsedTime = duration;
lastFrame = true;
}
if (me.reverse) {
elapsedTime = duration - elapsedTime;
}
for (attr in attrs) {
if (attrs.hasOwnProperty(attr)) {
values = attrs[attr];
easing = lastFrame ? 1 : easingFn(elapsedTime / duration);
ret[attr] = propHandlers[attr].set(values, easing);
}
}
me.frameCount++;
return ret;
},
lastFrame: function() {
var me = this,
iter = me.iterations,
iterCount = me.currentIteration;
iterCount++;
if (iterCount < iter) {
if (me.alternate) {
me.reverse = !me.reverse;
}
me.startTime = new Date();
me.currentIteration = iterCount;
me.paused = false;
}
else {
me.currentIteration = 0;
me.end();
me.fireEvent('lastframe', me, me.startTime);
}
},
endWasCalled: 0,
end: function() {
var me = this;
if (me.endWasCalled++) {
return;
}
me.startTime = 0;
me.paused = false;
me.running = false;
Ext.fx.Manager.removeAnim(me);
me.fireEvent('afteranimate', me, me.startTime);
Ext.callback(me.callback, me.scope, [me, me.startTime]);
if (me.remove) {
me.target.remove();
}
},
isReady: function() {
return this.paused === false && this.running === false && this.iterations > 0;
},
isRunning: function() {
return this.paused === false && this.running === true && this.isAnimator !== true;
}
});
Ext.enableFx = true;
Ext.define('Ext.util.Animate', {
isAnimate: true,
animate: function(animObj) {
var me = this;
if (Ext.fx.Manager.hasFxBlock(me.id)) {
return me;
}
Ext.fx.Manager.queueFx(new Ext.fx.Anim(me.anim(animObj)));
return this;
},
anim: function(config) {
if (!Ext.isObject(config)) {
return (config) ? {} : false;
}
var me = this;
if (config.stopAnimation) {
me.stopAnimation();
}
Ext.applyIf(config, Ext.fx.Manager.getFxDefaults(me.id));
return Ext.apply({
target: me,
paused: true
}, config);
},
stopFx: Ext.Function.alias(Ext.util.Animate, 'stopAnimation'),
stopAnimation: function() {
Ext.fx.Manager.stopAnimation(this.id);
return this;
},
syncFx: function() {
Ext.fx.Manager.setFxDefaults(this.id, {
concurrent: true
});
return this;
},
sequenceFx: function() {
Ext.fx.Manager.setFxDefaults(this.id, {
concurrent: false
});
return this;
},
hasActiveFx: Ext.Function.alias(Ext.util.Animate, 'getActiveAnimation'),
getActiveAnimation: function() {
return Ext.fx.Manager.getActiveAnimation(this.id);
}
}, function(){
Ext.applyIf(Ext.Element.prototype, this.prototype);
Ext.CompositeElementLite.importElementMethods();
});
Ext.define('Ext.util.ElementContainer', {
childEls: [
],
constructor: function () {
var me = this,
childEls;
if (me.hasOwnProperty('childEls')) {
childEls = me.childEls;
delete me.childEls;
me.addChildEls.apply(me, childEls);
}
},
destroy: function () {
var me = this,
childEls = me.getChildEls(),
child, childName, i, k;
for (i = childEls.length; i--; ) {
childName = childEls[i];
if (typeof childName != 'string') {
childName = childName.name;
}
child = me[childName];
if (child) {
me[childName] = null; 
child.remove();
}
}
},
addChildEls: function () {
var me = this,
args = arguments;
if (me.hasOwnProperty('childEls')) {
me.childEls.push.apply(me.childEls, args);
} else {
me.childEls = me.getChildEls().concat(Array.prototype.slice.call(args));
}
me.prune(me.childEls, false);
},
applyChildEls: function(el, id) {
var me = this,
childEls = me.getChildEls(),
baseId, childName, i, selector, value;
baseId = (id || me.id) + '-';
for (i = childEls.length; i--; ) {
childName = childEls[i];
if (typeof childName == 'string') {
value = el.getById(baseId + childName);
} else {
if ((selector = childName.select)) {
value = Ext.select(selector, true, el.dom); 
} else if ((selector = childName.selectNode)) {
value = Ext.get(Ext.DomQuery.selectNode(selector, el.dom));
} else {
value = el.getById(childName.id || (baseId + childName.itemId));
}
childName = childName.name;
}
me[childName] = value;
}
},
getChildEls: function () {
var me = this,
self;
if (me.hasOwnProperty('childEls')) {
return me.childEls;
}
self = me.self;
return self.$childEls || me.getClassChildEls(self);
},
getClassChildEls: function (cls) {
var me = this,
result = cls.$childEls,
childEls, i, length, forked, mixin, mixins, name, parts, proto, supr, superMixins;
if (!result) {
supr = cls.superclass;
if (supr) {
supr = supr.self;
parts = [supr.$childEls || me.getClassChildEls(supr)]; 
superMixins = supr.prototype.mixins || {};
} else {
parts = [];
superMixins = {};
}
proto = cls.prototype;
mixins = proto.mixins; 
for (name in mixins) {
if (mixins.hasOwnProperty(name) && !superMixins.hasOwnProperty(name)) {
mixin = mixins[name].self;
parts.push(mixin.$childEls || me.getClassChildEls(mixin));
}
}
parts.push(proto.hasOwnProperty('childEls') && proto.childEls);
for (i = 0, length = parts.length; i < length; ++i) {
childEls = parts[i];
if (childEls && childEls.length) {
if (!result) {
result = childEls;
} else {
if (!forked) {
forked = true;
result = result.slice(0);
}
result.push.apply(result, childEls);
}
}
}
cls.$childEls = result = (result ? me.prune(result, !forked) : []);
}
return result;
},
prune: function (childEls, shared) {
var index = childEls.length,
map = {},
name;
while (index--) {
name = childEls[index];
if (typeof name != 'string') {
name = name.name;
}
if (!map[name]) {
map[name] = 1;
} else {
if (shared) {
shared = false;
childEls = childEls.slice(0);
}
Ext.Array.erase(childEls, index, 1);
}
}
return childEls;
},
removeChildEls: function (testFn) {
var me = this,
old = me.getChildEls(),
keepers = (me.childEls = []),
n, i, cel;
for (i = 0, n = old.length; i < n; ++i) {
cel = old[i];
if (!testFn(cel)) {
keepers.push(cel);
}
}
}
});
Ext.define('Ext.util.Renderable', {
frameCls: Ext.baseCSSPrefix + 'frame',
frameIdRegex: /[\-]frame\d+[TMB][LCR]$/,
frameElNames: ['TL','TC','TR','ML','MC','MR','BL','BC','BR','Table'],
frameTpl: [
'{%this.renderDockedItems(out,values,0);%}',
'<tpl if="top">',
'<tpl if="left"><div id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>{frameElCls}" role="presentation"></tpl>',
'<tpl if="right"><div id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>{frameElCls}" role="presentation"></tpl>',
'<div id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>{frameElCls}" role="presentation"></div>',
'<tpl if="right"></div></tpl>',
'<tpl if="left"></div></tpl>',
'</tpl>',
'<tpl if="left"><div id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>{frameElCls}" role="presentation"></tpl>',
'<tpl if="right"><div id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>{frameElCls}" role="presentation"></tpl>',
'<div id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>{frameElCls}" role="presentation">',
'{%this.applyRenderTpl(out, values)%}',
'</div>',
'<tpl if="right"></div></tpl>',
'<tpl if="left"></div></tpl>',
'<tpl if="bottom">',
'<tpl if="left"><div id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>{frameElCls}" role="presentation"></tpl>',
'<tpl if="right"><div id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>{frameElCls}" role="presentation"></tpl>',
'<div id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>{frameElCls}" role="presentation"></div>',
'<tpl if="right"></div></tpl>',
'<tpl if="left"></div></tpl>',
'</tpl>',
'{%this.renderDockedItems(out,values,1);%}'
],
frameTableTpl: [
'{%this.renderDockedItems(out,values,0);%}',
'<table id="{fgid}Table" class="', Ext.plainTableCls, '" cellpadding="0" role="presentation">',
'<tbody role="presentation">',
'<tpl if="top">',
'<tr role="presentation">',
'<tpl if="left"><td id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>{frameElCls}" role="presentation"></td></tpl>',
'<td id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>{frameElCls}" role="presentation"></td>',
'<tpl if="right"><td id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>{frameElCls}" role="presentation"></td></tpl>',
'</tr>',
'</tpl>',
'<tr role="presentation">',
'<tpl if="left"><td id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>{frameElCls}" role="presentation"></td></tpl>',
'<td id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>{frameElCls}" role="presentation">',
'{%this.applyRenderTpl(out, values)%}',
'</td>',
'<tpl if="right"><td id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>{frameElCls}" role="presentation"></td></tpl>',
'</tr>',
'<tpl if="bottom">',
'<tr role="presentation">',
'<tpl if="left"><td id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>{frameElCls}" role="presentation"></td></tpl>',
'<td id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>{frameElCls}" role="presentation"></td>',
'<tpl if="right"><td id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>{frameElCls}" role="presentation"></td></tpl>',
'</tr>',
'</tpl>',
'</tbody></table>',
'{%this.renderDockedItems(out,values,1);%}'
],
afterRender : function() {
var me = this,
data = {},
protoEl = me.protoEl,
target = me.el,
item, pre, hide, contentEl;
me.finishRenderChildren();
if (me.contentEl) {
pre = Ext.baseCSSPrefix;
hide = pre + 'hide-';
contentEl = Ext.get(me.contentEl);
contentEl.removeCls([pre+'hidden', hide+'display', hide+'offsets', hide+'nosize']);
me.getContentTarget().appendChild(contentEl.dom);
}
protoEl.writeTo(data);
item = data.removed;
if (item) {
target.removeCls(item);
}
item = data.cls;
if (item.length) {
target.addCls(item);
}
item = data.style;
if (data.style) {
target.setStyle(item);
}
me.protoEl = null;
if (!me.ownerCt) {
me.updateLayout();
}
},
afterFirstLayout : function(width, height) {
var me = this,
x = me.x,
y = me.y,
hasX,
hasY,
pos, xy;
if (!me.ownerLayout) {
hasX = Ext.isDefined(x);
hasY = Ext.isDefined(y);
}
if (me.floating && (!hasX || !hasY)) {
if (me.floatParent) {
pos = me.floatParent.getTargetEl().getViewRegion();
xy = me.el.getAlignToXY(me.floatParent.getTargetEl(), 'c-c');
pos.x = xy[0] - pos.x;
pos.y = xy[1] - pos.y;
} else {
xy = me.el.getAlignToXY(me.container, 'c-c');
pos = me.container.translateXY(xy[0], xy[1]);
}
x = hasX ? x : pos.x;
y = hasY ? y : pos.y;
hasX = hasY = true;
}
if (hasX || hasY) {
me.setPosition(x, y);
}
me.onBoxReady(width, height);
},
applyRenderSelectors: function() {
var me = this,
selectors = me.renderSelectors,
el = me.el,
dom = el.dom,
selector;
me.applyChildEls(el);
if (selectors) {
for (selector in selectors) {
if (selectors.hasOwnProperty(selector) && selectors[selector]) {
me[selector] = Ext.get(Ext.DomQuery.selectNode(selectors[selector], dom));
}
}
}
},
beforeRender: function () {
var me = this,
target = me.getTargetEl(),
overflowEl = me.getOverflowEl(),
layout = me.getComponentLayout(),
overflowStyle = me.getOverflowStyle();
me.frame = me.frame || me.alwaysFramed;
if (!layout.initialized) {
layout.initLayout();
}
if (overflowEl) {
overflowEl.setStyle(overflowStyle);
me.overflowStyleSet = true;
}
me.setUI(me.ui);
if (me.disabled) {
me.disabled = false;
me.disable(true);
}
},
doApplyRenderTpl: function(out, values) {
var me = values.$comp,
tpl;
if (!me.rendered) {
tpl = me.initRenderTpl();
tpl.applyOut(values.renderData, out);
}
},
doAutoRender: function() {
var me = this;
if (!me.rendered) {
if (me.floating) {
me.render(document.body);
} else {
me.render(Ext.isBoolean(me.autoRender) ? Ext.getBody() : me.autoRender);
}
}
},
doRenderContent: function (out, renderData) {
var me = renderData.$comp;
if (me.html) {
Ext.DomHelper.generateMarkup(me.html, out);
delete me.html;
}
if (me.tpl) {
if (!me.tpl.isTemplate) {
me.tpl = new Ext.XTemplate(me.tpl);
}
if (me.data) {
me.tpl.applyOut(me.data, out);
delete me.data;
}
}
},
doRenderFramingDockedItems: function (out, renderData, after) {
var me = renderData.$comp;
if (!me.rendered && me.doRenderDockedItems) {
renderData.renderData.$skipDockedItems = true;
me.doRenderDockedItems.call(this, out, renderData, after);
}
},
finishRender: function(containerIdx) {
var me = this,
tpl, data, el;
if (!me.el || me.$pid) {
if (me.container) {
el = me.container.getById(me.id, true);
} else {
el = Ext.getDom(me.id);
}
if (!me.el) {
me.wrapPrimaryEl(el);
} else {
delete me.$pid;
if (!me.el.dom) {
me.wrapPrimaryEl(me.el);
}
el.parentNode.insertBefore(me.el.dom, el);
Ext.removeNode(el); 
}
} else if (!me.rendering) {
tpl = me.initRenderTpl();
if (tpl) {
data = me.initRenderData();
tpl.insertFirst(me.getTargetEl(), data);
}
}
if (!me.container) {
me.container = Ext.get(me.el.dom.parentNode);
}
if (me.ctCls) {
me.container.addCls(me.ctCls);
}
me.onRender(me.container, containerIdx);
if (!me.overflowStyleSet) {
me.getOverflowEl().setStyle(me.getOverflowStyle());
}
me.el.setVisibilityMode(Ext.Element[me.hideMode.toUpperCase()]);
if (me.overCls) {
me.el.hover(me.addOverCls, me.removeOverCls, me);
}
if (me.hasListeners.render) {
me.fireEvent('render', me);
}
me.afterRender(); 
if (me.hasListeners.afterrender) {
me.fireEvent('afterrender', me);
}
me.initEvents();
if (me.hidden) {
me.el.hide();
}
},
finishRenderChildren: function () {
var layout = this.getComponentLayout();
layout.finishRender();
},
getElConfig : function() {
var me = this,
autoEl = me.autoEl,
frameInfo = me.getFrameInfo(),
config = {
tag: 'div',
tpl: frameInfo ? me.initFramingTpl(frameInfo.table) : me.initRenderTpl()
},
protoEl = me.protoEl,
i, frameElNames, len, suffix, frameGenId, frameData;
me.initStyles(protoEl);
protoEl.writeTo(config);
protoEl.flush();
if (Ext.isString(autoEl)) {
config.tag = autoEl;
} else {
Ext.apply(config, autoEl); 
}
config.id = me.id;
if (config.tpl) {
if (frameInfo) {
frameElNames = me.frameElNames;
len = frameElNames.length;
config.tplData = frameData = me.getFrameRenderData();
frameData.renderData = me.initRenderData();
frameGenId = frameData.fgid;
for (i = 0; i < len; i++) {
suffix = frameElNames[i];
me.addChildEls({ name: 'frame' + suffix, id: frameGenId + suffix });
}
me.addChildEls({
name: 'frameBody',
id: frameGenId + 'MC'
});
} else {
config.tplData = me.initRenderData();
}
}
return config;
},
initFramingTpl: function(table) {
var tpl = this.getFrameTpl(table);
if (tpl && !tpl.applyRenderTpl) {
this.setupFramingTpl(tpl);
}
return tpl;
},
setupFramingTpl: function(frameTpl) {
frameTpl.applyRenderTpl = this.doApplyRenderTpl;
frameTpl.renderDockedItems = this.doRenderFramingDockedItems;
},
getInsertPosition: function(position) {
if (position !== undefined) {
if (Ext.isNumber(position)) {
position = this.container.dom.childNodes[position];
}
else {
position = Ext.getDom(position);
}
}
return position;
},
getRenderTree: function() {
var me = this;
if (!me.hasListeners.beforerender || me.fireEvent('beforerender', me) !== false) {
me.beforeRender();
me.rendering = true;
if (me.el) {
return {
tag: 'div',
role: 'presentation',
id: (me.$pid = Ext.id())
};
}
return me.getElConfig();
}
return null;
},
initContainer: function(container) {
var me = this;
if (!container && me.el) {
container = me.el.dom.parentNode;
me.allowDomMove = false;
}
me.container = container.dom ? container : Ext.get(container);
return me.container;
},
initRenderData: function() {
var me = this;
return Ext.apply({
$comp: me,
id: me.id,
ui: me.ui,
uiCls: me.uiCls,
baseCls: me.baseCls,
componentCls: me.componentCls,
frame: me.frame,
role: me.ariaRole,
childElCls: '' 
}, me.renderData);
},
initRenderTpl: function() {
var tpl = this.getTpl('renderTpl');
if (tpl && !tpl.renderContent) {
this.setupRenderTpl(tpl);
}
return tpl;
},
onRender: function(parentNode, containerIdx) {
var me = this,
x = me.x,
y = me.y,
lastBox = null,
width, height,
el = me.el;
me.applyRenderSelectors();
me.rendering = null;
me.rendered = true;
if (x != null) {
lastBox = {x:x};
}
if (y != null) {
(lastBox = lastBox || {}).y = y;
}
if (!me.getFrameInfo() && Ext.isBorderBox) {
width = me.width;
height = me.height;
if (typeof width === 'number') {
lastBox = lastBox || {};
lastBox.width = width;
}
if (typeof height === 'number') {
lastBox = lastBox || {};
lastBox.height = height;
}
}
me.lastBox = el.lastBox = lastBox;
},
render: function(container, position) {
var me = this,
el = me.el && (me.el = Ext.get(me.el)), 
vetoed,
tree,
nextSibling;
Ext.suspendLayouts();
container = me.initContainer(container);
nextSibling = me.getInsertPosition(position);
if (!el) {
tree = me.getRenderTree();
if (me.ownerLayout && me.ownerLayout.transformItemRenderTree) {
tree = me.ownerLayout.transformItemRenderTree(tree);
}
if (tree) {
if (nextSibling) {
el = Ext.DomHelper.insertBefore(nextSibling, tree);
} else {
el = Ext.DomHelper.append(container, tree);
}
me.wrapPrimaryEl(el);
}
} else {
if (!me.hasListeners.beforerender || me.fireEvent('beforerender', me) !== false) {
me.beforeRender();
me.initStyles(el);
if (me.allowDomMove !== false) {
if (nextSibling) {
container.dom.insertBefore(el.dom, nextSibling);
} else {
container.dom.appendChild(el.dom);
}
}
} else {
vetoed = true;
}
}
if (el && !vetoed) {
me.finishRender(position);
}
Ext.resumeLayouts(!me.hidden && !container.isDetachedBody);
},
ensureAttachedToBody: function (runLayout) {
var comp = this,
body;
while (comp.ownerCt) {
comp = comp.ownerCt;
}
if (comp.container.isDetachedBody) {
comp.container = body = Ext.getBody();
body.appendChild(comp.el.dom);
if (runLayout) {
comp.updateLayout();
}
if (typeof comp.x == 'number' || typeof comp.y == 'number') {
comp.setPosition(comp.x, comp.y);
}
}
},
setupRenderTpl: function (renderTpl) {
renderTpl.renderBody = renderTpl.renderContent = this.doRenderContent;
},
wrapPrimaryEl: function (dom) {
this.el = Ext.get(dom, true);
},
initFrame : function() {
if (Ext.supports.CSS3BorderRadius || !this.frame) {
return;
}
var me = this,
frameInfo = me.getFrameInfo(),
frameTpl, frameGenId,
frameElNames = me.frameElNames,
len = frameElNames.length,
i, frameData, suffix;
if (frameInfo) {
frameTpl = me.getFrameTpl(frameInfo.table);
frameData = me.getFrameRenderData();
frameGenId = frameData.fgid;
frameTpl.insertFirst(me.el, frameData);
me.frameBody = me.el.down('.' + me.frameCls + '-mc');
me.removeChildEls(function (c) {
return c.id && me.frameIdRegex.test(c.id);
});
for (i = 0; i < len; i++) {
suffix = frameElNames[i];
me['frame' + suffix] = me.el.getById(frameGenId + suffix);
}
}
},
getFrameRenderData: function () {
var me = this,
frameInfo = me.frameSize,
frameGenId = (me.frameGenId || 0) + 1;
me.frameGenId = frameGenId;
return {
$comp:      me,
fgid:       me.id + '-frame' + frameGenId,
ui:         me.ui,
uiCls:      me.uiCls,
frameCls:   me.frameCls,
baseCls:    me.baseCls,
top:        !!frameInfo.top,
left:       !!frameInfo.left,
right:      !!frameInfo.right,
bottom:     !!frameInfo.bottom,
frameElCls: ''
};
},
updateFrame: function() {
if (Ext.supports.CSS3BorderRadius || !this.frame) {
return;
}
var me = this,
wasTable = me.frameSize && me.frameSize.table,
oldFrameTL = me.frameTL,
oldFrameBL = me.frameBL,
oldFrameML = me.frameML,
oldFrameMC = me.frameMC,
newMCClassName;
me.initFrame();
if (oldFrameMC) {
if (me.frame) {
newMCClassName = me.frameMC.dom.className;
oldFrameMC.insertAfter(me.frameMC);
me.frameMC.remove();
me.frameBody = me.frameMC = oldFrameMC;
oldFrameMC.dom.className = newMCClassName;
if (wasTable) {
me.el.query('> table')[1].remove();
}
else {
if (oldFrameTL) {
oldFrameTL.remove();
}
if (oldFrameBL) {
oldFrameBL.remove();
}
if (oldFrameML) {
oldFrameML.remove();
}
}
}
}
else if (me.frame) {
me.applyRenderSelectors();
}
},
getFrameInfo: function() {
if (Ext.supports.CSS3BorderRadius || !this.frame) {
return false;
}
var me = this,
frameInfoCache = me.frameInfoCache,
cls = me.getFramingInfoCls() + '-frameInfo',
frameInfo = frameInfoCache[cls],
max = Math.max,
styleEl, match, info, frameTop, frameRight, frameBottom, frameLeft,
borderWidthT, borderWidthR, borderWidthB, borderWidthL,
paddingT, paddingR, paddingB, paddingL,
borderRadiusTL, borderRadiusTR, borderRadiusBR, borderRadiusBL;
if (frameInfo == null) {
styleEl = Ext.fly(me.getStyleProxy(cls), 'frame-style-el');
info = styleEl.getStyle('font-family');
if (info) {
info = info.split('-');
borderRadiusTL = parseInt(info[1], 10);
borderRadiusTR = parseInt(info[2], 10);
borderRadiusBR = parseInt(info[3], 10);
borderRadiusBL = parseInt(info[4], 10);
borderWidthT   = parseInt(info[5], 10);
borderWidthR   = parseInt(info[6], 10);
borderWidthB   = parseInt(info[7], 10);
borderWidthL   = parseInt(info[8], 10);
paddingT       = parseInt(info[9], 10);
paddingR       = parseInt(info[10], 10);
paddingB       = parseInt(info[11], 10);
paddingL       = parseInt(info[12], 10);
frameTop    = max(borderWidthT, max(borderRadiusTL, borderRadiusTR));
frameRight  = max(borderWidthR, max(borderRadiusTR, borderRadiusBR));
frameBottom = max(borderWidthB, max(borderRadiusBL, borderRadiusBR));
frameLeft   = max(borderWidthL, max(borderRadiusTL, borderRadiusBL));
frameInfo = {
table: info[0].charAt(0) === 't',
vertical: info[0].charAt(1) === 'v',
top: frameTop,
right: frameRight,
bottom: frameBottom,
left: frameLeft,
width: frameLeft + frameRight,
height: frameTop + frameBottom,
maxWidth: max(frameTop, frameRight, frameBottom, frameLeft),
border: {
top:    borderWidthT,
right:  borderWidthR,
bottom: borderWidthB,
left:   borderWidthL,
width:  borderWidthL + borderWidthR,
height: borderWidthT + borderWidthB
},
padding: {
top:    paddingT,
right:  paddingR,
bottom: paddingB,
left:   paddingL,
width:  paddingL + paddingR,
height: paddingT + paddingB
},
radius: {
tl: borderRadiusTL,
tr: borderRadiusTR,
br: borderRadiusBR,
bl: borderRadiusBL
}
};
} else {
frameInfo = false;
}
frameInfoCache[cls] = frameInfo;
}
me.frame = !!frameInfo;
me.frameSize = frameInfo;
return frameInfo;
},
getFramingInfoCls: function(){
return this.baseCls + '-' + this.ui;
},
getStyleProxy: function(cls) {
var result = this.styleProxyEl || (Ext.AbstractComponent.prototype.styleProxyEl = Ext.getBody().createChild({
role: 'presentation',
style: {
position: 'absolute',
top: '-10000px'
}
}, null, true));
result.className = cls;
return result;
},
getFrameTpl : function(table) {
return this.getTpl(table ? 'frameTableTpl' : 'frameTpl');
},
frameInfoCache: {}
});
Ext.define('Ext.state.Stateful', {
mixins: {
observable:  Ext.util.Observable 
},
stateful: false,
saveDelay: 100,
constructor: function(config) {
var me = this;
config = config || {};
if (config.stateful !== undefined) {
me.stateful = config.stateful;
}
if (config.saveDelay !== undefined) {
me.saveDelay = config.saveDelay;
}
me.stateId = me.stateId || config.stateId;
if (!me.stateEvents) {
me.stateEvents = [];
}
if (config.stateEvents) {
me.stateEvents.concat(config.stateEvents);
}
this.addEvents(
'beforestaterestore',
'staterestore',
'beforestatesave',
'statesave'
);
me.mixins.observable.constructor.call(me);
if (me.stateful !== false) {
me.addStateEvents(me.stateEvents);
me.initState();
}
},
addStateEvents: function (events) {
var me = this,
i, event, stateEventsByName;
if (me.stateful && me.getStateId()) {
if (typeof events == 'string') {
events = Array.prototype.slice.call(arguments, 0);
}
stateEventsByName = me.stateEventsByName || (me.stateEventsByName = {});
for (i = events.length; i--; ) {
event = events[i];
if (!stateEventsByName[event]) {
stateEventsByName[event] = 1;
me.on(event, me.onStateChange, me);
}
}
}
},
onStateChange: function(){
var me = this,
delay = me.saveDelay,
statics, runner;
if (!me.stateful) {
return;
}
if (delay) {
if (!me.stateTask) {
statics = Ext.state.Stateful;
runner = statics.runner || (statics.runner = new Ext.util.TaskRunner());
me.stateTask = runner.newTask({
run: me.saveState,
scope: me,
interval: delay,
repeat: 1
});
}
me.stateTask.start();
} else {
me.saveState();
}
},
saveState: function() {
var me = this,
id = me.stateful && me.getStateId(),
hasListeners = me.hasListeners,
state;
if (id) {
state = me.getState() || {};    
if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) {
Ext.state.Manager.set(id, state);
if (hasListeners.statesave) {
me.fireEvent('statesave', me, state);
}
}
}
},
getState: function(){
return null;
},
applyState: function(state) {
if (state) {
Ext.apply(this, state);
}
},
getStateId: function() {
var me = this;
return me.stateId || (me.autoGenId ? null : me.id);
},
initState: function(){
var me = this,
id = me.stateful && me.getStateId(),
hasListeners = me.hasListeners,
state;
if (id) {
state = Ext.state.Manager.get(id);
if (state) {
state = Ext.apply({}, state);
if (!hasListeners.beforestaterestore || me.fireEvent('beforestaterestore', me, state) !== false) {
me.applyState(state);
if (hasListeners.staterestore) {
me.fireEvent('staterestore', me, state);
}
}
}
}
},
savePropToState: function (propName, state, stateName) {
var me = this,
value = me[propName],
config = me.initialConfig;
if (me.hasOwnProperty(propName)) {
if (!config || config[propName] !== value) {
if (state) {
state[stateName || propName] = value;
}
return true;
}
}
return false;
},
savePropsToState: function (propNames, state) {
var me = this,
i, n;
if (typeof propNames == 'string') {
me.savePropToState(propNames, state);
} else {
for (i = 0, n = propNames.length; i < n; ++i) {
me.savePropToState(propNames[i], state);
}
}
return state;
},
destroy: function(){
var me = this,
task = me.stateTask;
if (task) {
task.destroy();
me.stateTask = null;
}
me.clearListeners();
}
});
Ext.define('Ext.AbstractComponent', {
mixins: {
positionable:  Ext.util.Positionable ,
observable:  Ext.util.Observable ,
animate:  Ext.util.Animate ,
elementCt:  Ext.util.ElementContainer ,
renderable:  Ext.util.Renderable ,
state:  Ext.state.Stateful 
},
statics: {
AUTO_ID: 1000,
pendingLayouts: null,
layoutSuspendCount: 0,
cancelLayout: function(comp, isDestroying) {
var context = this.runningLayoutContext || this.pendingLayouts;
if (context) {
context.cancelComponent(comp, false, isDestroying);
}
},
flushLayouts: function () {
var me = this,
context = me.pendingLayouts;
if (context && context.invalidQueue.length) {
me.pendingLayouts = null;
me.runningLayoutContext = context;
Ext.override(context, {
runComplete: function () {
me.runningLayoutContext = null;
var result = this.callParent(); 
if (Ext.globalEvents.hasListeners.afterlayout) {                            
Ext.globalEvents.fireEvent('afterlayout');
}
return result;
}
});
context.run();
}
},
resumeLayouts: function (flush) {
if (this.layoutSuspendCount && ! --this.layoutSuspendCount) {
if (flush) {
this.flushLayouts();
}
if (Ext.globalEvents.hasListeners.resumelayouts) {
Ext.globalEvents.fireEvent('resumelayouts');
}
}
},
suspendLayouts: function () {
++this.layoutSuspendCount;
},
updateLayout: function (comp, defer) {
var me = this,
running = me.runningLayoutContext,
pending;
if (running) {
running.queueInvalidate(comp);
} else {
pending = me.pendingLayouts || (me.pendingLayouts = new Ext.layout.Context());
pending.queueInvalidate(comp);
if (!defer && !me.layoutSuspendCount && !comp.isLayoutSuspended()) {
me.flushLayouts();
}
}
}
},
isComponent: true,
getAutoId: function() {
this.autoGenId = true;
return ++Ext.AbstractComponent.AUTO_ID;
},
deferLayouts: false,
autoGenId: false,
renderTpl: '{%this.renderContent(out,values)%}',
frameSize: null,
tplWriteMode: 'overwrite',
baseCls: Ext.baseCSSPrefix + 'component',
disabledCls: Ext.baseCSSPrefix + 'item-disabled',
ui: 'default',
uiCls: [],
hidden: false,
disabled: false,
draggable: false,
floating: false,
hideMode: 'display',
autoShow: false,
autoRender: false,
allowDomMove: true,
rendered: false,
componentLayoutCounter: 0,
shrinkWrap: 2,
weight: 0,
maskOnDisable: true,
_isLayoutRoot: false,
contentPaddingProperty: 'padding',
horizontalPosProp: 'left',
borderBoxCls: Ext.baseCSSPrefix + 'border-box',
rootCls: Ext.baseCSSPrefix + 'body',
constructor : function(config) {
var me = this,
i, len, xhooks;
if (config) {
Ext.apply(me, config);
xhooks = me.xhooks;
if (xhooks) {
delete me.xhooks;
Ext.override(me, xhooks);
}
} else {
config = {};
}
me.initialConfig = config;
me.mixins.elementCt.constructor.call(me);
me.addEvents(
'beforeactivate',
'activate',
'beforedeactivate',
'deactivate',
'added',
'disable',
'enable',
'beforeshow',
'show',
'beforehide',
'hide',
'removed',
'beforerender',
'render',
'afterrender',
'boxready',
'beforedestroy',
'destroy',
'resize',
'move',
'focus',
'blur'
);
me.getId();
me.setupProtoEl();
if (me.cls) {
me.initialCls = me.cls;
me.protoEl.addCls(me.cls);
}
if (me.style) {
me.initialStyle = me.style;
me.protoEl.setStyle(me.style);
}
me.renderData = me.renderData || {};
me.renderSelectors = me.renderSelectors || {};
if (me.plugins) {
me.plugins = me.constructPlugins();
}
if (!me.hasListeners) {
me.hasListeners = new me.HasListeners();
}
me.initComponent();
Ext.ComponentManager.register(me);
me.mixins.observable.constructor.call(me);
me.mixins.state.constructor.call(me, config);
this.addStateEvents('resize');
if (me.plugins) {
for (i = 0, len = me.plugins.length; i < len; i++) {
me.plugins[i] = me.initPlugin(me.plugins[i]);
}
}
me.loader = me.getLoader();
if (me.renderTo) {
me.render(me.renderTo);
}
if (me.autoShow && !me.isContained) {
me.show();
}
},
initComponent: function () {
var me = this;
if (me.plugins && !me.plugins.processed) {
me.plugins = me.constructPlugins();
}
me.setSize(me.width, me.height);
},
getState: function() {
var me = this,
state = null,
sizeModel = me.getSizeModel();
if (sizeModel.width.configured) {
state = me.addPropertyToState(state, 'width');
}
if (sizeModel.height.configured) {
state = me.addPropertyToState(state, 'height');
}
return state;
},
addPropertyToState: function (state, propName, value) {
var me = this,
len = arguments.length;
if (len == 3 || me.hasOwnProperty(propName)) {
if (len < 3) {
value = me[propName];
}
if (value !== me.initialConfig[propName]) {
(state || (state = {}))[propName] = value;
}
}
return state;
},
show: Ext.emptyFn,
animate: function(animObj) {
var me = this,
hasToWidth,
hasToHeight,
toHeight,
toWidth,
to,
clearWidth,
clearHeight,
curWidth, w, curHeight, h, isExpanding,
wasConstrained,
wasConstrainedHeader,
passedCallback,
oldOverflow;
animObj = animObj || {};
to = animObj.to || {};
if (Ext.fx.Manager.hasFxBlock(me.id)) {
return me;
}
hasToWidth = Ext.isDefined(to.width);
if (hasToWidth) {
toWidth = Ext.Number.constrain(to.width, me.minWidth, me.maxWidth);
}
hasToHeight = Ext.isDefined(to.height);
if (hasToHeight) {
toHeight = Ext.Number.constrain(to.height, me.minHeight, me.maxHeight);
}
if (!animObj.dynamic && (hasToWidth || hasToHeight)) {
curWidth = (animObj.from ? animObj.from.width : undefined) || me.getWidth();
w = curWidth;
curHeight = (animObj.from ? animObj.from.height : undefined) || me.getHeight();
h = curHeight;
isExpanding = false;
if (hasToHeight && toHeight > curHeight) {
h = toHeight;
isExpanding = true;
}
if (hasToWidth && toWidth > curWidth) {
w = toWidth;
isExpanding = true;
}
if (hasToHeight || hasToWidth) {
oldOverflow = me.el.getStyle('overtflow');
if (oldOverflow !== 'hidden') {
me.el.setStyle('overflow', 'hidden');
}
}
if (isExpanding) {
clearWidth = !Ext.isNumber(me.width);
clearHeight = !Ext.isNumber(me.height);
me.setSize(w, h);
me.el.setSize(curWidth, curHeight);
if (clearWidth) {
me.width = void 0;
}
if (clearHeight) {
me.height = void 0;
}
}
if (hasToWidth) {
to.width = toWidth;
}
if (hasToHeight) {
to.height = toHeight;
}
}
wasConstrained = me.constrain;
wasConstrainedHeader = me.constrainHeader;
if (wasConstrained || wasConstrainedHeader) {
me.constrain = me.constrainHeader = false;
passedCallback = animObj.callback;
animObj.callback = function() {
me.constrain = wasConstrained;
me.constrainHeader = wasConstrainedHeader;
if (passedCallback) {
passedCallback.call(animObj.scope||me, arguments);
}
if (oldOverflow !== 'hidden') {
me.el.setStyle('overflow', oldOverflow);
}
};
}
return me.mixins.animate.animate.apply(me, arguments);
},
setHiddenState: function(hidden){
var hierarchyState = this.getHierarchyState();
this.hidden = hidden;
if (hidden) {
hierarchyState.hidden = true;
} else {
delete hierarchyState.hidden;
}
},
onHide: function() {
if (this.ownerLayout) {
this.updateLayout({ isRoot: false });
}
},
onShow : function() {
this.updateLayout({ isRoot: false });
},
constructPlugin: function(plugin) {
var me = this;
if (typeof plugin == 'string') {
plugin = Ext.PluginManager.create({}, plugin, me);
}
else {
plugin = Ext.PluginManager.create(plugin, null, me);
}
return plugin;
},
constructPlugins: function() {
var me = this,
plugins = me.plugins,
result, i, len;
if (plugins) {
result = [];
result.processed = true;
if (!Ext.isArray(plugins)) {
plugins = [ plugins ];
}
for (i = 0, len = plugins.length; i < len; i++) {
result[i] = me.constructPlugin(plugins[i]);
}
}
me.pluginsInitialized = true;
return result;
},
initPlugin : function(plugin) {
plugin.init(this);
return plugin;
},
addPlugin: function(plugin) {
var me = this;
plugin = me.constructPlugin(plugin);
if (me.plugins) {
me.plugins.push(plugin);
} else {
me.plugins = [ plugin ];
}
if (me.pluginsInitialized) {
me.initPlugin(plugin);
}
return plugin;
},
removePlugin: function(plugin) {
Ext.Array.remove(this.plugins, plugin);
plugin.destroy();
},
findPlugin: function(ptype) {
var i,
plugins = this.plugins,
ln = plugins && plugins.length;
for (i = 0; i < ln; i++) {
if (plugins[i].ptype === ptype) {
return plugins[i];
}
}
},
getPlugin: function(pluginId) {
var i,
plugins = this.plugins,
ln = plugins && plugins.length;
for (i = 0; i < ln; i++) {
if (plugins[i].pluginId === pluginId) {
return plugins[i];
}
}
},
beforeLayout: Ext.emptyFn,
registerFloatingItem: function(cmp) {
var me = this;
if (!me.floatingDescendants) {
me.floatingDescendants = new Ext.ZIndexManager(me);
}
me.floatingDescendants.register(cmp);
},
unregisterFloatingItem: function(cmp) {
var me = this;
if (me.floatingDescendants) {
me.floatingDescendants.unregister(cmp);
}
},
layoutSuspendCount: 0,
suspendLayouts: function () {
var me = this;
if (!me.rendered) {
return;
}
if (++me.layoutSuspendCount == 1) {
me.suspendLayout = true;
}
},
resumeLayouts: function (flushOptions) {
var me = this;
if (!me.rendered) {
return;
}
if (! --me.layoutSuspendCount) {
me.suspendLayout = false;
if (flushOptions && !me.isLayoutSuspended()) {
me.updateLayout(flushOptions);
}
}
},
setupProtoEl: function() {
var cls = this.initCls();
this.protoEl = new Ext.util.ProtoElement({
cls: cls.join(' ') 
});
},
initCls: function() {
var me = this,
cls = [ me.baseCls, me.getComponentLayout().targetCls ];
if (Ext.isDefined(me.cmpCls)) {
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.warn('Ext.Component: cmpCls has been deprecated. Please use componentCls.');
}
me.componentCls = me.cmpCls;
delete me.cmpCls;
}
if (me.componentCls) {
cls.push(me.componentCls);
} else {
me.componentCls = me.baseCls;
}
return cls;
},
setUI: function(ui) {
var me = this,
uiCls = me.uiCls,
activeUI = me.activeUI,
classes;
if (ui === activeUI) {
return;
}
if (activeUI) {
classes = me.removeClsWithUI(uiCls, true);
if (classes.length) {
me.removeCls(classes);
}
me.removeUIFromElement();
}
else {
me.uiCls = [];
}
me.ui = ui;
me.activeUI = ui;
me.addUIToElement();
classes = me.addClsWithUI(uiCls, true);
if (classes.length) {
me.addCls(classes);
}
if (me.rendered) {
me.updateLayout();
}
},
addClsWithUI: function(classes, skip) {
var me = this,
clsArray = [],
i = 0,
uiCls = me.uiCls = Ext.Array.clone(me.uiCls),
activeUI = me.activeUI,
length,
cls;
if (typeof classes === "string") {
classes = (classes.indexOf(' ') < 0) ? [classes] : Ext.String.splitWords(classes);
}
length = classes.length;
for (; i < length; i++) {
cls = classes[i];
if (cls && !me.hasUICls(cls)) {
uiCls.push(cls);
if (activeUI) {
clsArray = clsArray.concat(me.addUIClsToElement(cls));
}
}
}
if (skip !== true && activeUI) {
me.addCls(clsArray);
}
return clsArray;
},
removeClsWithUI: function(classes, skip) {
var me = this,
clsArray = [],
i = 0,
extArray = Ext.Array,
remove = extArray.remove,
uiCls = me.uiCls = extArray.clone(me.uiCls),
activeUI = me.activeUI,
length, cls;
if (typeof classes === "string") {
classes = (classes.indexOf(' ') < 0) ? [classes] : Ext.String.splitWords(classes);
}
length = classes.length;
for (i = 0; i < length; i++) {
cls = classes[i];
if (cls && me.hasUICls(cls)) {
remove(uiCls, cls);
if (activeUI) {
clsArray = clsArray.concat(me.removeUIClsFromElement(cls));
}
}
}
if (skip !== true && activeUI) {
me.removeCls(clsArray);
}
return clsArray;
},
hasUICls: function(cls) {
var me = this,
uiCls = me.uiCls || [];
return Ext.Array.contains(uiCls, cls);
},
frameElementsArray: ['tl', 'tc', 'tr', 'ml', 'mc', 'mr', 'bl', 'bc', 'br'],
addUIClsToElement: function(cls) {
var me = this,
baseClsUi = me.baseCls + '-' + me.ui + '-' + cls,
result = [Ext.baseCSSPrefix + cls, me.baseCls + '-' + cls, baseClsUi],
frameElementsArray, frameElementsLength, i, el, frameElement;
if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
frameElementsArray = me.frameElementsArray;
frameElementsLength = frameElementsArray.length;
for (i = 0; i < frameElementsLength; i++) {
frameElement = frameElementsArray[i];
el = me['frame' + frameElement.toUpperCase()];
if (el) {
el.addCls(baseClsUi + '-' + frameElement);
}
}
}
return result;
},
removeUIClsFromElement: function(cls) {
var me = this,
baseClsUi = me.baseCls + '-' + me.ui + '-' + cls,
result = [Ext.baseCSSPrefix + cls, me.baseCls + '-' + cls, baseClsUi],
frameElementsArray, frameElementsLength, i, el, frameElement;
if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
frameElementsArray = me.frameElementsArray;
frameElementsLength = frameElementsArray.length;
for (i = 0; i < frameElementsLength; i++) {
frameElement = frameElementsArray[i];
el = me['frame' + frameElement.toUpperCase()];
if (el) {
el.removeCls(baseClsUi + '-' + frameElement);
}
}
}
return result;
},
addUIToElement: function() {
var me = this,
baseClsUI = me.baseCls + '-' + me.ui,
frameElementsArray, frameElementsLength, i, el, frameElement;
me.addCls(baseClsUI);
if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
frameElementsArray = me.frameElementsArray;
frameElementsLength = frameElementsArray.length;
for (i = 0; i < frameElementsLength; i++) {
frameElement = frameElementsArray[i];
el = me['frame' + frameElement.toUpperCase()];
if (el) {
el.addCls(baseClsUI + '-' + frameElement);
}
}
}
},
removeUIFromElement: function() {
var me = this,
baseClsUI = me.baseCls + '-' + me.ui,
frameElementsArray, frameElementsLength, i, el, frameElement;
me.removeCls(baseClsUI);
if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
frameElementsArray = me.frameElementsArray;
frameElementsLength = frameElementsArray.length;
for (i = 0; i < frameElementsLength; i++) {
frameElement = frameElementsArray[i];
el = me['frame' + frameElement.toUpperCase()];
if (el) {
el.removeCls(baseClsUI + '-' + frameElement);
}
}
}
},
getTpl: function(name) {
return Ext.XTemplate.getTpl(this, name);
},
initStyles: function(targetEl) {
var me = this,
Element = Ext.Element,
margin = me.margin,
border = me.border,
cls = me.cls,
style = me.style,
x = me.x,
y = me.y,
width, height;
me.initPadding(targetEl);
if (margin != null) {
targetEl.setStyle('margin', this.unitizeBox((margin === true) ? 5 : margin));
}
if (border != null) {
me.setBorder(border, targetEl);
}
if (cls && cls != me.initialCls) {
targetEl.addCls(cls);
me.cls = me.initialCls = null;
}
if (style && style != me.initialStyle) {
targetEl.setStyle(style);
me.style = me.initialStyle = null;
}
if (x != null) {
targetEl.setStyle(me.horizontalPosProp, (typeof x == 'number') ? (x + 'px') : x);
}
if (y != null) {
targetEl.setStyle('top', (typeof y == 'number') ? (y + 'px') : y);
}
if (!me.ownerCt || me.floating) {
if (Ext.scopeCss) {
targetEl.addCls(me.rootCls);
}
if (Ext.isBorderBox) {
targetEl.addCls(me.borderBoxCls);
}
}
if (!me.getFrameInfo()) {
width = me.width;
height = me.height;
if (width != null) {
if (typeof width === 'number') {
if (Ext.isBorderBox) {
targetEl.setStyle('width', width + 'px');
}
} else {
targetEl.setStyle('width', width);
}
}
if (height != null) {
if (typeof height === 'number') {
if (Ext.isBorderBox) {
targetEl.setStyle('height', height + 'px');
}
} else {
targetEl.setStyle('height', height);
}
}
}
},
initPadding: function(targetEl) {
var me = this,
padding = me.padding;
if (padding != null) {
if (me.layout && me.layout.managePadding && me.contentPaddingProperty === 'padding') {
targetEl.setStyle('padding', 0);
} else {
targetEl.setStyle('padding', this.unitizeBox((padding === true) ? 5 : padding));
}
}
},
parseBox: function(box) {
return Ext.dom.Element.parseBox(box);    
},
unitizeBox: function(box) {
return Ext.dom.Element.unitizeBox(box);    
},
setMargin: function(margin,  preventLayout) {
var me = this;
if (me.rendered) {
if (!margin && margin !== 0) {
margin = '';
} else {
if (margin === true) {
margin = 5;
}
margin = this.unitizeBox(margin);
}
me.getTargetEl().setStyle('margin', margin);
if (!preventLayout) {
me.updateLayout();
}
} else {
me.margin = margin;
}
},
initEvents : function() {
var me = this,
afterRenderEvents = me.afterRenderEvents,
afterRenderEvent, el, property, index, len;
if (afterRenderEvents) {
for (property in afterRenderEvents) {
el = me[property];
if (el && el.on) {
afterRenderEvent = afterRenderEvents[property];
for (index = 0, len = afterRenderEvent.length ; index < len ; ++index) {
me.mon(el, afterRenderEvent[index]);
}
}
}
}
me.addFocusListener();
},
addFocusListener: function() {
var me = this,
focusEl = me.getFocusEl(),
needsTabIndex;
if (focusEl) {
if (focusEl.isComponent) {
return focusEl.addFocusListener();
}
needsTabIndex = focusEl.needsTabIndex();
if (!me.focusListenerAdded && (!needsTabIndex || Ext.FocusManager.enabled)) {
if (needsTabIndex) {
focusEl.dom.tabIndex = -1;
}
focusEl.on({
focus: me.onFocus,
blur: me.onBlur,
scope: me
});
me.focusListenerAdded = true;
}
}
},
getFocusEl: Ext.emptyFn,
isFocusable: function() {
var me = this,
focusEl;
if ((me.focusable !== false) && (focusEl = me.getFocusEl()) && me.rendered && !me.destroying && !me.isDestroyed && !me.disabled && me.isVisible(true)) {
return focusEl.isFocusable(true);
}
},
beforeFocus: Ext.emptyFn,
onFocus: function(e) {
var me = this,
focusCls = me.focusCls,
focusEl = me.getFocusEl();
if (!me.disabled) {
me.beforeFocus(e);
if (focusCls && focusEl) {
focusEl.addCls(me.addClsWithUI(focusCls, true));
}
if (!me.hasFocus) {
me.hasFocus = true;
me.fireEvent('focus', me, e);
}
}
},
beforeBlur : Ext.emptyFn,
onBlur : function(e) {
var me = this,
focusCls = me.focusCls,
focusEl = me.getFocusEl();
if (me.destroying) {
return;
}
me.beforeBlur(e);
if (focusCls && focusEl) {
focusEl.removeCls(me.removeClsWithUI(focusCls, true));
}
if (me.validateOnBlur) {
me.validate();
}
me.hasFocus = false;
me.fireEvent('blur', me, e);
me.postBlur(e);
},
postBlur : Ext.emptyFn,
is: function(selector) {
return Ext.ComponentQuery.is(this, selector);
},
up: function (selector, limit) {
var result = this.getRefOwner(),
limitSelector = typeof limit === 'string',
limitCount = typeof limit === 'number',
limitComponent = limit && limit.isComponent,
steps = 0;
if (selector) {
for (; result; result = result.getRefOwner()) {
steps++;
if (selector.isComponent) {
if (result === selector) {
return result;
}
} else {
if (Ext.ComponentQuery.is(result, selector)) {
return result;
}
}
if (limitSelector && result.is(limit)) {
return;
}
if (limitCount && steps === limit) {
return;
}
if (limitComponent && result === limit) {
return;
}
}
}
return result;
},
nextSibling: function(selector) {
var o = this.ownerCt, it, last, idx, c;
if (o) {
it = o.items;
idx = it.indexOf(this) + 1;
if (idx) {
if (selector) {
for (last = it.getCount(); idx < last; idx++) {
if ((c = it.getAt(idx)).is(selector)) {
return c;
}
}
} else {
if (idx < it.getCount()) {
return it.getAt(idx);
}
}
}
}
return null;
},
previousSibling: function(selector) {
var o = this.ownerCt, it, idx, c;
if (o) {
it = o.items;
idx = it.indexOf(this);
if (idx != -1) {
if (selector) {
for (--idx; idx >= 0; idx--) {
if ((c = it.getAt(idx)).is(selector)) {
return c;
}
}
} else {
if (idx) {
return it.getAt(--idx);
}
}
}
}
return null;
},
previousNode: function(selector,  includeSelf) {
var node = this,
ownerCt = node.ownerCt,
result,
it, i, sib;
if (includeSelf && node.is(selector)) {
return node;
}
if (ownerCt) {
for (it = ownerCt.items.items, i = Ext.Array.indexOf(it, node) - 1; i > -1; i--) {
sib = it[i];
if (sib.query) {
result = sib.query(selector);
result = result[result.length - 1];
if (result) {
return result;
}
}
if (sib.is(selector)) {
return sib;
}
}
return ownerCt.previousNode(selector, true);
}
return null;
},
nextNode: function(selector,  includeSelf) {
var node = this,
ownerCt = node.ownerCt,
result,
it, len, i, sib;
if (includeSelf && node.is(selector)) {
return node;
}
if (ownerCt) {
for (it = ownerCt.items.items, i = Ext.Array.indexOf(it, node) + 1, len = it.length; i < len; i++) {
sib = it[i];
if (sib.is(selector)) {
return sib;
}
if (sib.down) {
result = sib.down(selector);
if (result) {
return result;
}
}
}
return ownerCt.nextNode(selector);
}
return null;
},
getId : function() {
return this.id || (this.id = 'ext-comp-' + (this.getAutoId()));
},
getItemId : function() {
return this.itemId || this.id;
},
getEl : function() {
return this.el;
},
getTargetEl: function() {
return this.frameBody || this.el;
},
getOverflowEl: function(){
return this.getTargetEl();
},
getOverflowStyle: function() {
var me = this,
result = null,
auto = me.autoScroll,
ox, oy,
overflowStyle;
if (typeof auto === 'boolean') {
result = {
overflow: overflowStyle = (auto ? 'auto' : '')
};
me.scrollFlags = {
overflowX: overflowStyle,
overflowY: overflowStyle,
x: auto,
y: auto,
both: auto
};
} else {
ox = me.overflowX;
oy = me.overflowY;
if (ox !== undefined || oy !== undefined) {
if (ox && ox === true) {
ox = 'auto';
}
if (oy && oy === true) {
oy = 'auto';
}
result = {
'overflowX':  ox = ox || '',
'overflowY':  oy = oy || ''
};
me.scrollFlags = {
overflowX: ox,
overflowY: oy,
x: ox = (ox === 'auto' || ox === 'scroll'),
y: oy = (oy === 'auto' || oy === 'scroll'),
both: ox && oy
};
} else {
me.scrollFlags = {
overflowX: '',
overflowY: '',
x: false,
y: false,
both: false
};
}
}
if (result && Ext.isIE7m) {
result.position = 'relative';
}
return result;
},
isXType: function(xtype, shallow) {
if (shallow) {
return this.xtype === xtype;
}
else {
return this.xtypesMap[xtype];
}
},
getXTypes: function() {
var self = this.self,
xtypes, parentPrototype, parentXtypes;
if (!self.xtypes) {
xtypes = [];
parentPrototype = this;
while (parentPrototype) {
parentXtypes = parentPrototype.xtypes;
if (parentXtypes !== undefined) {
xtypes.unshift.apply(xtypes, parentXtypes);
}
parentPrototype = parentPrototype.superclass;
}
self.xtypeChain = xtypes;
self.xtypes = xtypes.join('/');
}
return self.xtypes;
},
update : function(htmlOrData, loadScripts, cb) {
var me = this,
isData = (me.tpl && !Ext.isString(htmlOrData)),
el;
if (isData) {
me.data = htmlOrData;
} else {
me.html = Ext.isObject(htmlOrData) ? Ext.DomHelper.markup(htmlOrData) : htmlOrData;
}
if (me.rendered) {
el = me.isContainer ? me.layout.getRenderTarget() : me.getTargetEl();
if (isData) {
me.tpl[me.tplWriteMode](el, htmlOrData || {});
} else {
el.update(me.html, loadScripts, cb);
}
me.updateLayout();
}
},
setVisible : function(visible) {
return this[visible ? 'show': 'hide']();
},
isVisible: function(deep) {
var me = this,
hidden;
if (me.hidden || !me.rendered || me.isDestroyed) {
hidden = true;
} else if (deep) {
hidden = me.isHierarchicallyHidden();
}
return !hidden;
},
isHierarchicallyHidden: function() {
var child = this,
hidden = false,
parent, parentHierarchyState;
for (; (parent = child.ownerCt || child.floatParent); child = parent) {
parentHierarchyState = parent.getHierarchyState();
if (parentHierarchyState.hidden) {
hidden = true;
break;
}
if (child.getHierarchyState().collapseImmune) {
if (parent.collapsed && !child.collapseImmune) {
hidden = true;
break;
}
} else {
hidden = !!parentHierarchyState.collapsed;
break;
}
}
return hidden;
},
onBoxReady: function(width, height) {
var me = this;
if (me.disableOnBoxReady) {
me.onDisable();
} else if (me.enableOnBoxReady) {
me.onEnable();
}
if (me.resizable) {
me.initResizable(me.resizable);
}
if (me.draggable) {
me.initDraggable();
}
if (me.hasListeners.boxready) {
me.fireEvent('boxready', me, width, height);
}
},
enable: function(silent) {
var me = this;
if(!me.disabled) return me;
me.disabled = false;
me.removeCls(me.disabledCls);
if (me.rendered) {
me.onEnable();
} else {
me.enableOnBoxReady = true;
}
me.disableOnBoxReady && (me.disableOnBoxReady = false);
me.resetDisable && (me.resetDisable = false);
if (silent !== true) {
me.fireEvent('enable', me);
}
return me;
},
disable: function(silent) {
var me = this;
if(me.disabled) return me;
me.disabled = true;
me.enableOnBoxReady && (me.enableOnBoxReady = false);
me.addCls(me.disabledCls);
if (me.rendered) {
me.onDisable();
} else {
me.disableOnBoxReady = true;
}
if (silent !== true) {
me.resetDisable && (me.resetDisable = false);
me.fireEvent('disable', me);
}
return me;
},
onEnable: function() {
if (this.maskOnDisable) {
this.el.dom.disabled = false;
this.unmask();
}
},
onDisable : function() {
var me = this,
focusCls = me.focusCls,
focusEl = me.getFocusEl();
if (focusCls && focusEl) {
focusEl.removeCls(me.removeClsWithUI(focusCls, true));
}
if (me.maskOnDisable) {
me.el.dom.disabled = true;
me.mask();
}
},
mask: function (msg, msgCls, elHeight) {
var box = this.lastBox,
target = this.getMaskTarget();
if (box) {
elHeight = box.height;
}
target.mask(msg, msgCls, elHeight);
},
unmask: function() {
this.getMaskTarget().unmask();
},
getMaskTarget: function(){
return this.el;
},
isDisabled : function() {
return this.disabled;
},
setDisabled : function(disabled) {
return this[disabled ? 'disable': 'enable']();
},
isHidden : function() {
return this.hidden;
},
addCls : function(cls) {
var me = this,
el = me.rendered ? me.el : me.protoEl;
el.addCls.apply(el, arguments);
return me;
},
addClass : function() {
return this.addCls.apply(this, arguments);
},
hasCls: function (cls) {
var me = this,
el = me.rendered ? me.el : me.protoEl;
return el.hasCls.apply(el, arguments);
},
removeCls : function(cls) {
var me = this,
el = me.rendered ? me.el : me.protoEl;
el.removeCls.apply(el, arguments);
return me;
},
addOverCls: function() {
var me = this;
if (!me.disabled) {
me.el.addCls(me.overCls);
}
},
removeOverCls: function() {
this.el.removeCls(this.overCls);
},
addListener : function(element, listeners, scope, options) {
var me = this,
fn,
option;
if (Ext.isString(element) && (Ext.isObject(listeners) || options && options.element)) {
if (options.element) {
fn = listeners;
listeners = {};
listeners[element] = fn;
element = options.element;
if (scope) {
listeners.scope = scope;
}
for (option in options) {
if (options.hasOwnProperty(option)) {
if (me.eventOptionsRe.test(option)) {
listeners[option] = options[option];
}
}
}
}
if (me[element] && me[element].on) {
me.mon(me[element], listeners);
} else {
me.afterRenderEvents = me.afterRenderEvents || {};
if (!me.afterRenderEvents[element]) {
me.afterRenderEvents[element] = [];
}
me.afterRenderEvents[element].push(listeners);
}
return;
}
return me.mixins.observable.addListener.apply(me, arguments);
},
removeManagedListenerItem: function(isClear, managedListener, item, ename, fn, scope){
var me = this,
element = managedListener.options ? managedListener.options.element : null;
if (element) {
element = me[element];
if (element && element.un) {
if (isClear || (managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope))) {
element.un(managedListener.ename, managedListener.fn, managedListener.scope);
if (!isClear) {
Ext.Array.remove(me.managedListeners, managedListener);
}
}
}
} else {
return me.mixins.observable.removeManagedListenerItem.apply(me, arguments);
}
},
getBubbleTarget : function() {
return this.ownerCt;
},
isFloating : function() {
return this.floating;
},
isDraggable : function() {
return !!this.draggable;
},
isDroppable : function() {
return !!this.droppable;
},
onAdded : function(container, pos) {
var me = this;
me.ownerCt = container;
if (me.hierarchyState) {
me.hierarchyState.invalid = true;
delete me.hierarchyState;
}
if (me.hasListeners.added) {
me.fireEvent('added', me, container, pos);
}
},
onRemoved : function(destroying) {
var me = this;
if (me.hasListeners.removed) {
me.fireEvent('removed', me, me.ownerCt);
}
delete me.ownerCt;
delete me.ownerLayout;
},
beforeDestroy : Ext.emptyFn,
onResize: function(width, height, oldWidth, oldHeight) {
var me = this;
if (me.floating && me.constrain) {
me.doConstrain();
}
if (me.hasListeners.resize) {
me.fireEvent('resize', me, width, height, oldWidth, oldHeight);
}
},
setSize : function(width, height) {
var me = this;
if (width && typeof width == 'object') {
height = width.height;
width  = width.width;
}
if (typeof width == 'number') {
me.width = Ext.Number.constrain(width, me.minWidth, me.maxWidth);
}
if (typeof height == 'number') {
me.height = Ext.Number.constrain(height, me.minHeight, me.maxHeight);
}
if (me.rendered && me.isVisible()) {
me.updateLayout({
isRoot: false
});
}
return me;
},
isLayoutRoot: function() {
var me = this,
ownerLayout = me.ownerLayout;
if (!ownerLayout || me._isLayoutRoot || me.floating) {
return true;
}
return ownerLayout.isItemLayoutRoot(me);
},
isLayoutSuspended: function () {
var comp = this,
ownerLayout;
while (comp) {
if (comp.layoutSuspendCount || comp.suspendLayout) {
return true;
}
ownerLayout = comp.ownerLayout;
if (!ownerLayout) {
break;
}
comp = ownerLayout.owner;
}
return false;
},
updateLayout: function (options) {
var me = this,
defer,
lastBox = me.lastBox,
isRoot = options && options.isRoot;
if (lastBox) {
lastBox.invalid = true;
}
if (!me.rendered || me.layoutSuspendCount || me.suspendLayout) {
return;
}
if (me.hidden) {
Ext.AbstractComponent.cancelLayout(me);
} else if (typeof isRoot != 'boolean') {
isRoot = me.isLayoutRoot();
}
if (isRoot || !me.ownerLayout || !me.ownerLayout.onContentChange(me)) {
if (!me.isLayoutSuspended()) {
defer = (options && options.hasOwnProperty('defer')) ? options.defer : me.deferLayouts;
Ext.AbstractComponent.updateLayout(me, defer);
}
}
},
getSizeModel: function (ownerCtSizeModel) {
var me = this,
models = Ext.layout.SizeModel,
ownerContext = me.componentLayout.ownerContext,
width = me.width,
height = me.height,
typeofWidth, typeofHeight,
hasPixelWidth, hasPixelHeight,
heightModel, ownerLayout, policy, shrinkWrap, topLevel, widthModel;
if (ownerContext) {
widthModel = ownerContext.widthModel;
heightModel = ownerContext.heightModel;
}
if (!widthModel || !heightModel) {
hasPixelWidth = ((typeofWidth = typeof width) == 'number');
hasPixelHeight = ((typeofHeight = typeof height) == 'number');
topLevel = me.floating || !(ownerLayout = me.ownerLayout);
if (topLevel) {
policy = Ext.layout.Layout.prototype.autoSizePolicy;
shrinkWrap = me.floating ? 3 : me.shrinkWrap;
if (hasPixelWidth) {
widthModel = models.configured;
}
if (hasPixelHeight) {
heightModel = models.configured;
}
} else {
policy = ownerLayout.getItemSizePolicy(me, ownerCtSizeModel);
shrinkWrap = ownerLayout.isItemShrinkWrap(me);
}
if (ownerContext) {
ownerContext.ownerSizePolicy = policy;
}
shrinkWrap = (shrinkWrap === true) ? 3 : (shrinkWrap || 0); 
if (topLevel && shrinkWrap) {
if (width && typeofWidth == 'string') {
shrinkWrap &= 2; 
}
if (height && typeofHeight == 'string') {
shrinkWrap &= 1; 
}
}
if (shrinkWrap !== 3) {
if (!ownerCtSizeModel) {
ownerCtSizeModel = me.ownerCt && me.ownerCt.getSizeModel();
}
if (ownerCtSizeModel) {
shrinkWrap |= (ownerCtSizeModel.width.shrinkWrap ? 1 : 0) | (ownerCtSizeModel.height.shrinkWrap ? 2 : 0);
}
}
if (!widthModel) {
if (!policy.setsWidth) {
if (hasPixelWidth) {
widthModel = models.configured;
} else {
widthModel = (shrinkWrap & 1) ? models.shrinkWrap : models.natural;
}
} else if (policy.readsWidth) {
if (hasPixelWidth) {
widthModel = models.calculatedFromConfigured;
} else {
widthModel = (shrinkWrap & 1) ? models.calculatedFromShrinkWrap :
models.calculatedFromNatural;
}
} else {
widthModel = models.calculated;
}
}
if (!heightModel) {
if (!policy.setsHeight) {
if (hasPixelHeight) {
heightModel = models.configured;
} else {
heightModel = (shrinkWrap & 2) ? models.shrinkWrap : models.natural;
}
} else if (policy.readsHeight) {
if (hasPixelHeight) {
heightModel = models.calculatedFromConfigured;
} else {
heightModel = (shrinkWrap & 2) ? models.calculatedFromShrinkWrap :
models.calculatedFromNatural;
}
} else {
heightModel = models.calculated;
}
}
}
return widthModel.pairsByHeightOrdinal[heightModel.ordinal];
},
isDescendant: function(ancestor) {
if (ancestor.isContainer) {
for (var c = this.ownerCt; c; c = c.ownerCt) {
if (c === ancestor) {
return true;
}
}
}
return false;
},
doComponentLayout : function() {
this.updateLayout();
return this;
},
forceComponentLayout: function () {
this.updateLayout();
},
setComponentLayout : function(layout) {
var currentLayout = this.componentLayout;
if (currentLayout && currentLayout.isLayout && currentLayout != layout) {
currentLayout.setOwner(null);
}
this.componentLayout = layout;
layout.setOwner(this);
},
getComponentLayout : function() {
var me = this;
if (!me.componentLayout || !me.componentLayout.isLayout) {
me.setComponentLayout(Ext.layout.Layout.create(me.componentLayout, 'autocomponent'));
}
return me.componentLayout;
},
afterComponentLayout: function(width, height, oldWidth, oldHeight) {
var me = this;
if (++me.componentLayoutCounter === 1) {
me.afterFirstLayout(width, height);
}
if (width !== oldWidth || height !== oldHeight) {
me.onResize(width, height, oldWidth, oldHeight);
}
},
beforeComponentLayout: function(width, height) {
return true;
},
setPosition: function(x, y, animate) {
var me = this,
pos = me.beforeSetPosition.apply(me, arguments);
if (pos && me.rendered) {
x = pos.x;
y = pos.y;
if (animate) {
if (x !== me.getLocalX() || y !== me.getLocalY()) {
me.stopAnimation();
me.animate(Ext.apply({
duration: 1000,
listeners: {
afteranimate: Ext.Function.bind(me.afterSetPosition, me, [x, y])
},
to: {
left: x,
top: y
}
}, animate));
}
} else {
me.setLocalXY(x, y);
me.afterSetPosition(x, y);
}
}
return me;
},
beforeSetPosition: function (x, y, animate) {
var pos, x0;
if (x) {
if (Ext.isNumber(x0 = x[0])) {
animate = y;
y = x[1];
x = x0;
}
else if ((x0 = x.x) !== undefined) {
animate = y;
y = x.y;
x = x0;
}
}
if (this.constrain || this.constrainHeader) {
pos = this.calculateConstrainedPosition(null, [x, y], true);
if (pos) {
x = pos[0];
y = pos[1];
}
}
pos = {
x : this.x = x,
y : this.y = y,
anim: animate,
hasX: x !== undefined,
hasY: y !== undefined
};
return (pos.hasX || pos.hasY) ? pos : null;
},
afterSetPosition: function(x, y) {
var me = this;
me.onPosition(x, y);
if (me.hasListeners.move) {
me.fireEvent('move', me, x, y);
}
},
onPosition: Ext.emptyFn,
setWidth : function(width) {
return this.setSize(width);
},
setHeight : function(height) {
return this.setSize(undefined, height);
},
getSize : function(contentSize) {
return this.el.getSize(contentSize);
},
getWidth : function() {
return this.el.getWidth();
},
getHeight : function() {
return this.el.getHeight();
},
getLoader: function(){
var me = this,
autoLoad = me.autoLoad ? (Ext.isObject(me.autoLoad) ? me.autoLoad : {url: me.autoLoad}) : null,
loader = me.loader || autoLoad;
if (loader) {
if (!loader.isLoader) {
me.loader = new Ext.ComponentLoader(Ext.apply({
target: me,
autoLoad: autoLoad
}, loader));
} else {
loader.setTarget(me);
}
return me.loader;
}
return null;
},
setDocked : function(dock, layoutParent) {
var me = this;
me.dock = dock;
if (layoutParent && me.ownerCt && me.rendered) {
me.ownerCt.updateLayout();
}
return me;
},
setBorder: function(border,  targetEl) {
var me = this,
initial = !!targetEl;
if (me.rendered || initial) {
if (!initial) {
targetEl = me.el;
}
if (!border) {
border = 0;
} else if (border === true) {
border = '1px';
} else {
border = this.unitizeBox(border);
}
targetEl.setStyle('border-width', border);
if (!initial) {
me.updateLayout();
}
}
me.border = border;
},
onDestroy : function() {
var me = this;
if (me.monitorResize && Ext.EventManager.resizeEvent) {
Ext.EventManager.resizeEvent.removeListener(me.setSize, me);
}
Ext.destroy(
me.componentLayout,
me.loadMask,
me.floatingDescendants
);
},
destroy : function() {
var me = this,
selectors = me.renderSelectors,
selector,
el;
if (!me.isDestroyed) {
if (!me.hasListeners.beforedestroy || me.fireEvent('beforedestroy', me) !== false) {
me.destroying = true;
me.beforeDestroy();
if (me.floating) {
delete me.floatParent;
if (me.zIndexManager) {
me.zIndexManager.unregister(me);
}
} else if (me.ownerCt && me.ownerCt.remove) {
me.ownerCt.remove(me, false);
}
me.stopAnimation();
me.onDestroy();
Ext.destroy(me.plugins);
if (me.hasListeners.destroy) {
me.fireEvent('destroy', me);
}
Ext.ComponentManager.unregister(me);
me.mixins.state.destroy.call(me);
me.clearListeners();
if (me.rendered) {
if (!me.preserveElOnDestroy) {
me.el.remove();
}
me.mixins.elementCt.destroy.call(me); 
if (selectors) {
for (selector in selectors) {
if (selectors.hasOwnProperty(selector)) {
el = me[selector];
if (el) { 
delete me[selector];
el.remove();
}
}
}
}
delete me.el;
delete me.frameBody;
delete me.rendered;
}
me.destroying = false;
me.isDestroyed = true;
}
}
},
isDescendantOf: function(container) {
return !!this.findParentBy(function(p){
return p === container;
});
},
getHierarchyState: function (inner) {
var me = this,
hierarchyState = (inner && me.hierarchyStateInner) || me.hierarchyState,
ownerCt = me.ownerCt,
parent, layout, hierarchyStateInner, getInner;
if (!hierarchyState || hierarchyState.invalid) {
parent = me.getRefOwner();
if (ownerCt) {
getInner = me.ownerLayout === ownerCt.layout;
}
me.hierarchyState = hierarchyState =
Ext.Object.chain(parent ? parent.getHierarchyState(getInner)
: Ext.rootHierarchyState);
me.initHierarchyState(hierarchyState);
if ((layout = me.componentLayout).initHierarchyState) {
layout.initHierarchyState(hierarchyState);
}
if (me.isContainer) {
me.hierarchyStateInner = hierarchyStateInner = Ext.Object.chain(hierarchyState);
layout = me.layout;
if (layout && layout.initHierarchyState) {
layout.initHierarchyState(hierarchyStateInner, hierarchyState);
}
if (inner) {
hierarchyState = hierarchyStateInner;
}
}
}
return hierarchyState;
},
initHierarchyState: function(hierarchyState) {
var me = this;
if (me.collapsed) {
hierarchyState.collapsed = true;
}
if (me.hidden) {
hierarchyState.hidden = true;
}
if (me.collapseImmune) {
hierarchyState.collapseImmune = true;
}
},
getAnchorToXY: function(el, anchor, local, mySize) {
return el.getAnchorXY(anchor, local, mySize);
},
getBorderPadding: function() {
return this.el.getBorderPadding();
},
getLocalX: function() {
return this.el.getLocalX();
},
getLocalXY: function() {
return this.el.getLocalXY();
},
getLocalY: function() {
return this.el.getLocalY();
},
getX: function() {
return this.el.getX();
},
getXY: function() {
return this.el.getXY();
},
getY: function() {
return this.el.getY();
},
setLocalX: function(x) {
this.el.setLocalX(x);
},
setLocalXY: function(x, y) {
this.el.setLocalXY(x, y);
},
setLocalY: function(y) {
this.el.setLocalY(y);
},
setX: function(x, animate) {
this.el.setX(x, animate);
},
setXY: function(xy, animate) {
this.el.setXY(xy, animate);
},
setY: function(y, animate) {
this.el.setY(y, animate);
}
}, function() {
var AbstractComponent = this;
AbstractComponent.createAlias({
on: 'addListener',
prev: 'previousSibling',
next: 'nextSibling'
});
Ext.resumeLayouts = function (flush) {
AbstractComponent.resumeLayouts(flush);
};
Ext.suspendLayouts = function () {
AbstractComponent.suspendLayouts();
};
Ext.batchLayouts = function(fn, scope) {
AbstractComponent.suspendLayouts();
fn.call(scope);
AbstractComponent.resumeLayouts(true);
};
});
Ext.ns('Ext.data.flash.BinaryXhr');Ext.data.flash.BinaryXhr=Ext.emptyFn;
Ext.define('Ext.data.Connection', {
mixins: {
observable:  Ext.util.Observable 
},
statics: {
requestId: 0
},
url: null,
async: true,
method: null,
username: '',
password: '',
disableCaching: true,
withCredentials: false,
binary: false,
cors: false,
isXdr: false,
defaultXdrContentType: 'text/plain',
disableCachingParam: '_dc',
timeout : 30000,
useDefaultHeader : true,
defaultPostHeader : 'application/x-www-form-urlencoded; charset=UTF-8',
useDefaultXhrHeader : true,
defaultXhrHeader : 'XMLHttpRequest',
constructor : function(config) {
config = config || {};
Ext.apply(this, config);
this.requests = {};
this.mixins.observable.constructor.call(this);
},
request : function(options) {
options = options || {};
var me = this,
scope = options.scope || window,
username = options.username || me.username,
password = options.password || me.password || '',
async,
requestOptions,
request,
headers,
xhr;
if (me.fireEvent('beforerequest', me, options) !== false) {
requestOptions = me.setOptions(options, scope);
if (me.isFormUpload(options)) {
me.upload(options.form, requestOptions.url, requestOptions.data, options);
return null;
}
if (options.autoAbort || me.autoAbort) {
me.abort();
}
async = options.async !== false ? (options.async || me.async) : false;
xhr = me.openRequest(options, requestOptions, async, username, password);
if (!me.isXdr) {
headers = me.setupHeaders(xhr, options, requestOptions.data, requestOptions.params);
}
request = {
id: ++Ext.data.Connection.requestId,
xhr: xhr,
headers: headers,
options: options,
async: async,
binary: options.binary || me.binary,
timeout: setTimeout(function() {
request.timedout = true;
me.abort(request);
}, options.timeout || me.timeout)
};
me.requests[request.id] = request;
me.latestId = request.id;
if (async) {
if (!me.isXdr) {
xhr.onreadystatechange = Ext.Function.bind(me.onStateChange, me, [request]);
}
}
if (me.isXdr) {
me.processXdrRequest(request, xhr);
}
xhr.send(requestOptions.data);
if (!async) {
return me.onComplete(request);
}
return request;
} else {
Ext.callback(options.callback, options.scope, [options, undefined, undefined]);
return null;
}
},
processXdrRequest: function(request, xhr) {
var me = this;
delete request.headers;
request.contentType = request.options.contentType || me.defaultXdrContentType;
xhr.onload = Ext.Function.bind(me.onStateChange, me, [request, true]);
xhr.onerror = xhr.ontimeout = Ext.Function.bind(me.onStateChange, me, [request, false]);
},
processXdrResponse: function(response, xhr) {
response.getAllResponseHeaders = function () {
return [];
};
response.getResponseHeader = function () {
return '';
};
response.contentType = xhr.contentType || this.defaultXdrContentType;
},
upload: function(form, url, params, options) {
form = Ext.getDom(form);
options = options || {};
var id = Ext.id(),
frame = document.createElement('iframe'),
hiddens = [],
encoding = 'multipart/form-data',
buf = {
target: form.target,
method: form.method,
encoding: form.encoding,
enctype: form.enctype,
action: form.action
},
addField = function(name, value) {
hiddenItem = document.createElement('input');
Ext.fly(hiddenItem).set({
type: 'hidden',
value: value,
name: name
});
form.appendChild(hiddenItem);
hiddens.push(hiddenItem);
},
hiddenItem, obj, value, name, vLen, v, hLen, h;
Ext.fly(frame).set({
id: id,
name: id,
cls: Ext.baseCSSPrefix + 'hide-display',
src: Ext.SSL_SECURE_URL
});
document.body.appendChild(frame);
if (document.frames) {
document.frames[id].name = id;
}
Ext.fly(form).set({
target: id,
method: 'POST',
enctype: encoding,
encoding: encoding,
action: url || buf.action
});
if (params) {
obj = Ext.Object.fromQueryString(params) || {};
for (name in obj) {
if (obj.hasOwnProperty(name)) {
value = obj[name];  
if (Ext.isArray(value)) {
vLen = value.length;
for (v = 0; v < vLen; v++) {
addField(name, value[v]);
}
} else {
addField(name, value);
}
}
}
}
Ext.fly(frame).on('load', Ext.Function.bind(this.onUploadComplete, this, [frame, options]), null, {single: !Ext.isOpera});
form.submit();
Ext.fly(form).set(buf);
hLen = hiddens.length;
for (h = 0; h < hLen; h++) {
Ext.removeNode(hiddens[h]);
}
},
onUploadComplete: function(frame, options) {
var me = this,
response = {
responseText: '',
responseXML: null
}, callback, success, doc, contentNode;
try {
doc = frame.contentWindow.document || frame.contentDocument || window.frames[frame.id].document;
if (doc) {
if (Ext.isOpera && doc.location == 'about:blank') {
return;
}
if (doc.body) {
if ((contentNode = doc.body.firstChild) && /pre/i.test(contentNode.tagName)) {
response.responseText = contentNode.textContent;
}
else if ((contentNode = doc.getElementsByTagName('textarea')[0])) {
response.responseText = contentNode.value;
}
else {
response.responseText = doc.body.textContent || doc.body.innerText;
}
}
response.responseXML = doc.XMLDocument || doc;
callback = options.success;
success = true;
}
} catch (e) {
response.responseText = '{success:false,message:"' + Ext.String.trim(e.message || e.description) + '"}';
callback = options.failure;
success = false;
}
me.fireEvent('requestcomplete', me, response, options);
Ext.callback(callback, options.scope, [response, options]);
Ext.callback(options.callback, options.scope, [options, success, response]);
setTimeout(function() {
Ext.removeNode(frame);
}, 100);
},
isFormUpload: function(options) {
var form = this.getForm(options);
if (form) {
return (options.isUpload || (/multipart\/form-data/i).test(form.getAttribute('enctype')));
}
return false;
},
getForm: function(options) {
return Ext.getDom(options.form) || null;
},
setOptions: function(options, scope) {
var me = this,
params = options.params || {},
extraParams = me.extraParams,
urlParams = options.urlParams,
url = options.url || me.url,
jsonData = options.jsonData,
method,
disableCache,
data;
if (Ext.isFunction(params)) {
params = params.call(scope, options);
}
if (Ext.isFunction(url)) {
url = url.call(scope, options);
}
url = this.setupUrl(options, url);
data = options.rawData || options.binaryData || options.xmlData || jsonData || null;
if (jsonData && !Ext.isPrimitive(jsonData)) {
data = Ext.encode(data);
}
if (options.binaryData) {
if (me.nativeBinaryPostSupport()) {
data = (new Uint8Array(options.binaryData));
if ((Ext.isChrome && Ext.chromeVersion < 22) || Ext.isSafari || Ext.isGecko) {
data = data.buffer; 
}
}
}
if (Ext.isObject(params)) {
params = Ext.Object.toQueryString(params);
}
if (Ext.isObject(extraParams)) {
extraParams = Ext.Object.toQueryString(extraParams);
}
params = params + ((extraParams) ? ((params) ? '&' : '') + extraParams : '');
urlParams = Ext.isObject(urlParams) ? Ext.Object.toQueryString(urlParams) : urlParams;
params = this.setupParams(options, params);
method = (options.method || me.method || ((params || data) ? 'POST' : 'GET')).toUpperCase();
this.setupMethod(options, method);
disableCache = options.disableCaching !== false ? (options.disableCaching || me.disableCaching) : false;
if (method === 'GET' && disableCache) {
url = Ext.urlAppend(url, (options.disableCachingParam || me.disableCachingParam) + '=' + (new Date().getTime()));
}
if ((method == 'GET' || data) && params) {
url = Ext.urlAppend(url, params);
params = null;
}
if (urlParams) {
url = Ext.urlAppend(url, urlParams);
}
return {
url: url,
method: method,
data: data || params || null
};
},
setupUrl: function(options, url) {
var form = this.getForm(options);
if (form) {
url = url || form.action;
}
return url;
},
setupParams: function(options, params) {
var form = this.getForm(options),
serializedForm;
if (form && !this.isFormUpload(options)) {
serializedForm = Ext.Element.serializeForm(form);
params = params ? (params + '&' + serializedForm) : serializedForm;
}
return params;
},
setupMethod: function(options, method) {
if (this.isFormUpload(options)) {
return 'POST';
}
return method;
},
setupHeaders: function(xhr, options, data, params) {
var me = this,
headers = Ext.apply({}, options.headers || {}, me.defaultHeaders || {}),
contentType = me.defaultPostHeader,
jsonData = options.jsonData,
xmlData = options.xmlData,
type = 'Content-Type',
key,
header;
if (!headers.hasOwnProperty(type) && (data || params)) {
if (data) {
if (options.rawData) {
contentType = 'text/plain';
} else {
if (xmlData && Ext.isDefined(xmlData)) {
contentType = 'text/xml';
} else if (jsonData && Ext.isDefined(jsonData)) {
contentType = 'application/json';
}
}
}
headers[type] = contentType;
}
if (me.useDefaultXhrHeader && !headers['X-Requested-With']) {
headers['X-Requested-With'] = me.defaultXhrHeader;
}
if (headers[type] === undefined || headers[type] === null) {
delete headers[type];
}
try {
for (key in headers) {
if (headers.hasOwnProperty(key)) {
header = headers[key];
xhr.setRequestHeader(key, header);
}
}
} catch(e) {
me.fireEvent('exception', key, header);
}
return headers;
},
newRequest: function (options) {
var me = this,
xhr;
if (options.binaryData) {
if (me.nativeBinaryPostSupport()) { 
xhr = this.getXhrInstance(); 
} else {
xhr = new Ext.data.flash.BinaryXhr();
}
} else  if ((options.cors || me.cors) && Ext.isIE && Ext.ieVersion <= 9) {
xhr = me.getXdrInstance();
me.isXdr = true;
} else {
xhr = me.getXhrInstance();
}
return xhr;
},
openRequest: function (options, requestOptions, async, username, password) {
var me = this,
xhr = me.newRequest(options);
if (username) {
xhr.open(requestOptions.method, requestOptions.url, async, username, password);
} else {
if (me.isXdr) {
xhr.open(requestOptions.method, requestOptions.url);
} else {
xhr.open(requestOptions.method, requestOptions.url, async);
}
}
if (options.binary || me.binary) {
if (window.Uint8Array) {
xhr.responseType = 'arraybuffer';
} else if (xhr.overrideMimeType) {
xhr.overrideMimeType('text\/plain; charset=x-user-defined');  
}
}
if (options.withCredentials || me.withCredentials) {
xhr.withCredentials = true;
}
return xhr;
},
getXdrInstance: function() {
var xdr;
if (Ext.ieVersion >= 8) {
xdr = new XDomainRequest();
} else {
Ext.Error.raise({
msg: 'Your browser does not support CORS'
});
}
return xdr;
},
getXhrInstance: (function() {
var options = [function() {
return new XMLHttpRequest();
}, function() {
return new ActiveXObject('MSXML2.XMLHTTP.3.0');
}, function() {
return new ActiveXObject('MSXML2.XMLHTTP');
}, function() {
return new ActiveXObject('Microsoft.XMLHTTP');
}], i = 0,
len = options.length,
xhr;
for (; i < len; ++i) {
try {
xhr = options[i];
xhr();
break;
} catch(e) {
}
}
return xhr;
}()),
isLoading : function(request) {
if (!request) {
request = this.getLatest();
}
if (!(request && request.xhr)) {
return false;
}
var state = request.xhr.readyState;
return ((request.xhr instanceof Ext.data.flash.BinaryXhr) && state != 4) || !(state === 0 || state == 4);
},
abort : function(request) {
var me = this,
xhr;
if (!request) {
request = me.getLatest();
}
if (request && me.isLoading(request)) {
xhr = request.xhr;
try {
xhr.onreadystatechange = null;
} catch (e) {
xhr.onreadystatechange = Ext.emptyFn;
}
xhr.abort();
me.clearTimeout(request);
if (!request.timedout) {
request.aborted = true;
}
me.onComplete(request);
me.cleanup(request);
}
},
abortAll: function(){
var requests = this.requests,
id;
for (id in requests) {
if (requests.hasOwnProperty(id)) {
this.abort(requests[id]);
}
}
},
getLatest: function(){
var id = this.latestId,
request;
if (id) {
request = this.requests[id];
}
return request || null;
},
onStateChange : function(request, xdrResult) {
var me = this;
if ((request.xhr && request.xhr.readyState == 4) || me.isXdr) {
me.clearTimeout(request);
me.onComplete(request, xdrResult);
me.cleanup(request);
Ext.EventManager.idleEvent.fire();
}
},
clearTimeout: function(request) {
clearTimeout(request.timeout);
delete request.timeout;
},
cleanup: function(request) {
request.xhr = null;
delete request.xhr;
},
onComplete : function(request, xdrResult) {
var me = this,
options = request.options,
xhr,
result,
success,
response;
try {
xhr = request.xhr;
result = me.parseStatus(xhr.status);
if (result.success) {
result.success = xhr.readyState === 4;
}
} catch (e) {
result = {
success : false,
isException : false
};
}
success = me.isXdr ? xdrResult : result.success;
if (success) {
response = me.createResponse(request);
me.fireEvent('requestcomplete', me, response, options);
Ext.callback(options.success, options.scope, [response, options]);
} else {
if (result.isException || request.aborted || request.timedout) {
response = me.createException(request);
} else {
response = me.createResponse(request);
}
me.fireEvent('requestexception', me, response, options);
Ext.callback(options.failure, options.scope, [response, options]);
}
Ext.callback(options.callback, options.scope, [options, success, response]);
delete me.requests[request.id];
return response;
},
parseStatus: function(status) {
status = status == 1223 ? 204 : status;
var success = (status >= 200 && status < 300) || status == 304,
isException = false;
if (!success) {
switch (status) {
case 12002:
case 12029:
case 12030:
case 12031:
case 12152:
case 13030:
isException = true;
break;
}
}
return {
success: success,
isException: isException
};
},
createResponse : function(request) {
var me = this,
xhr = request.xhr,
isXdr = me.isXdr,
headers = {},
lines = isXdr ? [] : xhr.getAllResponseHeaders().replace(/\r\n/g, '\n').split('\n'),
count = lines.length,
line, index, key, response, byteArray;
while (count--) {
line = lines[count];
index = line.indexOf(':');
if (index >= 0) {
key = line.substr(0, index).toLowerCase();
if (line.charAt(index + 1) == ' ') {
++index;
}
headers[key] = line.substr(index + 1);
}
}
request.xhr = null;
delete request.xhr;
response = {
request: request,
requestId: request.id,
status: xhr.status,
statusText: xhr.statusText,
getResponseHeader: function(header) {
return headers[header.toLowerCase()];
},
getAllResponseHeaders: function() {
return headers;
}
};
if (isXdr) {
me.processXdrResponse(response, xhr);
}
if (request.binary) {
response.responseBytes = me.getByteArray(xhr);
} else {
response.responseText = xhr.responseText;
response.responseXML = xhr.responseXML;
}
xhr = null;
return response;
},
createException : function(request) {
return {
request : request,
requestId : request.id,
status : request.aborted ? -1 : 0,
statusText : request.aborted ? 'transaction aborted' : 'communication failure',
aborted: request.aborted,
timedout: request.timedout
};
},
getByteArray: function(xhr) {
var response = xhr.response,
responseBody = xhr.responseBody,
byteArray, responseText, len, i;
if (xhr instanceof Ext.data.flash.BinaryXhr) {
byteArray = xhr.responseBytes;
} else if (window.Uint8Array) {
byteArray = response ? new Uint8Array(response) : [];
} else if (Ext.isIE9p) {
try {
byteArray = new VBArray(responseBody).toArray();
} catch(e) {
byteArray = [];
}
} else if (Ext.isIE) {
if (!this.self.vbScriptInjected) {
this.injectVBScript();
}
getIEByteArray(xhr.responseBody, byteArray = []);
} else {
byteArray = [];
responseText = xhr.responseText;
len = responseText.length;
for (i = 0; i < len; i++) {
byteArray.push(responseText.charCodeAt(i) & 0xFF);
}
}
return byteArray;
},
injectVBScript: function() {
var scriptTag = document.createElement('script');
scriptTag.type = 'text/vbscript';
scriptTag.text = [
'Function getIEByteArray(byteArray, out)',
'Dim len, i',
'len = LenB(byteArray)',
'For i = 1 to len',
'out.push(AscB(MidB(byteArray, i, 1)))',
'Next',
'End Function'
].join('\n');
Ext.getHead().dom.appendChild(scriptTag);
this.self.vbScriptInjected = true;
},
nativeBinaryPostSupport: function() {
return Ext.isChrome ||
(Ext.isSafari && Ext.isDefined(window.Uint8Array)) ||
(Ext.isGecko && Ext.isDefined(window.Uint8Array));
}
});
Ext.define('Ext.util.Floating', {
focusOnToFront: true,
shadow: 'sides',
constrain: false,
constructor: function (dom) {
var me = this;
me.fixed = me.fixed && !(Ext.isIE6 || Ext.isIEQuirks);
me.el = new Ext.dom.Layer(Ext.apply({
preventSync  : true,
hideMode     : me.hideMode,
shadow       : (typeof me.shadow != 'undefined') ? me.shadow : 'sides',
shadowOffset : me.shadowOffset,
constrain    : false,
fixed        : me.fixed,
shim         : (me.shim === false) ? false : undefined
}, me.floating), dom);
if (me.modal && !(Ext.FocusManager && Ext.FocusManager.enabled)) {
me.mon(me.el, {
keydown: me.onKeyDown,
scope: me
});
}
me.mon(me.el, {
mousedown: me.onMouseDown,
scope: me
});
me.floating = true;
me.registerWithOwnerCt();
me.initHierarchyEvents();
},
initHierarchyEvents: function() {
var me = this,
syncHidden = this.syncHidden;
if (!me.hasHierarchyEventListeners) {
me.mon(me.hierarchyEventSource, {
hide: syncHidden,
collapse: syncHidden,
show: syncHidden,
expand: syncHidden,
added: syncHidden,
scope: me
});
me.hasHierarchyEventListeners = true;
}
},
registerWithOwnerCt: function() {
var me = this,
ownerCt = me.ownerCt,
zip = me.zIndexParent;
if (zip) {
zip.unregisterFloatingItem(me);
}
zip = me.zIndexParent = me.up('[floating]');
me.setFloatParent(ownerCt || zip);
delete me.ownerCt;
if (zip) {
zip.registerFloatingItem(me);
} else {
Ext.WindowManager.register(me);
}
},
onKeyDown: function(e) {
var me = this,
shift,
focusables,
first,
last;
if (e.getKey() == Ext.EventObject.TAB) {
shift = e.shiftKey;
focusables = me.el.query(':focusable');
first = focusables[0];
last = focusables[focusables.length - 1];
if (first && last && e.target === (shift ? first : last)) {
e.stopEvent();
(shift ? last : first).focus(false, true);
}
}
},
onMouseDown: function (e) {
var focusTask = this.focusTask;
if (this.floating &&
(!focusTask || !focusTask.id)) {
this.toFront(!!e.getTarget(':focusable'));
}
},
setFloatParent: function(floatParent) {
var me = this;
me.floatParent = floatParent;
if ((me.constrain || me.constrainHeader) && !me.constrainTo) {
me.constrainTo = floatParent ? floatParent.getTargetEl() : me.container;
}
},
syncShadow : function() {
if (this.floating) {
this.el.sync(true);
}
},
onBeforeFloatLayout: function(){
this.el.preventSync = true;
},
onAfterFloatLayout: function(){
delete this.el.preventSync;
this.syncShadow();   
},
syncHidden: function() {
var me = this,
hidden = me.hidden || !me.rendered,
hierarchicallyHidden = me.hierarchicallyHidden = me.isHierarchicallyHidden(),
pendingShow = me.pendingShow;
if (hidden !== hierarchicallyHidden) {
if (hierarchicallyHidden) {
me.hide();
me.pendingShow = true;
} else if (pendingShow) {
delete me.pendingShow;
if (pendingShow.length) {
me.show.apply(me, pendingShow);
} else {
me.show();
}
}
}
},
setZIndex: function(index) {
var me = this;
me.el.setZIndex(index);
index += 10;
if (me.floatingDescendants) {
index = Math.floor(me.floatingDescendants.setBase(index) / 100) * 100 + 10000;
}
return index;
},
doConstrain: function(constrainTo) {
var me = this,
xy = me.calculateConstrainedPosition(constrainTo, null, true);
if (xy) {
me.setPosition(xy);
}
},
toFront: function(preventFocus) {
var me = this,
zip = me.zIndexParent,
preventFocusSetting = me.preventFocusOnActivate;
if (zip && me.bringParentToFront !== false) {
zip.toFront(true);
}
if (!Ext.isDefined(preventFocus)) {
preventFocus = !me.focusOnToFront;
}
if (preventFocus) {
me.preventFocusOnActivate = true;
}
if (me.zIndexManager.bringToFront(me, preventFocus)) {    
if (!preventFocus) {
me.focus(false, true);
}
}
me.preventFocusOnActivate = preventFocusSetting;
return me;
},
setActive: function(active, newActive) {
var me = this;
if (active) {
if (me.el.shadow && !me.maximized) {
me.el.enableShadow(true);
}
if (!me.preventFocusOnActivate) {
me.focus(false, true);
}
me.fireEvent('activate', me);
} else {
if (me.isWindow && (newActive && newActive.isWindow) && me.hideShadowOnDeactivate) {
me.el.disableShadow();
}
me.fireEvent('deactivate', me);
}
},
toBack: function() {
this.zIndexManager.sendToBack(this);
return this;
},
center: function() {
var me = this,
xy;
if (me.isVisible()) {
xy = me.getAlignToXY(me.container, 'c-c');
me.setPagePosition(xy);
} else {
me.needsCenter = true;
}
return me;
},
onFloatShow: function() {
if (this.needsCenter) {
this.center();    
}
delete this.needsCenter;
if (this.toFrontOnShow) {
this.toFront();
}
},
fitContainer: function(animate) {
var me = this,
parent = me.floatParent,
container = parent ? parent.getTargetEl() : me.container,
newBox = container.getViewSize(false),
newPosition = parent || (container.dom !== document.body) ?
[0, 0] :
container.getXY();
newBox.x = newPosition[0];
newBox.y = newPosition[1];
me.setBox(newBox, animate);
}
});
Ext.define('Ext.Component', {
alias: ['widget.component', 'widget.box'],
extend:  Ext.AbstractComponent ,
mixins: {
floating:  Ext.util.Floating 
},
statics: {
DIRECTION_TOP: 'top',
DIRECTION_RIGHT: 'right',
DIRECTION_BOTTOM: 'bottom',
DIRECTION_LEFT: 'left',
VERTICAL_DIRECTION_Re: /^(?:top|bottom)$/,
INVALID_ID_CHARS_Re: /[\.,\s]/g
},
resizeHandles: 'all',
floating: false,
defaultAlign: 'tl-bl?',
toFrontOnShow: true,
hideMode: 'display',
offsetsCls: Ext.baseCSSPrefix + 'hide-offsets',
bubbleEvents: [],
defaultComponentLayoutType: 'autocomponent',
constructor: function(config) {
var me = this;
config = config || {};
if (config.initialConfig) {
if (config.isAction) {
me.baseAction = config;
}
config = config.initialConfig;
}
else if (config.tagName || config.dom || Ext.isString(config)) {
config = {
applyTo: config,
id: config.id || config
};
}
me.callParent([config]);
if (me.baseAction){
me.baseAction.addComponent(me);
}
},
initComponent: function() {
var me = this;
me.callParent();
if (me.listeners) {
me.on(me.listeners);
me.listeners = null; 
}
me.enableBubble(me.bubbleEvents);
},
afterRender: function() {
var me = this;
me.callParent();
if (!(me.x && me.y) && (me.pageX || me.pageY)) {
me.setPagePosition(me.pageX, me.pageY);
}
},
setAutoScroll : function(scroll) {
var me = this;
me.autoScroll = !!scroll;
if (me.rendered) {
me.getOverflowEl().setStyle(me.getOverflowStyle());
}
me.updateLayout();
return me;
},
setOverflowXY: function(overflowX, overflowY) {
var me = this,
argCount = arguments.length;
if (argCount) {
me.overflowX = overflowX || '';
if (argCount > 1) {
me.overflowY = overflowY || '';
}
}
if (me.rendered) {
me.getOverflowEl().setStyle(me.getOverflowStyle());
}
me.updateLayout();
return me;
},
beforeRender: function () {
var me = this,
floating = me.floating,
cls;
if (floating) {
me.addCls(Ext.baseCSSPrefix + 'layer');
cls = floating.cls;
if (cls) {
me.addCls(cls);
}
}
return me.callParent();
},
beforeLayout: function(){
this.callParent(arguments);
if (this.floating) {
this.onBeforeFloatLayout();
}    
},
afterComponentLayout: function(){
this.callParent(arguments);
if (this.floating) {
this.onAfterFloatLayout();
}
},
makeFloating : function (dom) {
this.mixins.floating.constructor.call(this, dom);
},
wrapPrimaryEl: function (dom) {
if (this.floating) {
this.makeFloating(dom);
} else {
this.callParent(arguments);
}
},
initResizable: function(resizable) {
var me = this;
resizable = Ext.apply({
target: me,
dynamic: false,
constrainTo: me.constrainTo || (me.floatParent ? me.floatParent.getTargetEl() : null),
handles: me.resizeHandles
}, resizable);
resizable.target = me;
me.resizer = new Ext.resizer.Resizer(resizable);
},
getDragEl: function() {
return this.el;
},
initDraggable: function() {
var me = this,
dragTarget = (me.resizer && me.resizer.el !== me.el) ? me.resizerComponent = new Ext.Component({
ariaRole: 'presentation',
el: me.resizer.el,
rendered: true,
container: me.container
}) : me,
ddConfig = Ext.applyIf({
el: dragTarget.getDragEl(),
constrainTo: (me.constrain||me.draggable.constrain) ? (me.constrainTo || (me.floatParent ? me.floatParent.getTargetEl() : me.container)) : undefined
}, me.draggable);
if (me.constrain || me.constrainDelegate) {
ddConfig.constrain = me.constrain;
ddConfig.constrainDelegate = me.constrainDelegate;
}
me.dd = new Ext.util.ComponentDragger(dragTarget, ddConfig);
},
scrollBy: function(deltaX, deltaY, animate) {
var el;
if ((el = this.getTargetEl()) && el.dom) {
el.scrollBy.apply(el, arguments);
}
},
setLoading : function(load, targetEl) {
var me = this,
config = {
target: me
};
if (me.rendered) {
Ext.destroy(me.loadMask);
me.loadMask = null;
if (load !== false && !me.collapsed) {
if (Ext.isObject(load)) {
Ext.apply(config, load);
} else if (Ext.isString(load)) {
config.msg = load;
}
if (targetEl) {
Ext.applyIf(config, {
useTargetEl: true
});
}
me.loadMask = new Ext.LoadMask(config);
me.loadMask.show();
}
}
return me.loadMask;
},
beforeSetPosition: function () {
var me = this,
pos = me.callParent(arguments), 
adj;
if (pos) {
adj = me.adjustPosition(pos.x, pos.y);
pos.x = adj.x;
pos.y = adj.y;
}
return pos || null;
},
afterSetPosition: function(ax, ay) {
this.onPosition(ax, ay);
this.fireEvent('move', this, ax, ay);
},
showAt: function(x, y, animate) {
var me = this;
if (!me.rendered && (me.autoRender || me.floating)) {
me.x = x;
me.y = y;
return me.show();
}
if (me.floating) {
me.setPosition(x, y, animate);
} else {
me.setPagePosition(x, y, animate);
}
me.show();
},
showBy: function(cmp, pos, off) {
var me = this;
if (me.floating && cmp) {
me.show();
if (me.rendered && !me.hidden) {
me.alignTo(cmp, pos || me.defaultAlign, off);
}
}
return me;
},
setPagePosition: function(x, y, animate) {
var me = this,
p,
floatParentBox;
if (Ext.isArray(x)) {
y = x[1];
x = x[0];
}
me.pageX = x;
me.pageY = y;
if (me.floating) {
if (me.isContainedFloater()) {
floatParentBox = me.floatParent.getTargetEl().getViewRegion();
if (Ext.isNumber(x) && Ext.isNumber(floatParentBox.left)) {
x -= floatParentBox.left;
}
if (Ext.isNumber(y) && Ext.isNumber(floatParentBox.top)) {
y -= floatParentBox.top;
}
} else {
p = me.el.translateXY(x, y);
x = p.x;
y = p.y;
}
me.setPosition(x, y, animate);
} else {
p = me.el.translateXY(x, y);
me.setPosition(p.x, p.y, animate);
}
return me;
},
isContainedFloater: function() {
return (this.floating && this.floatParent);
},
updateBox : function(box){
this.setSize(box.width, box.height);
this.setPagePosition(box.x, box.y);
return this;
},
getOuterSize: function() {
var el = this.el;
return {
width: el.getWidth() + el.getMargin('lr'),
height: el.getHeight() + el.getMargin('tb')
};
},
adjustPosition: function(x, y) {
var me = this,
floatParentBox;
if (me.isContainedFloater()) {
floatParentBox = me.floatParent.getTargetEl().getViewRegion();
x += floatParentBox.left;
y += floatParentBox.top;
}
return {
x: x,
y: y
};
},
getPosition: function(local) {
var me = this,
xy,
isContainedFloater = me.isContainedFloater(),
floatParentBox;
if ((local === true) && !isContainedFloater) {
return [me.getLocalX(), me.getLocalY()];
}
xy = me.getXY();
if ((local === true) && isContainedFloater) {
floatParentBox = me.floatParent.getTargetEl().getViewRegion();
xy[0] -= floatParentBox.left;
xy[1] -= floatParentBox.top;
}
return xy;
},
getId: function() {
var me = this,
xtype;
if (!me.id) {
xtype = me.getXType();
if (xtype) {
xtype = xtype.replace(Ext.Component.INVALID_ID_CHARS_Re, '-');
} else {
xtype = Ext.name.toLowerCase() + '-comp';
}
me.id = xtype + '-' + me.getAutoId();
}
return me.id;
},
show: function(animateTarget, cb, scope) {
var me = this,
rendered = me.rendered;
if (me.hierarchicallyHidden || (me.floating && !rendered && me.isHierarchicallyHidden())) {
if (!rendered) {
me.initHierarchyEvents();
}
if (arguments.length > 1) {
arguments[0] = null;
me.pendingShow = arguments;
} else {
me.pendingShow = true;
}
} else if (rendered && me.isVisible()) {
if (me.floating) {
me.onFloatShow();
}
} else {
if (me.fireEvent('beforeshow', me) !== false) {
me.hidden = false;
delete this.getHierarchyState().hidden;
Ext.suspendLayouts();
if (!rendered && (me.autoRender || me.floating)) {
me.doAutoRender();
rendered = me.rendered;
}
if (rendered) {
me.beforeShow();
Ext.resumeLayouts();
me.onShow.apply(me, arguments);
me.afterShow.apply(me, arguments);
} else {
Ext.resumeLayouts(true);
}
} else {
me.onShowVeto();
}
}
return me;
},
onShowVeto: Ext.emptyFn,
beforeShow: Ext.emptyFn,
onShow: function() {
var me = this;
me.el.show();
me.callParent(arguments);
if (me.floating) {
if (me.maximized) {
me.fitContainer();
}
else if (me.constrain) {
me.doConstrain();
}
}
},
getAnimateTarget: function(target){
target = target || this.animateTarget;
if (target) {
target = target.isComponent ? target.getEl() : Ext.get(target);
}
return target || null;
},
afterShow: function(animateTarget, cb, scope) {
var me = this,
myEl = me.el,
fromBox,
toBox,
ghostPanel;
animateTarget = me.getAnimateTarget(animateTarget);
if (!me.ghost) {
animateTarget = null;
}
if (animateTarget) {
toBox = {
x: myEl.getX(),
y: myEl.getY(),
width: myEl.dom.offsetWidth,
height: myEl.dom.offsetHeight
};
fromBox = {
x: animateTarget.getX(),
y: animateTarget.getY(),
width: animateTarget.dom.offsetWidth,
height: animateTarget.dom.offsetHeight
};
myEl.addCls(me.offsetsCls);
ghostPanel = me.ghost();
ghostPanel.el.stopAnimation();
ghostPanel.setX(-10000);
me.ghostBox = toBox;
ghostPanel.el.animate({
from: fromBox,
to: toBox,
listeners: {
afteranimate: function() {
delete ghostPanel.componentLayout.lastComponentSize;
me.unghost();
delete me.ghostBox;
myEl.removeCls(me.offsetsCls);
me.onShowComplete(cb, scope);
}
}
});
}
else {
me.onShowComplete(cb, scope);
}
me.fireHierarchyEvent('show');
},
onShowComplete: function(cb, scope) {
var me = this;
if (me.floating) {
me.onFloatShow();
}
Ext.callback(cb, scope || me);
me.fireEvent('show', me);
delete me.hiddenByLayout;
},
hide: function(animateTarget, cb, scope) {
var me = this,
continueHide;
if (me.pendingShow) {
delete me.pendingShow;
} if (!(me.rendered && !me.isVisible())) {
continueHide = (me.fireEvent('beforehide', me) !== false);
if (me.hierarchicallyHidden || continueHide) {
me.hidden = true;
me.getHierarchyState().hidden = true;
if (me.rendered) {
me.onHide.apply(me, arguments);
}
}
}
return me;
},
onHide: function(animateTarget, cb, scope) {
var me = this,
ghostPanel,
fromSize,
toBox,
activeEl = Ext.Element.getActiveElement();
if (activeEl === me.el || me.el.contains(activeEl)) {
Ext.fly(activeEl).blur();
}
animateTarget = me.getAnimateTarget(animateTarget);
if (!me.ghost) {
animateTarget = null;
}
if (animateTarget) {
toBox = {
x: animateTarget.getX(),
y: animateTarget.getY(),
width: animateTarget.dom.offsetWidth,
height: animateTarget.dom.offsetHeight
};
ghostPanel = me.ghost();
ghostPanel.el.stopAnimation();
fromSize = me.getSize();
ghostPanel.el.animate({
to: toBox,
listeners: {
afteranimate: function() {
delete ghostPanel.componentLayout.lastComponentSize;
ghostPanel.el.hide();
ghostPanel.setHiddenState(true);
ghostPanel.el.setSize(fromSize);
me.afterHide(cb, scope);
}
}
});
}
me.el.hide();
if (!animateTarget) {
me.afterHide(cb, scope);
}
},
afterHide: function(cb, scope) {
var me = this;
me.hiddenByLayout = null;
Ext.AbstractComponent.prototype.onHide.call(me);
Ext.callback(cb, scope || me);
me.fireEvent('hide', me);
me.fireHierarchyEvent('hide');
},
onDestroy: function() {
var me = this;
if (me.rendered) {
Ext.destroy(
me.dd,
me.resizer,
me.proxy,
me.proxyWrap,
me.resizerComponent
);
}
delete me.focusTask;
me.callParent();
},
deleteMembers: function() {
var args = arguments,
len = args.length,
i = 0;
for (; i < len; ++i) {
delete this[args[i]];
}
},
focus: function(selectText, delay, callback, scope) {
var me = this,
focusEl,
focusElDom,
containerScrollTop;
if (delay) {
me.getFocusTask().delay(Ext.isNumber(delay) ? delay : 10, me.focus, me, [selectText, false, callback, scope]);
return me;
}
if (me.focusTask) {
me.focusTask.cancel();
}
if (me.rendered && !me.isDestroyed && me.isVisible(true) && (focusEl = me.getFocusEl())) {
if (focusEl.isComponent) {
return focusEl.focus(selectText, delay);
}
if ((focusElDom = focusEl.dom)) {
if (focusEl.needsTabIndex()) {
focusElDom.tabIndex = -1;
}
if (me.floating) {
containerScrollTop = me.container.dom.scrollTop;
}
focusEl.focus();
if (selectText) {
if (Ext.isArray(selectText)) {
if (me.selectText) {
me.selectText.apply(me, selectText);
}
} else {
focusElDom.select();
}
}
Ext.callback(callback, scope);
}
if (me.floating) {
if (me !== me.zIndexManager.getActive()) {
me.toFront(true);
}
if (containerScrollTop !== undefined) {
me.container.dom.scrollTop = containerScrollTop;
}
}
}
return me;
},
getFocusTask: function() {
if (!this.focusTask) {
Ext.Component.prototype.focusTask = new Ext.util.DelayedTask();
}
return this.focusTask;
},
cancelFocus: function() {
var task = this.focusTask;
if (task) {
task.cancel();
}
},
blur: function() {
var me = this,
focusEl;
if (me.rendered && (focusEl = me.getFocusEl())) {
me.blurring = true;
focusEl.blur();
delete me.blurring;
}
return me;
},
getEl: function() {
return this.el;
},
getResizeEl: function() {
return this.el;
},
getPositionEl: function() {
return this.el;
},
getActionEl: function() {
return this.el;
},
getVisibilityEl: function() {
return this.el;
},
getRefOwner: function() {
return this.ownerCt || this.floatParent;
},
getBubbleTarget: function() {
return this.getRefOwner();
},
getContentTarget: function() {
return this.el;
},
cloneConfig: function(overrides) {
overrides = overrides || {};
var id = overrides.id || Ext.id(),
cfg = Ext.applyIf(overrides, this.initialConfig),
self;
cfg.id = id;
self = Ext.getClass(this);
return new self(cfg);
},
getXType: function() {
return this.self.xtype;
},
findParentBy: function(fn) {
var p;
for (p = this.getBubbleTarget(); p && !fn(p, this); p = p.getBubbleTarget()) {
}
return p || null;
},
findParentByType: function(xtype) {
return Ext.isFunction(xtype) ?
this.findParentBy(function(p) {
return p.constructor === xtype;
})
:
this.up(xtype);
},
bubble: function(fn, scope, args) {
var p = this;
while (p) {
if (fn.apply(scope || p, args || [p]) === false) {
break;
}
p = p.getBubbleTarget();
}
return this;
},
getProxy: function() {
var me = this,
target;
if (!me.proxy) {
target = Ext.getBody();
me.proxy = me.el.createProxy(Ext.baseCSSPrefix + 'proxy-el', target, true);
}
return me.proxy;
},
fireHierarchyEvent: function (ename) {
this.hierarchyEventSource.fireEvent(ename, this);
},
onAdded: function() {
this.callParent(arguments);
if (this.hierarchyEventSource.hasListeners.added) {
this.fireHierarchyEvent('added');
}
}
}, function () {
this.hierarchyEventSource = this.prototype.hierarchyEventSource = new Ext.util.Observable({ events: {
hide: true,
show: true,
collapse: true,
expand: true,
added: true
}});
});
Ext.define('Ext.ElementLoader', {
mixins: {
observable:  Ext.util.Observable 
},
statics: {
Renderer: {
Html: function(loader, response, active){
loader.getTarget().update(response.responseText, active.scripts === true);
return true;
}
}
},
url: null,
params: null,
baseParams: null,
autoLoad: false,
target: null,
loadMask: false,
ajaxOptions: null,
scripts: false,
isLoader: true,
constructor: function(config) {
var me = this,
autoLoad;
config = config || {};
Ext.apply(me, config);
me.setTarget(me.target);
me.addEvents(
'beforeload',
'exception',
'load'
);
me.mixins.observable.constructor.call(me);
if (me.autoLoad) {
autoLoad = me.autoLoad;
if (autoLoad === true) {
autoLoad = {};
}
me.load(autoLoad);
}
},
setTarget: function(target){
var me = this;
target = Ext.get(target);
if (me.target && me.target != target) {
me.abort();
}
me.target = target;
},
getTarget: function(){
return this.target || null;
},
abort: function(){
var active = this.active;
if (active !== undefined) {
Ext.Ajax.abort(active.request);
if (active.mask) {
this.removeMask();
}
delete this.active;
}
},
removeMask: function(){
this.target.unmask();
},
addMask: function(mask){
this.target.mask(mask === true ? null : mask);
},
load: function(options) {
options = Ext.apply({}, options);
var me = this,
mask = Ext.isDefined(options.loadMask) ? options.loadMask : me.loadMask,
params = Ext.apply({}, options.params),
ajaxOptions = Ext.apply({}, options.ajaxOptions),
callback = options.callback || me.callback,
scope = options.scope || me.scope || me;
Ext.applyIf(ajaxOptions, me.ajaxOptions);
Ext.applyIf(options, ajaxOptions);
Ext.applyIf(params, me.params);
Ext.apply(params, me.baseParams);
Ext.applyIf(options, {
url: me.url
});
Ext.apply(options, {
scope: me,
params: params,
callback: me.onComplete
});
if (me.fireEvent('beforeload', me, options) === false) {
return;
}
if (mask) {
me.addMask(mask);
}
me.active = {
options: options,
mask: mask,
scope: scope,
callback: callback,
success: options.success || me.success,
failure: options.failure || me.failure,
renderer: options.renderer || me.renderer,
scripts: Ext.isDefined(options.scripts) ? options.scripts : me.scripts
};
me.active.request = Ext.Ajax.request(options);
me.setOptions(me.active, options);
},
setOptions: Ext.emptyFn,
onComplete: function(options, success, response) {
var me = this,
active = me.active,
scope;
if (active) {
scope = active.scope;
if (success) {
success = me.getRenderer(active.renderer).call(me, me, response, active) !== false;
}
if (success) {
Ext.callback(active.success, scope, [me, response, options]);
me.fireEvent('load', me, response, options);
} else {
Ext.callback(active.failure, scope, [me, response, options]);
me.fireEvent('exception', me, response, options);
}
Ext.callback(active.callback, scope, [me, success, response, options]);
if (active.mask) {
me.removeMask();
}
}
delete me.active;
},
getRenderer: function(renderer){
if (Ext.isFunction(renderer)) {
return renderer;
}
return this.statics().Renderer.Html;
},
startAutoRefresh: function(interval, options){
var me = this;
me.stopAutoRefresh();
me.autoRefresh = setInterval(function(){
me.load(options);
}, interval);
},
stopAutoRefresh: function(){
clearInterval(this.autoRefresh);
delete this.autoRefresh;
},
isAutoRefreshing: function(){
return Ext.isDefined(this.autoRefresh);
},
destroy: function(){
var me = this;
me.stopAutoRefresh();
delete me.target;
me.abort();
me.clearListeners();
}
});
Ext.define('Ext.ComponentLoader', {
extend:  Ext.ElementLoader ,
statics: {
Renderer: {
Data: function(loader, response, active){
var success = true;
try {
loader.getTarget().update(Ext.decode(response.responseText));
} catch (e) {
success = false;
}
return success;
},
Component: function(loader, response, active){
var success = true,
target = loader.getTarget(),
items = [];
try {
items = Ext.decode(response.responseText);
} catch (e) {
success = false;
}
if (success) {
target.suspendLayouts();
if (active.removeAll) {
target.removeAll();
}
target.add(items);
target.resumeLayouts(true);
}
return success;
}
}
},
target: null,
loadMask: false,
renderer: 'html',
setTarget: function(target){
var me = this;
if (Ext.isString(target)) {
target = Ext.getCmp(target);
}
if (me.target && me.target != target) {
me.abort();
}
me.target = target;
},
removeMask: function(){
this.target.setLoading(false);
},
addMask: function(mask){
this.target.setLoading(mask);
},
setOptions: function(active, options){
active.removeAll = Ext.isDefined(options.removeAll) ? options.removeAll : this.removeAll;
},
getRenderer: function(renderer){
if (Ext.isFunction(renderer)) {
return renderer;
}
var renderers = this.statics().Renderer;
switch (renderer) {
case 'component':
return renderers.Component;
case 'data':
return renderers.Data;
default:
return Ext.ElementLoader.Renderer.Html;
}
}
});
Ext.define('Ext.layout.SizeModel', {
constructor: function (config) {
var me = this,
SizeModel = me.self,
sizeModelsArray = SizeModel.sizeModelsArray,
name;
Ext.apply(me, config);
me[name = me.name] = true; 
me.fixed = !(me.auto = me.natural || me.shrinkWrap);
sizeModelsArray[me.ordinal = sizeModelsArray.length] =
SizeModel[name] =
SizeModel.sizeModels[name] = me;
},
statics: {
sizeModelsArray: [],
sizeModels: {}
},
calculated: false,
configured: false,
constrainedMax: false,
constrainedMin: false,
natural: false,
shrinkWrap: false,
calculatedFromConfigured: false,
calculatedFromNatural: false,
calculatedFromShrinkWrap: false,
names: null
},
function () {
var SizeModel = this,
sizeModelsArray = SizeModel.sizeModelsArray,
i, j, n, pairs, sizeModel;
new SizeModel({
name: 'calculated'
});
new SizeModel({
name: 'configured',
names: { width: 'width', height: 'height' }
});
new SizeModel({
name: 'natural'
});
new SizeModel({
name: 'shrinkWrap'
});
new SizeModel({
name: 'calculatedFromConfigured',
configured: true,
names: { width: 'width', height: 'height' }
});
new SizeModel({
name: 'calculatedFromNatural',
natural: true
});
new SizeModel({
name: 'calculatedFromShrinkWrap',
shrinkWrap: true
});
new SizeModel({
name: 'constrainedMax',
configured: true,
constrained: true,
names: { width: 'maxWidth', height: 'maxHeight' }
});
new SizeModel({
name: 'constrainedMin',
configured: true,
constrained: true,
names: { width: 'minWidth', height: 'minHeight' }
});
new SizeModel({
name: 'constrainedDock',
configured: true,
constrained: true,
constrainedByMin: true,
names: { width: 'dockConstrainedWidth', height: 'dockConstrainedHeight' }
});
for (i = 0, n = sizeModelsArray.length; i < n; ++i) {
sizeModel = sizeModelsArray[i];
sizeModel.pairsByHeightOrdinal = pairs = [];
for (j = 0; j < n; ++j) {
pairs.push({
width: sizeModel,
height: sizeModelsArray[j]
});
}
}
});
Ext.define('Ext.layout.Layout', {
isLayout: true,
initialized: false,
running: false,
autoSizePolicy: {
readsWidth: 1,
readsHeight: 1,
setsWidth: 0,
setsHeight: 0
},
statics: {
layoutsByType: {},
create: function(layout, defaultType) {
var ClassManager = Ext.ClassManager,
layoutsByType = this.layoutsByType,
alias, className, config, layoutClass, type, load;
if (!layout || typeof layout === 'string') {
type = layout || defaultType;
config = {};                    
} else if (layout.isLayout) {
return layout;
} else {
config = layout;
type = layout.type || defaultType;
}
if (!(layoutClass = layoutsByType[type])) {
alias = 'layout.' + type;
className = ClassManager.getNameByAlias(alias);
if (!className) {
console.warn('`type` is undefined: ' + type)
load = true;
}
layoutClass = ClassManager.get(className);
if (load || !layoutClass) {
return ClassManager.instantiateByAlias(alias, config || {});
}
layoutsByType[type] = layoutClass;
}
return new layoutClass(config);
}
},
constructor : function(config) {
var me = this;
me.id = Ext.id(null, me.type + '-');
Ext.apply(me, config);
me.layoutCount = 0;
},
beginLayout: Ext.emptyFn,
beginLayoutCycle: function (ownerContext) {
var me = this,
context = me.context,
changed;
if (me.lastWidthModel != ownerContext.widthModel) {
if (me.lastWidthModel) {
changed = true;
}
me.lastWidthModel = ownerContext.widthModel;
}
if (me.lastHeightModel != ownerContext.heightModel) {
if (me.lastWidthModel) {
changed = true;
}
me.lastHeightModel = ownerContext.heightModel;
}
if (changed) {
(context = ownerContext.context).clearTriggers(me, false);
context.clearTriggers(me, true);
me.triggerCount = 0;
}
},
finishedLayout: function (ownerContext) {
this.lastWidthModel = ownerContext.widthModel;
this.lastHeightModel = ownerContext.heightModel;
this.ownerContext = null;
},
redoLayout: Ext.emptyFn,
undoLayout: Ext.emptyFn,
getAnimatePolicy: function() {
return this.animatePolicy;
},
getItemSizePolicy: function (item) {
return this.autoSizePolicy;
},
isItemBoxParent: function (itemContext) {
return false;
},
isItemLayoutRoot: function (item) {
var sizeModel = item.getSizeModel(),
width = sizeModel.width,
height = sizeModel.height;
if (!item.componentLayout.lastComponentSize && (width.calculated || height.calculated)) {
return false;
}
return !width.shrinkWrap && !height.shrinkWrap;
},
isItemShrinkWrap: function (item) {
return item.shrinkWrap;
},
isRunning: function () {
return !!this.ownerContext;
},
getItemsRenderTree: function (items, renderCfgs) {
var length = items.length,
i, item, itemConfig, result;
if (length) {
result = [];
for (i = 0; i < length; ++i) {
item = items[i];
if (!item.rendered) {
if (renderCfgs && (renderCfgs[item.id] !== undefined)) {
itemConfig = renderCfgs[item.id];
} else {
this.configureItem(item);
itemConfig = item.getRenderTree();
if (renderCfgs) {
renderCfgs[item.id] = itemConfig;
}
}
if (itemConfig) {
result.push(itemConfig);
}
}
}
}
return result;
},
finishRender: Ext.emptyFn,
finishRenderItems: function (target, items) {
var length = items.length,
i, item;
for (i = 0; i < length; i++) {
item = items[i];
if (item.rendering) {
item.finishRender(i);
this.afterRenderItem(item);
}
}
},
renderChildren: function () {
var me = this,
items = me.getLayoutItems(),
target = me.getRenderTarget();
me.renderItems(items, target);
},
renderItems : function(items, target) {
var me = this,
ln = items.length,
i = 0,
item;
if (ln) {
Ext.suspendLayouts();
for (; i < ln; i++) {
item = items[i];
if (item && !item.rendered) {
me.renderItem(item, target, i);
} else if (!me.isValidParent(item, target, i)) {
me.moveItem(item, target, i);
} else {
me.configureItem(item);
}
}
Ext.resumeLayouts(true);
}
},
isValidParent : function(item, target, position) {
var itemDom = item.el ? item.el.dom : Ext.getDom(item),
targetDom = (target && target.dom) || target,
parentNode = itemDom.parentNode,
className;
if (parentNode) {
className = parentNode.className;
if (className && className.indexOf(Ext.baseCSSPrefix + 'resizable-wrap') !== -1) {
itemDom = itemDom.parentNode;
}
}
if (itemDom && targetDom) {
if (typeof position == 'number') {
position = this.getPositionOffset(position);
return itemDom === targetDom.childNodes[position];
}
return itemDom.parentNode === targetDom;
}
return false;
},
getPositionOffset: function(position){
return position;
},
configureItem: function(item) {
item.ownerLayout = this;
},
renderItem : function(item, target, position) {
var me = this;
if (!item.rendered) {
me.configureItem(item);
item.render(target, position);
me.afterRenderItem(item);
}
},
moveItem : function(item, target, position) {
target = target.dom || target;
if (typeof position == 'number') {
position = target.childNodes[position];
}
target.insertBefore(item.el.dom, position || null);
item.container = Ext.get(target);
this.configureItem(item);
},
onContentChange: function () {
this.owner.updateLayout();
return true;
},
initLayout : function() {
this.initialized = true;
},
setOwner : function(owner) {
this.owner = owner;
},
getLayoutItems : function() {
return [];
},
onAdd: function (item) {
item.ownerLayout = this;
},
afterRenderItem: Ext.emptyFn,
onRemove : Ext.emptyFn,
onDestroy : Ext.emptyFn,
afterRemove : function(item) {
var me = this,
el = item.el,
owner = me.owner,
removeClasses;
if (item.rendered) {
removeClasses = [].concat(me.itemCls || []);
if (owner.itemCls) {
removeClasses = Ext.Array.push(removeClasses, owner.itemCls);
}
if (removeClasses.length) {
el.removeCls(removeClasses);
}
}
delete item.ownerLayout;
},
destroy : function() {
var me = this,
target;
if (me.targetCls) {
target = me.getTarget();
if (target) {
target.removeCls(me.targetCls);
}
}
me.onDestroy();
},
sortWeightedItems: function (items, reverseProp) {
for (var i = 0, length = items.length; i < length; ++i) {
items[i].$i = i;
}
Ext.Array.sort(items, function (item1, item2) {
var ret = item2.weight - item1.weight;
if (!ret) {
ret = item1.$i - item2.$i;
if (item1[reverseProp]) {
ret = -ret;
}
}
return ret;
});
for (i = 0; i < length; ++i) {
delete items[i].$i;
}
}
}, function () {
var Layout = this;
Layout.prototype.sizeModels = Layout.sizeModels = Ext.layout.SizeModel.sizeModels;
});
Ext.define('Ext.layout.container.Container', {
alias: ['layout.container'],
extend:  Ext.layout.Layout ,
alternateClassName: 'Ext.layout.ContainerLayout',
mixins: {
elementCt:  Ext.util.ElementContainer 
},
type: 'container',
beginCollapse: Ext.emptyFn,
beginExpand: Ext.emptyFn,
animatePolicy: null,
childEls: [
'overflowPadderEl'
],
renderTpl: [
'{%this.renderBody(out,values)%}'
],
usesContainerHeight: true,
usesContainerWidth: true,
usesHeight: true,
usesWidth: true,
constructor: function () {
this.callParent(arguments);
this.mixins.elementCt.constructor.call(this);
},
destroy : function() {
this.callParent();
this.mixins.elementCt.destroy.call(this);
},
beginLayout: function (ownerContext) {
this.callParent(arguments);
ownerContext.targetContext = ownerContext.paddingContext = ownerContext.getEl('getTarget', this);
this.cacheChildItems(ownerContext);
},
beginLayoutCycle: function (ownerContext, firstCycle) {
var me = this;
me.callParent(arguments);
if (firstCycle) {
if (me.usesContainerHeight) {
++ownerContext.consumersContainerHeight;
}
if (me.usesContainerWidth) {
++ownerContext.consumersContainerWidth;
}
}
},
cacheChildItems: function (ownerContext) {
var context = ownerContext.context,
childItems = [],
items = this.getVisibleItems(),
length = items.length,
i;
ownerContext.childItems = childItems;
ownerContext.visibleItems = items;
for (i = 0; i < length; ++i) {
childItems.push(context.getCmp(items[i]));
}
},
cacheElements: function () {
var owner = this.owner;
this.applyChildEls(owner.el, owner.id); 
},
configureItem: function(item) {
var me = this,
itemCls = me.itemCls,
ownerItemCls = me.owner.itemCls,
addClasses;
item.ownerLayout = me;
if (itemCls) {
addClasses = typeof itemCls === 'string' ? [itemCls] : itemCls;
}
if (ownerItemCls) {
addClasses = Ext.Array.push(addClasses||[], ownerItemCls);
}
if (addClasses) {
item.addCls(addClasses);
}
},
doRenderBody: function (out, renderData) {
this.renderItems(out, renderData);
this.renderContent(out, renderData);
},
doRenderContainer: function (out, renderData) {
var me = renderData.$comp.layout,
tpl = me.getRenderTpl(),
data = me.getRenderData();
tpl.applyOut(data, out);
},
doRenderItems: function (out, renderData) {
var me = renderData.$layout,
tree = me.getRenderTree();
if (tree) {
Ext.DomHelper.generateMarkup(tree, out);
}
},
finishRender: function () {
var me = this,
target, items;
me.callParent();
me.cacheElements();
target = me.getRenderTarget();
items = me.getLayoutItems();
me.finishRenderItems(target, items);
},
notifyOwner: function() {
this.owner.afterLayout(this);
},
getContainerSize : function(ownerContext, inDom) {
var targetContext = ownerContext.targetContext,
frameInfo = targetContext.getFrameInfo(),
padding = ownerContext.paddingContext.getPaddingInfo(),
got = 0,
needed = 0,
gotWidth, gotHeight, width, height;
if (!ownerContext.widthModel.shrinkWrap) {
++needed;
width = inDom ? targetContext.getDomProp('width') : targetContext.getProp('width');
gotWidth = (typeof width == 'number');
if (gotWidth) {
++got;
width -= frameInfo.width + padding.width;
if (width < 0) {
width = 0;
}
}
}
if (!ownerContext.heightModel.shrinkWrap) {
++needed;
height = inDom ? targetContext.getDomProp('height') : targetContext.getProp('height');
gotHeight = (typeof height == 'number');
if (gotHeight) {
++got;
height -= frameInfo.height + padding.height;
if (height < 0) {
height = 0;
}
}
}
return {
width: width,
height: height,
needed: needed,
got: got,
gotAll: got == needed,
gotWidth: gotWidth,
gotHeight: gotHeight
};
},
getPositionOffset: function(position) {
if (!this.createsInnerCt) {
var offset = this.owner.itemNodeOffset;
if (offset) {
position += offset;
}
}
return position;
},
getLayoutItems: function() {
var owner = this.owner,
items = owner && owner.items;
return (items && items.items) || [];
},
getRenderData: function () {
var comp = this.owner;
return {
$comp: comp,
$layout: this,
ownerId: comp.id
};
},
getRenderedItems: function() {
var me = this,
target = me.getRenderTarget(),
items = me.getLayoutItems(),
ln = items.length,
renderedItems = [],
i, item;
for (i = 0; i < ln; i++) {
item = items[i];
if (item.rendered && me.isValidParent(item, target, i)) {
renderedItems.push(item);
}
}
return renderedItems;
},
getRenderTarget: function() {
return this.owner.getTargetEl();
},
getElementTarget: function() {
return this.getRenderTarget();
},
getRenderTpl: function () {
var me = this,
renderTpl = Ext.XTemplate.getTpl(this, 'renderTpl');
if (!renderTpl.renderContent) {
me.owner.setupRenderTpl(renderTpl);
}
return renderTpl;
},
getRenderTree: function () {
var result,
items = this.owner.items,
itemsGen,
renderCfgs = {};
do {
itemsGen = items.generation;
result = this.getItemsRenderTree(this.getLayoutItems(), renderCfgs);
} while (items.generation !== itemsGen);
return result;
},
renderChildren: function () {
var me = this,
ownerItems = me.owner.items,
target = me.getRenderTarget(),
itemsGen, items;
do {
itemsGen = ownerItems.generation;
items = me.getLayoutItems();
me.renderItems(items, target);
} while (ownerItems.generation !== itemsGen);
},
getScrollbarsNeeded: function (width, height, contentWidth, contentHeight) {
var scrollbarSize = Ext.getScrollbarSize(),
hasWidth = typeof width == 'number',
hasHeight = typeof height == 'number',
needHorz = 0,
needVert = 0;
if (!scrollbarSize.width) {
return 0;
}
if (hasHeight && height < contentHeight) {
needVert = 2;
width -= scrollbarSize.width;
}
if (hasWidth && width < contentWidth) {
needHorz = 1;
if (!needVert && hasHeight) {
height -= scrollbarSize.height;
if (height < contentHeight) {
needVert = 2;
}
}
}
return needVert + needHorz;
},
getTarget: function() {
return this.owner.getTargetEl();
},
getVisibleItems: function() {
var target   = this.getRenderTarget(),
items = this.getLayoutItems(),
ln = items.length,
visibleItems = [],
i, item;
for (i = 0; i < ln; i++) {
item = items[i];
if (item.rendered && this.isValidParent(item, target, i) && item.hidden !== true) {
visibleItems.push(item);
}
}
return visibleItems;
},
setupRenderTpl: function (renderTpl) {
var me = this;
renderTpl.renderBody = me.doRenderBody;
renderTpl.renderContainer = me.doRenderContainer;
renderTpl.renderItems = me.doRenderItems;
},
getContentTarget: function(){
return this.owner.getDefaultContentTarget();
}
});
Ext.define('Ext.layout.container.Auto', {
alias: ['layout.auto', 'layout.autocontainer'],
extend:  Ext.layout.container.Container ,
type: 'autocontainer',
childEls: [
'outerCt',
'innerCt',
'clearEl'
],
reserveScrollbar: false,
managePadding: true,
manageOverflow: false,
lastOverflowAdjust: {
width: 0,
height: 0
},
renderTpl: [
'{% if (!(Ext.isIEQuirks || Ext.isIE7m)) { %}',
'<span id="{ownerId}-outerCt" style="display:table;" role="presentation">',
'<div id="{ownerId}-innerCt" style="display:table-cell;height:100%;',
'vertical-align:top;{%this.renderPadding(out, values)%}" class="{innerCtCls}" role="presentation">',
'{%this.renderBody(out,values)%}',
'</div>',
'</span>',
'{% } else if (values.shrinkWrapWidth) { %}',
'<table id="{ownerId}-outerCt" class="' + Ext.plainTableCls + '" role="presentation">',
'<tbody role="presentation">',
'<tr role="presentation">',
'<td id="{ownerId}-innerCt" style="vertical-align:top;padding:0;',
'{%this.renderPadding(out, values)%}" class="{innerCtCls}" role="presentation">',
'{%this.renderBody(out,values)%}',
'<div id="{ownerId}-clearEl" class="', Ext.baseCSSPrefix,  'clear"',
'role="presentation"></div>',
'</td>',
'</tr>',
'</tbody>',
'</table>',
'{% } else { %}',
'<div id="{ownerId}-outerCt" style="zoom:1;{%this.renderPadding(out, values)%}" role="presentation">',
'<div id="{ownerId}-innerCt" style="zoom:1;height:100%;" class="{innerCtCls}" role="presentation">',
'{%this.renderBody(out,values)%}',
'<div id="{ownerId}-clearEl" class="', Ext.baseCSSPrefix,  'clear"',
'role="presentation"></div>',
'</div>',
'</div>',
'{% values.$layout.isShrinkWrapTpl = false %}',
'{% } %}'
],
tableTpl: [
'<table id="{ownerId}-outerCt" class="' + Ext.plainTableCls + '" role="presentation">',
'<tbody role="presentation">',
'<tr role="presentation">',
'<td id="{ownerId}-innerCt" style="vertical-align:top;padding:0;',
'{%this.renderPadding(out, values)%}" class="{innerCtCls}" role="presentation">',
'</td>',
'</tr>',
'</tbody>',
'</table>'
],
isShrinkWrapTpl: true,
beginLayout: function(ownerContext) {
var me = this,
bottomPadding, overflowYStyle, overflowXStyle, needsTable;
me.callParent(arguments);
me.initContextItems(ownerContext);
if (!me.isShrinkWrapTpl) {
if (ownerContext.widthModel.shrinkWrap) {
needsTable = true;
}
if (Ext.isStrict && Ext.isIE7) {
overflowXStyle = me.getOverflowXStyle(ownerContext);
if ((overflowXStyle === 'auto' || overflowXStyle === 'scroll') &&
ownerContext.paddingContext.getPaddingInfo().right) {
needsTable = true;
}
}
if (needsTable) {
me.insertTableCt(ownerContext);
}
}
if (!me.isShrinkWrapTpl && Ext.isIE7 && Ext.isStrict && !me.clearElHasPadding) {
bottomPadding = ownerContext.paddingContext.getPaddingInfo().bottom;
overflowYStyle = me.getOverflowYStyle(ownerContext);
if (bottomPadding && (overflowYStyle === 'auto' || overflowYStyle === 'scroll')) {
me.clearEl.setStyle('height', bottomPadding);
me.clearElHasPadding = true;
}
}
},
beforeLayoutCycle: function(ownerContext){
var comp = this.owner,
hierarchyState = comp.hierarchyState,
hierarchyStateInner = comp.hierarchyStateInner;
if (!hierarchyState || hierarchyState.invalid) {
hierarchyState = comp.getHierarchyState(); 
hierarchyStateInner = comp.hierarchyStateInner;
}
if (ownerContext.widthModel.shrinkWrap && this.isShrinkWrapTpl) {
hierarchyStateInner.inShrinkWrapTable = true;
} else {
delete hierarchyStateInner.inShrinkWrapTable;
}
},
beginLayoutCycle: function(ownerContext) {
var me = this,
outerCt = me.outerCt,
lastOuterCtWidth = me.lastOuterCtWidth || '',
lastOuterCtHeight = me.lastOuterCtHeight || '',
lastOuterCtTableLayout = me.lastOuterCtTableLayout || '',
state = ownerContext.state,
overflowXStyle, overflowYStyle, outerCtWidth, outerCtHeight, outerCtTableLayout,
deferWidth, hierarchyStateInner;
me.callParent(arguments);
outerCtWidth = outerCtHeight = outerCtTableLayout = '';
if (!ownerContext.widthModel.shrinkWrap && me.isShrinkWrapTpl) {
if (Ext.isIE7m && Ext.isStrict) {
overflowYStyle = me.getOverflowYStyle(ownerContext);
if (overflowYStyle === 'auto' || overflowYStyle === 'scroll') {
deferWidth = true;
}
}
if (!deferWidth) {
outerCtWidth = '100%';
}
hierarchyStateInner = me.owner.hierarchyStateInner;
overflowXStyle = me.getOverflowXStyle(ownerContext);
outerCtTableLayout = (hierarchyStateInner.inShrinkWrapTable ||
overflowXStyle === 'auto' || 
overflowXStyle === 'scroll') ? '' : 'fixed';
}
if (!ownerContext.heightModel.shrinkWrap && 
!Ext.supports.PercentageHeightOverflowBug) {
outerCtHeight = '100%';
}
if ((outerCtWidth !== lastOuterCtWidth) || me.hasOuterCtPxWidth) {
outerCt.setStyle('width', outerCtWidth);
me.lastOuterCtWidth = outerCtWidth;
me.hasOuterCtPxWidth = false;
}
if (outerCtTableLayout !== lastOuterCtTableLayout) {
outerCt.setStyle('table-layout', outerCtTableLayout);
me.lastOuterCtTableLayout = outerCtTableLayout;
}
if ((outerCtHeight !== lastOuterCtHeight) || me.hasOuterCtPxHeight) {
outerCt.setStyle('height', outerCtHeight);
me.lastOuterCtHeight = outerCtHeight;
me.hasOuterCtPxHeight = false;
}
if (me.hasInnerCtPxHeight) {
me.innerCt.setStyle('height', '');
me.hasInnerCtPxHeight = false;
}
state.overflowAdjust = state.overflowAdjust || me.lastOverflowAdjust;
},
calculate: function(ownerContext) {
var me = this,
state = ownerContext.state,
containerSize = me.getContainerSize(ownerContext, true),
calculatedItems = state.calculatedItems ||
(state.calculatedItems = me.calculateItems ?
me.calculateItems(ownerContext, containerSize) : true);
me.setCtSizeIfNeeded(ownerContext, containerSize);
if (calculatedItems && ownerContext.hasDomProp('containerChildrenSizeDone')) {
me.calculateContentSize(ownerContext);
if (containerSize.gotAll) {
if (me.manageOverflow && !ownerContext.state.secondPass && !me.reserveScrollbar) {
me.calculateOverflow(ownerContext, containerSize);
}
return;
}
}
me.done = false;
},
calculateContentSize: function (ownerContext) {
var me = this,
containerDimensions = ((ownerContext.widthModel.shrinkWrap ? 1 : 0) |
(ownerContext.heightModel.shrinkWrap ? 2 : 0)),
calcWidth = (containerDimensions & 1) || undefined,
calcHeight = (containerDimensions & 2) || undefined,
needed = 0,
props = ownerContext.props;
if (calcWidth) {
if (isNaN(props.contentWidth)) {
++needed;
} else {
calcWidth = undefined;
}
}
if (calcHeight) {
if (isNaN(props.contentHeight)) {
++needed;
} else {
calcHeight = undefined;
}
}
if (needed) {
if (calcWidth && !ownerContext.setContentWidth(me.measureContentWidth(ownerContext))) {
me.done = false;
}
if (calcHeight && !ownerContext.setContentHeight(me.measureContentHeight(ownerContext))) {
me.done = false;
}
}
},
calculateOverflow: function (ownerContext) {
var me = this,
width, height, scrollbarSize, scrollbars, xauto, yauto, targetEl;
xauto = (me.getOverflowXStyle(ownerContext) === 'auto');
yauto = (me.getOverflowYStyle(ownerContext) === 'auto');
if (xauto || yauto) {
scrollbarSize = Ext.getScrollbarSize();
targetEl = ownerContext.overflowContext.el.dom;
scrollbars = 0;
if (targetEl.scrollWidth > targetEl.clientWidth) {
scrollbars |= 1;
}
if (targetEl.scrollHeight > targetEl.clientHeight) {
scrollbars |= 2;
}
width = (yauto && (scrollbars & 2)) ? scrollbarSize.width : 0;
height = (xauto && (scrollbars & 1)) ? scrollbarSize.height : 0;
if (width !== me.lastOverflowAdjust.width || height !== me.lastOverflowAdjust.height) {
me.done = false;
ownerContext.invalidate({
state: {
overflowAdjust: {
width: width,
height: height
},
overflowState: scrollbars,
secondPass: true
}
});
}
}
},
completeLayout: function(ownerContext) {
this.lastOverflowAdjust = ownerContext.state.overflowAdjust;
},
doRenderPadding: function(out, renderData) {
var me = renderData.$layout,
owner = renderData.$layout.owner,
padding = owner[owner.contentPaddingProperty];
if (me.managePadding && padding) {
out.push('padding:', owner.unitizeBox(padding));
}
},
finishedLayout: function (ownerContext) {
var innerCt = this.innerCt;
this.callParent(arguments);
if (Ext.isIEQuirks || Ext.isIE8m)  {
innerCt.repaint();
}
if (Ext.isOpera) {
innerCt.setStyle('position', 'relative');
innerCt.dom.scrollWidth;
innerCt.setStyle('position', '');
}
},
getContainerSize : function(ownerContext, inDom) {
var size = this.callParent(arguments),
overflowAdjust = ownerContext.state.overflowAdjust;
if (overflowAdjust) {
size.width -= overflowAdjust.width;
size.height -= overflowAdjust.height;
}
return size;
},
getRenderData: function() {
var owner = this.owner,
data = this.callParent();
if ((Ext.isIEQuirks || Ext.isIE7m) && 
((owner.shrinkWrap & 1) || 
(owner.floating && !owner.width))) { 
data.shrinkWrapWidth = true;
}
return data;
},
getRenderTarget: function() {
return this.innerCt;
},
getElementTarget: function() {
return this.innerCt;
},
getOverflowXStyle: function(ownerContext) {
return ownerContext.overflowXStyle ||
(ownerContext.overflowXStyle = this.owner.scrollFlags.overflowX || ownerContext.overflowContext.getStyle('overflow-x'));
},
getOverflowYStyle: function(ownerContext) {
return ownerContext.overflowYStyle || 
(ownerContext.overflowYStyle = this.owner.scrollFlags.overflowY || ownerContext.overflowContext.getStyle('overflow-y'));
},
initContextItems: function(ownerContext) {
var me = this,
target = ownerContext.target,
customOverflowEl = me.owner.customOverflowEl;
ownerContext.outerCtContext = ownerContext.getEl('outerCt', me);
ownerContext.innerCtContext = ownerContext.getEl('innerCt', me);
if (customOverflowEl) {
ownerContext.overflowContext = ownerContext.getEl(customOverflowEl);    
} else {
ownerContext.overflowContext = ownerContext.targetContext;
}
if (target[target.contentPaddingProperty] !== undefined) {
ownerContext.paddingContext = me.isShrinkWrapTpl ?
ownerContext.innerCtContext : ownerContext.outerCtContext;
}
},
initLayout: function() {
var me = this,
scrollbarWidth = Ext.getScrollbarSize().width,
owner = me.owner;
me.callParent();
if (scrollbarWidth && me.manageOverflow && !me.hasOwnProperty('lastOverflowAdjust')) {
if (owner.autoScroll || me.reserveScrollbar) {
me.lastOverflowAdjust = {
width: scrollbarWidth,
height: 0
};
}
}
},
insertTableCt: function(ownerContext) {
var me = this,
owner = me.owner,
i = 0,
renderTpl, fragment, childNodes, childLength, targetEl;
renderTpl = Ext.XTemplate.getTpl(this, 'tableTpl');
renderTpl.renderPadding = me.doRenderPadding;
me.outerCt.dom.removeChild(me.innerCt.dom);
fragment = document.createDocumentFragment();
childNodes = me.innerCt.dom.childNodes;
childLength = childNodes.length;
for (; i < childLength; i++) {
fragment.appendChild(childNodes[0]);
}
targetEl = me.getTarget();
targetEl.dom.innerHTML = renderTpl.apply({
$layout: me,
ownerId: me.owner.id
});
targetEl.down('td').dom.appendChild(fragment);
me.applyChildEls(owner.el, owner.id)
me.isShrinkWrapTpl = true;
ownerContext.removeEl(me.outerCt);
ownerContext.removeEl(me.innerCt);
me.initContextItems(ownerContext);
},
measureContentHeight: function (ownerContext) {
var contentHeight = this.outerCt.getHeight(),
target = ownerContext.target;
if (this.managePadding && (target[target.contentPaddingProperty] === undefined)) {
contentHeight += ownerContext.targetContext.getPaddingInfo().height;
}
return contentHeight;
},
measureContentWidth: function (ownerContext) {
var dom, style, old, contentWidth, target;
if (this.chromeCellMeasureBug) {
dom = this.innerCt.dom;
style = dom.style;
old = style.display;
if (old == 'table-cell') {
style.display = '';
dom.offsetWidth;
style.display = old;
}    
}
contentWidth = this.outerCt.getWidth();
target = ownerContext.target;
if (this.managePadding && (target[target.contentPaddingProperty] === undefined)) {
contentWidth += ownerContext.targetContext.getPaddingInfo().width;
}
return contentWidth;
},
setCtSizeIfNeeded: function(ownerContext, containerSize) {
var me = this,
width = containerSize.width,
height = containerSize.height,
padding = ownerContext.paddingContext.getPaddingInfo(),
targetEl = me.getTarget(),
overflowXStyle = me.getOverflowXStyle(ownerContext),
overflowYStyle = me.getOverflowYStyle(ownerContext),
canOverflowX = (overflowXStyle === 'auto' || overflowXStyle === 'scroll'),
canOverflowY = (overflowYStyle === 'auto' || overflowYStyle === 'scroll'),
scrollbarSize = Ext.getScrollbarSize(),
isShrinkWrapTpl = me.isShrinkWrapTpl,
manageOverflow = me.manageOverflow,
overflowStyleName, needsOuterHeight, needsInnerHeight, needsInnerCtPaddingHeight;
if (width && !ownerContext.widthModel.shrinkWrap &&
((Ext.isIE7m && Ext.isStrict && isShrinkWrapTpl && canOverflowY) ||
(Ext.isIEQuirks && !isShrinkWrapTpl && !canOverflowX))) {
if (!manageOverflow) {
if (canOverflowY && (targetEl.dom.scrollHeight > targetEl.dom.clientHeight)) {
width -= scrollbarSize.width;
}
}
ownerContext.outerCtContext.setProp('width', width + padding.width);
me.hasOuterCtPxWidth = true;
}
if (height && !ownerContext.heightModel.shrinkWrap) {
if (Ext.supports.PercentageHeightOverflowBug) {
needsOuterHeight = true;
}
if (((Ext.isIE8 && Ext.isStrict) ||
Ext.isIE7m && Ext.isStrict && isShrinkWrapTpl)) {
needsInnerHeight = true;
needsInnerCtPaddingHeight = !Ext.isIE8;
}
if ((needsOuterHeight || needsInnerHeight) && canOverflowX && 
(targetEl.dom.scrollWidth > targetEl.dom.clientWidth)) {
height = Math.max(height - scrollbarSize.height, 0);
}
if (needsOuterHeight) {
ownerContext.outerCtContext.setProp('height', height + padding.height);
me.hasOuterCtPxHeight = true;
}
if (needsInnerHeight) {
if (needsInnerCtPaddingHeight) {
height += padding.height;
}
ownerContext.innerCtContext.setProp('height', height);
me.hasInnerCtPxHeight = true;
}
}
if (Ext.isIE7 && Ext.isStrict && !isShrinkWrapTpl && (overflowYStyle === 'auto')) {
overflowStyleName = (overflowXStyle === 'auto') ? 'overflow-x' : 'overflow-y';
targetEl.setStyle(overflowStyleName, 'hidden');
targetEl.setStyle(overflowStyleName, 'auto');
}
},
setupRenderTpl: function (renderTpl) {
this.callParent(arguments);
renderTpl.renderPadding = this.doRenderPadding;
},
getContentTarget: function(){
return this.innerCt;
}
}, function(){
this.prototype.chromeCellMeasureBug = Ext.isChrome && Ext.chromeVersion >= 26;
});
Ext.define('Ext.ZIndexManager', {
alternateClassName: 'Ext.WindowGroup',
statics: {
zBase : 9000
},
constructor: function(container) {
var me = this;
me.map = {};
me.zIndexStack = [];
me.front = null;
if (container) {
if (container.isContainer) {
container.on('resize', me._onContainerResize, me);
me.zseed = Ext.Number.from(me.rendered ? container.getEl().getStyle('zIndex') : undefined, me.getNextZSeed());
me.targetEl = container.getTargetEl();
me.container = container;
}
else {
Ext.EventManager.onWindowResize(me._onContainerResize, me);
me.zseed = me.getNextZSeed();
me.targetEl = Ext.get(container);
}
}
else {
Ext.EventManager.onWindowResize(me._onContainerResize, me);
me.zseed = me.getNextZSeed();
Ext.onDocumentReady(function() {
me.targetEl = Ext.getBody();
});
}
},
getNextZSeed: function() {
return (Ext.ZIndexManager.zBase += 10000);
},
setBase: function(baseZIndex) {
this.zseed = baseZIndex;
var result = this.assignZIndices();
this._activateLast();
return result;
},
assignZIndices: function() {
var a = this.zIndexStack,
len = a.length,
i = 0,
zIndex = this.zseed,
comp,
topModal;
for (; i < len; i++) {
comp = a[i];
if (comp && !comp.hidden) {
zIndex = comp.setZIndex(zIndex);
if (comp.modal) {
topModal = comp;
}
}
}
if (topModal) {
this._showModalMask(topModal)
}
return zIndex;
},
_setActiveChild: function(comp, oldFront) {
var front = this.front,
oldPreventFocus = comp.preventFocusOnActivate;
if (comp !== front) {
if (front && !front.destroying) {
front.setActive(false, comp);
}
this.front = comp;
if (comp && comp != oldFront) {
comp.preventFocusOnActivate = comp.preventFocusOnActivate || oldFront && (oldFront.preventFocusOnActivate || !oldFront.focusOnToFront);
comp.setActive(true);
if (comp.modal) {
this._showModalMask(comp);
}
comp.preventFocusOnActivate = oldPreventFocus;
}
}
},
onComponentHide: function(comp){
this._activateLast();
},
_activateLast: function() {
var me = this,
stack = me.zIndexStack,
i = stack.length - 1,
comp;
for (; i >= 0 && stack[i].hidden; --i);
if ((comp = stack[i])) {
me._setActiveChild(comp, me.front);
if (comp.modal) {
return;
}
}
else {
if (me.front && !me.front.destroying) {
me.front.setActive(false);
}
me.front = null;
}
for (; i >= 0; --i) {
comp = stack[i];
if (comp.isVisible() && comp.modal) {
me._showModalMask(comp);
return;
}
}
me._hideModalMask();
},
_showModalMask: function(comp) {
var me = this,
zIndex = comp.el.getStyle('zIndex') - 4,
maskTarget = comp.floatParent ? comp.floatParent.getTargetEl() : comp.container,
mask = me.mask,
shim = me.maskShim,
viewSize;
if (!mask) {
if (Ext.isIE6) {
shim = me.maskShim = Ext.getBody().createChild({
tag: 'iframe',
role: 'presentation',
cls : Ext.baseCSSPrefix + 'shim ' + Ext.baseCSSPrefix + 'mask-shim'
});
shim.setVisibilityMode(Ext.Element.DISPLAY);
}
mask = me.mask = Ext.getBody().createChild({
role: 'presentation',
cls: Ext.baseCSSPrefix + 'mask',
style: 'height:0;width:0'
});
mask.setVisibilityMode(Ext.Element.DISPLAY);
mask.on('click', me._onMaskClick, me);
}
mask.maskTarget = maskTarget;
viewSize = me.getMaskBox();
if (shim) {
shim.setStyle('zIndex', zIndex);
shim.show();
shim.setBox(viewSize);
}
mask.setStyle('zIndex', zIndex);
mask.show();
mask.setBox(viewSize);
},
_hideModalMask: function() {
var mask = this.mask,
maskShim = this.maskShim;
if (mask && mask.isVisible()) {
mask.maskTarget = undefined;
mask.hide();
if (maskShim) {
maskShim.hide();
}
}
},
_onMaskClick: function() {
if (this.front) {
this.front.focus();
}
},
getMaskBox: function(){
var maskTarget = this.mask.maskTarget;
if (maskTarget.dom === document.body) {
return {
height: Math.max(document.body.scrollHeight, Ext.dom.Element.getDocumentHeight()),
width: Math.max(document.body.scrollWidth, document.documentElement.clientWidth),
x: 0,
y: 0
};
} else {
return maskTarget.getBox();
} 
},
_onContainerResize: function() {
var me = this,
mask = me.mask,
maskShim = me.maskShim,
viewSize;
if (mask && mask.isVisible()) {
mask.hide();
if (maskShim) {
maskShim.hide();
}
viewSize = me.getMaskBox();
if (maskShim) {
maskShim.setSize(viewSize);
maskShim.show();
}
mask.setSize(viewSize);
mask.show();
}
},
register : function(comp) {
var me = this,
compAfterHide = comp.afterHide;
if (comp.zIndexManager) {
comp.zIndexManager.unregister(comp);
}
comp.zIndexManager = me;
me.map[comp.id] = comp;
me.zIndexStack.push(comp);
comp.afterHide = function() {
compAfterHide.apply(comp, arguments);
me.onComponentHide(comp);
};
},
unregister : function(comp) {
var me = this,
map = me.map;
delete comp.zIndexManager;
if (map && map[comp.id]) {
delete map[comp.id];
delete comp.afterHide;
Ext.Array.remove(me.zIndexStack, comp);
me._activateLast();
}
},
get : function(id) {
return id.isComponent ? id : this.map[id];
},
bringToFront : function(comp, preventFocus) {
var me = this,
result = false,
zIndexStack = me.zIndexStack;
comp = me.get(comp);
if (comp !== me.front) {
Ext.Array.remove(zIndexStack, comp);
if (comp.preventBringToFront) {
zIndexStack.unshift(comp);
} else {
zIndexStack.push(comp);
}
me.assignZIndices();
if (!preventFocus) {
me._activateLast();
}
result = true;
me.front = comp;
if (comp.modal) {
me._showModalMask(comp);
}
}
return result;
},
sendToBack : function(comp) {
var me = this;
comp = me.get(comp);
Ext.Array.remove(me.zIndexStack, comp);
me.zIndexStack.unshift(comp);
me.assignZIndices();
this._activateLast();
return comp;
},
hideAll : function() {
var map = this.map,
item,
id;
for (id in map) {
if (map.hasOwnProperty(id)) {
item = map[id];
if (item.isComponent && item.isVisible()) {
item.hide();
}
}
}
},
hide: function() {
var i = 0,
stack = this.zIndexStack,
len = stack.length,
comp;
this.tempHidden = [];
for (; i < len; i++) {
comp = stack[i];
if (comp.isVisible()) {
this.tempHidden.push(comp);
comp.el.hide();
comp.hidden = true;
}
}
},
show: function() {
var i = 0,
tempHidden = this.tempHidden,
len = tempHidden ? tempHidden.length : 0,
comp;
for (; i < len; i++) {
comp = tempHidden[i];
comp.el && comp.el.show();
comp.hidden = false;
comp.setPosition(comp.x, comp.y);
}
this.tempHidden = void 0;
},
getActive : function() {
return this.front;
},
getBy : function(fn, scope) {
var r = [],
i = 0,
stack = this.zIndexStack,
len = stack.length,
comp;
for (; i < len; i++) {
comp = stack[i];
if (fn.call(scope||comp, comp) !== false) {
r.push(comp);
}
}
return r;
},
each : function(fn, scope) {
var map = this.map,
id,
comp;
for (id in map) {
if (map.hasOwnProperty(id)) {
comp = map[id];
if (comp.isComponent && fn.call(scope || comp, comp) === false) {
return;
}
}
}
},
eachBottomUp: function (fn, scope) {
var stack = this.zIndexStack,
i = 0,
len = stack.length,
comp;
for (; i < len; i++) {
comp = stack[i];
if (comp.isComponent && fn.call(scope || comp, comp) === false) {
return;
}
}
},
eachTopDown: function (fn, scope) {
var stack = this.zIndexStack,
i = stack.length,
comp;
for (; i-- > 0; ) {
comp = stack[i];
if (comp.isComponent && fn.call(scope || comp, comp) === false) {
return;
}
}
},
destroy: function() {
var me   = this,
map = me.map,
comp,
id;
for (id in map) {
if (map.hasOwnProperty(id)) {
comp = map[id];
if (comp.isComponent) {
comp.destroy();
}
}
}
Ext.destroy(me.mask);
Ext.destroy(me.maskShim);
delete me.zIndexStack;
delete me.map;
delete me.container;
delete me.targetEl;
}
}, function() {
Ext.WindowManager = Ext.WindowMgr = new this();
});
Ext.define('Ext.Queryable', {
isQueryable: true,
query : function(selector) {
selector = selector || '*';
return Ext.ComponentQuery.query(selector, this);
},
queryBy: function(fn, scope) {
var out = [],
items = this.getRefItems(true),
i = 0,
len = items.length,
item;
for (; i < len; ++i) {
item = items[i];
if (fn.call(scope || item, item) !== false) {
out.push(item);
}
}
return out;
},
queryById: function(id){
return this.down('#' + id);
},
child: function (selector) {
if (selector && selector.isComponent) {
selector = '#' + Ext.escapeId(selector.getItemId());
}
selector = selector || '';
return this.query('> ' + selector)[0] || null;
},
down: function (selector) {
if (selector && selector.isComponent) {
selector = '#' + Ext.escapeId(selector.getItemId());
}
selector = selector || '';
return this.query(selector)[0] || null;
},
getRefItems: function(){
return [];
}
});
Ext.define('Ext.layout.component.Component', {
extend:  Ext.layout.Layout ,
type: 'component',
isComponentLayout: true,
nullBox: {},
usesContentHeight: true,
usesContentWidth: true,
usesHeight: true,
usesWidth: true,
beginLayoutCycle: function (ownerContext, firstCycle) {
var me = this,
owner = me.owner,
ownerCtContext = ownerContext.ownerCtContext,
heightModel = ownerContext.heightModel,
widthModel = ownerContext.widthModel,
body = owner.el.dom === document.body,
lastBox = owner.lastBox || me.nullBox,
lastSize = owner.el.lastBox || me.nullBox,
dirty = !body,
ownerLayout, v, widthName, heightName;
me.callParent(arguments);
if (firstCycle) {
if (me.usesContentWidth) {
++ownerContext.consumersContentWidth;
}
if (me.usesContentHeight) {
++ownerContext.consumersContentHeight;
}
if (me.usesWidth) {
++ownerContext.consumersWidth;
}
if (me.usesHeight) {
++ownerContext.consumersHeight;
}
if (ownerCtContext && !ownerCtContext.hasRawContent) {
ownerLayout = owner.ownerLayout;
if (ownerLayout.usesWidth) {
++ownerContext.consumersWidth;
}
if (ownerLayout.usesHeight) {
++ownerContext.consumersHeight;
}
}
}
if (widthModel.configured) {
widthName = widthModel.names.width;
if (!body) {
dirty = me.setWidthInDom ||
(firstCycle ? owner[widthName] !== lastSize.width : widthModel.constrained);
}
ownerContext.setWidth(owner[widthName], dirty);
} else if (ownerContext.isTopLevel) {
if (widthModel.calculated) {
v = lastBox.width;
ownerContext.setWidth(v, v != lastSize.width);
}
v = lastBox.x;
ownerContext.setProp('x', v, v != lastSize.x);
}
if (heightModel.configured) {
heightName = heightModel.names.height;
if (!body) {
dirty = firstCycle ? owner[heightName] !== lastSize.height
: heightModel.constrained;
}
ownerContext.setHeight(owner[heightName], dirty);
} else if (ownerContext.isTopLevel) {
if (heightModel.calculated) {
v = lastBox.height;
ownerContext.setHeight(v, v != lastSize.height);
}
v = lastBox.y;
ownerContext.setProp('y', v, v != lastSize.y);
}
},
finishedLayout: function(ownerContext) {
var me = this,
elementChildren = ownerContext.children,
owner = me.owner,
len, i, elContext, lastBox, props;
if (elementChildren) {
len = elementChildren.length;
for (i = 0; i < len; i++) {
elContext = elementChildren[i];
elContext.el.lastBox = elContext.props;
}
}
ownerContext.previousSize = me.lastComponentSize;
me.lastComponentSize = owner.el.lastBox = props = ownerContext.props;
lastBox = owner.lastBox || (owner.lastBox = {});
lastBox.x = props.x;
lastBox.y = props.y;
lastBox.width = props.width;
lastBox.height = props.height;
lastBox.invalid = false;
me.callParent(arguments);
},
notifyOwner: function(ownerContext) {
var me = this,
currentSize = me.lastComponentSize,
prevSize = ownerContext.previousSize,
args = [currentSize.width, currentSize.height];
if (prevSize) {
args.push(prevSize.width, prevSize.height);
}
me.owner.afterComponentLayout.apply(me.owner, args);
},
getTarget : function() {
return this.owner.el;
},
getRenderTarget : function() {
return this.owner.el;
},
cacheTargetInfo: function(ownerContext) {
var me = this,
targetInfo = me.targetInfo,
target;
if (!targetInfo) {
target = ownerContext.getEl('getTarget', me);
me.targetInfo = targetInfo = {
padding: target.getPaddingInfo(),
border: target.getBorderInfo()
};
}
return targetInfo;
},
measureAutoDimensions: function (ownerContext, dimensions) {
var me = this,
owner = me.owner,
containerLayout = owner.layout,
heightModel = ownerContext.heightModel,
widthModel = ownerContext.widthModel,
boxParent = ownerContext.boxParent,
isBoxParent = ownerContext.isBoxParent,
props = ownerContext.props,
isContainer,
ret = {
gotWidth: false,
gotHeight: false,
isContainer: (isContainer = !ownerContext.hasRawContent)
},
hv = dimensions || 3,
zeroWidth, zeroHeight,
needed = 0,
got = 0,
ready, size, temp;
if (widthModel.shrinkWrap && ownerContext.consumersContentWidth) {
++needed;
zeroWidth = !(hv & 1);
if (isContainer) {
if (zeroWidth) {
ret.contentWidth = 0;
ret.gotWidth = true;
++got;
} else if ((ret.contentWidth = ownerContext.getProp('contentWidth')) !== undefined) {
ret.gotWidth = true;
++got;
}
} else {
size = props.contentWidth;
if (typeof size == 'number') { 
ret.contentWidth = size;
ret.gotWidth = true;
++got;
} else {
if (zeroWidth) {
ready = true;
} else if (!ownerContext.hasDomProp('containerChildrenSizeDone')) {
ready = false;
} else if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) {
ready = true;
} else {
ready = boxParent.hasDomProp('width');
}
if (ready) {
if (zeroWidth) {
temp = 0;
} else if (containerLayout && containerLayout.measureContentWidth) {
temp = containerLayout.measureContentWidth(ownerContext);
} else {
temp = me.measureContentWidth(ownerContext);
}
if (!isNaN(ret.contentWidth = temp)) {
ownerContext.setContentWidth(temp, true);
ret.gotWidth = true;
++got;
}
}
}
}
} else if (widthModel.natural && ownerContext.consumersWidth) {
++needed;
size = props.width;
if (typeof size == 'number') { 
ret.width = size;
ret.gotWidth = true;
++got;
} else {
if (isBoxParent || !boxParent) {
ready = true;
} else {
ready = boxParent.hasDomProp('width');
}
if (ready) {
if (!isNaN(ret.width = me.measureOwnerWidth(ownerContext))) {
ownerContext.setWidth(ret.width, false);
ret.gotWidth = true;
++got;
}
}
}
}
if (heightModel.shrinkWrap && ownerContext.consumersContentHeight) {
++needed;
zeroHeight = !(hv & 2);
if (isContainer) {
if (zeroHeight) {
ret.contentHeight = 0;
ret.gotHeight = true;
++got;
} else if ((ret.contentHeight = ownerContext.getProp('contentHeight')) !== undefined) {
ret.gotHeight = true;
++got;
}
} else {
size = props.contentHeight;
if (typeof size == 'number') { 
ret.contentHeight = size;
ret.gotHeight = true;
++got;
} else {
if (zeroHeight) {
ready = true;
} else if (!ownerContext.hasDomProp('containerChildrenSizeDone')) {
ready = false;
} else if (owner.noWrap) {
ready = true;
} else if (!widthModel.shrinkWrap) {
ready = (ownerContext.bodyContext || ownerContext).hasDomProp('width');
} else if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) {
ready = true;
} else {
ready = boxParent.hasDomProp('width');
}
if (ready) {
if (zeroHeight) {
temp = 0;
} else if (containerLayout && containerLayout.measureContentHeight) {
temp = containerLayout.measureContentHeight(ownerContext);
} else {
temp = me.measureContentHeight(ownerContext);
}
if (!isNaN(ret.contentHeight = temp)) {
ownerContext.setContentHeight(temp, true);
ret.gotHeight = true;
++got;
}
}
}
}
} else if (heightModel.natural && ownerContext.consumersHeight) {
++needed;
size = props.height;
if (typeof size == 'number') { 
ret.height = size;
ret.gotHeight = true;
++got;
} else {
if (isBoxParent || !boxParent) {
ready = true;
} else {
ready = boxParent.hasDomProp('width');
}
if (ready) {
if (!isNaN(ret.height = me.measureOwnerHeight(ownerContext))) {
ownerContext.setHeight(ret.height, false);
ret.gotHeight = true;
++got;
}
}
}
}
if (boxParent) {
ownerContext.onBoxMeasured();
}
ret.gotAll = got == needed;
return ret;
},
measureContentWidth: function (ownerContext) {
return ownerContext.el.getWidth() - ownerContext.getFrameInfo().width;
},
measureContentHeight: function (ownerContext) {
return ownerContext.el.getHeight() - ownerContext.getFrameInfo().height;
},
measureOwnerHeight: function (ownerContext) {
return ownerContext.el.getHeight();
},
measureOwnerWidth: function (ownerContext) {
return ownerContext.el.getWidth();
}
});
Ext.define('Ext.layout.component.Auto', {
alias: 'layout.autocomponent',
extend:  Ext.layout.component.Component ,
type: 'autocomponent',
setHeightInDom: false,
setWidthInDom: false,
waitForOuterHeightInDom: false,
waitForOuterWidthInDom: false,
beginLayoutCycle: function(ownerContext, firstCycle){
var me = this,
lastWidthModel = me.lastWidthModel,
lastHeightModel = me.lastHeightModel,
el = me.owner.el;
me.callParent(arguments);
if (lastWidthModel && lastWidthModel.fixed && ownerContext.widthModel.shrinkWrap) {
el.setWidth(null);
}
if (lastHeightModel && lastHeightModel.fixed && ownerContext.heightModel.shrinkWrap) {
el.setHeight(null);
}    
},
calculate: function(ownerContext) {
var me = this,
measurement = me.measureAutoDimensions(ownerContext),
heightModel = ownerContext.heightModel,
widthModel = ownerContext.widthModel,
width, height;
if (measurement.gotWidth) {
if (widthModel.shrinkWrap) {
me.publishOwnerWidth(ownerContext, measurement.contentWidth);
} else if (me.publishInnerWidth) {
me.publishInnerWidth(ownerContext, measurement.width);
}
} else if (!widthModel.auto && me.publishInnerWidth) {
width = me.waitForOuterWidthInDom ? ownerContext.getDomProp('width')
: ownerContext.getProp('width');
if (width === undefined) {
me.done = false;
} else {
me.publishInnerWidth(ownerContext, width);
}
}
if (measurement.gotHeight) {
if (heightModel.shrinkWrap) {
me.publishOwnerHeight(ownerContext, measurement.contentHeight);
} else if (me.publishInnerHeight) {
me.publishInnerHeight(ownerContext, measurement.height);
}
} else if (!heightModel.auto && me.publishInnerHeight) {
height = me.waitForOuterHeightInDom ? ownerContext.getDomProp('height')
: ownerContext.getProp('height');
if (height === undefined) {
me.done = false;
} else {
me.publishInnerHeight(ownerContext, height);
}
}
if (!measurement.gotAll) {
me.done = false;
}
},
calculateOwnerHeightFromContentHeight: function (ownerContext, contentHeight) {
return contentHeight + ownerContext.getFrameInfo().height;
},
calculateOwnerWidthFromContentWidth: function (ownerContext, contentWidth) {
return contentWidth + ownerContext.getFrameInfo().width;
},
publishOwnerHeight: function (ownerContext, contentHeight) {
var me = this,
owner = me.owner,
height = me.calculateOwnerHeightFromContentHeight(ownerContext, contentHeight),
constrainedHeight, dirty, heightModel;
if (isNaN(height)) {
me.done = false;
} else {
constrainedHeight = Ext.Number.constrain(height, owner.minHeight, owner.maxHeight);
if (constrainedHeight == height) {
dirty = me.setHeightInDom;
} else {
heightModel = me.sizeModels[
(constrainedHeight < height) ? 'constrainedMax' : 'constrainedMin'];
height = constrainedHeight;
if (ownerContext.heightModel.calculatedFromShrinkWrap) {
ownerContext.heightModel = heightModel;
} else {
ownerContext.invalidate({ heightModel: heightModel });
}
}
ownerContext.setHeight(height, dirty);
}
},
publishOwnerWidth: function (ownerContext, contentWidth) {
var me = this,
owner = me.owner,
width = me.calculateOwnerWidthFromContentWidth(ownerContext, contentWidth),
constrainedWidth, dirty, widthModel;
if (isNaN(width)) {
me.done = false;
} else {
constrainedWidth = Ext.Number.constrain(width, owner.minWidth, owner.maxWidth);
if (constrainedWidth == width) {
dirty = me.setWidthInDom;
} else {
widthModel = me.sizeModels[
(constrainedWidth < width) ? 'constrainedMax' : 'constrainedMin'];
width = constrainedWidth;
if (ownerContext.widthModel.calculatedFromShrinkWrap) {
ownerContext.widthModel = widthModel;
} else {
ownerContext.invalidate({ widthModel: widthModel });
}
}
ownerContext.setWidth(width, dirty);
}
}
});
Ext.define('Ext.container.AbstractContainer', {
extend:  Ext.Component ,
mixins: {
queryable:  Ext.Queryable 
},
renderTpl: '{%this.renderContainer(out,values)%}',
suspendLayout : false,
autoDestroy : true,
defaultType: 'panel',
detachOnRemove: true,
isContainer : true,
layoutCounter : 0,
baseCls: Ext.baseCSSPrefix + 'container',
defaultLayoutType: 'auto',
ariaRole: 'presentation',
initComponent : function(){
var me = this;
me.addEvents(
'afterlayout',
'beforeadd',
'beforeremove',
'add',
'remove'
);
me.callParent();
me.getLayout();
me.initItems();
},
initItems : function() {
var me = this,
items = me.items;
me.items = new Ext.util.AbstractMixedCollection(false, me.getComponentId);
me.floatingItems = new Ext.util.MixedCollection(false, me.getComponentId);
if (items) {
if (!Ext.isArray(items)) {
items = [items];
}
me.add(items);
}
},
getFocusEl: function() {
return this.getTargetEl();
},
finishRenderChildren: function () {
this.callParent();
var layout = this.getLayout();
if (layout) {
layout.finishRender();
}
},
beforeRender: function () {
var me = this,
layout = me.getLayout(),
targetCls;
me.callParent();
if (!layout.initialized) {
layout.initLayout();
}
targetCls = layout.targetCls;
if (targetCls) {
me.applyTargetCls(targetCls);
}
},
applyTargetCls: function(targetCls) {
this.addCls(targetCls);
},
afterComponentLayout: function() {
var floaters = this.floatingItems.items,
floaterCount = floaters.length,
i, floater
this.callParent(arguments);
for (i = 0; i < floaterCount; i++) {
floater = floaters[i];
if (!floater.rendered && floater.autoShow) {
floater.show();
}
}
},
onPosition: function() {
this.callParent(arguments);
this.repositionFloatingItems();
},
onResize: function() {
this.callParent(arguments);
this.repositionFloatingItems();
},
repositionFloatingItems: function() {
var floaters = this.floatingItems.items,
floaterCount = floaters.length,
i, floater;
for (i = 0; i < floaterCount; i++) {
floater = floaters[i];
if (floater.el && !floater.hidden) {
floater.setPosition(floater.x, floater.y);
}
}
},
setupRenderTpl: function (renderTpl) {
this.callParent(arguments);
this.getLayout().setupRenderTpl(renderTpl);
},
getDefaultContentTarget: function() {
return this.el;
},
getContentTarget: function(){
return this.getLayout().getContentTarget();
},
setLayout : function(layout) {
var currentLayout = this.layout;
if (currentLayout && currentLayout.isLayout && currentLayout != layout) {
currentLayout.setOwner(null);
}
this.layout = layout;
layout.setOwner(this);
},
getLayout : function() {
var me = this;
if (!me.layout || !me.layout.isLayout) {
me.setLayout(Ext.layout.Layout.create(me.layout, me.self.prototype.layout || me.defaultLayoutType));
}
return me.layout;
},
doLayout : function() {
this.updateLayout();
return this;
},
afterLayout : function(layout) {
var me = this;
++me.layoutCounter;
if (me.hasListeners.afterlayout) {
me.fireEvent('afterlayout', me, layout);
}
},
prepareItems : function(items, applyDefaults) {
if (Ext.isArray(items)) {
items = items.slice();
} else {
items = [items];
}
var me = this,
i = 0,
len = items.length,
item;
for (; i < len; i++) {
item = items[i];
if (item == null) {
Ext.Array.erase(items, i, 1);
--i;
--len;
} else {
if (applyDefaults) {
item = this.applyDefaults(item);
}
item.isContained = me;
items[i] = me.lookupComponent(item);
delete item.isContained;
delete items[i].isContained;
}
}
return items;
},
applyDefaults : function(config) {
var defaults = this.defaults;
if (defaults) {
if (Ext.isFunction(defaults)) {
defaults = defaults.call(this, config);
}
if (Ext.isString(config)) {
config = Ext.ComponentManager.get(config);
}
Ext.applyIf(config, defaults);
}
return config;
},
lookupComponent : function(comp) {
return (typeof comp == 'string') ? Ext.ComponentManager.get(comp)
: Ext.ComponentManager.create(comp, this.defaultType);
},
getComponentId : function(comp) {
return comp.getItemId && comp.getItemId();
},
add : function() {
var me = this,
args = Ext.Array.slice(arguments),
index = (typeof args[0] == 'number') ? args.shift() : -1,
layout = me.getLayout(),
addingArray, items, i, length, item, pos, ret,
needsLayout = false;
if (args.length == 1 && Ext.isArray(args[0])) {
items = args[0];
addingArray = true;
} else {
items = args;
}
if (me.rendered) {
Ext.suspendLayouts(); 
}
ret = items = me.prepareItems(items, true);
length = items.length;
if (!addingArray && length == 1) { 
ret = items[0];
}
for (i = 0; i < length; i++) {
item = items[i];
pos = (index < 0) ? me.items.length : (index + i);
if (item.floating) {
me.floatingItems.add(item);
item.onAdded(me, pos);
if (me.hasListeners.add) {
me.fireEvent('add', me, item, pos);
}
} else if ((!me.hasListeners.beforeadd || me.fireEvent('beforeadd', me, item, pos) !== false) && me.onBeforeAdd(item) !== false) {
me.items.insert(pos, item);
item.onAdded(me, pos);
me.onAdd(item, pos);
layout.onAdd(item, pos);
needsLayout = true;
if (me.hasListeners.add) {
me.fireEvent('add', me, item, pos);
}
}
}
if (needsLayout) {
me.updateLayout();
}
if (me.rendered) {
Ext.resumeLayouts(true);
}
return ret;
},
onAdd : Ext.emptyFn,
onRemove : Ext.emptyFn,
insert : function(index, comp) {
var compIdx;
if (comp && comp.isComponent) {
compIdx = this.items.indexOf(comp);
if (compIdx !== -1) {
return this.move(compIdx, index);
}
}
return this.add(index, comp);
},
move : function(fromIdx, toIdx) {
var items = this.items,
item;
if (fromIdx.isComponent) {
fromIdx = items.indexOf(fromIdx);
}
item = items.removeAt(fromIdx);
if (item === false) {
return false;
}
items.insert(toIdx, item);
this.onMove(item, fromIdx, toIdx);
this.updateLayout();
return item;
},
onMove: Ext.emptyFn,
onBeforeAdd : function(item) {
if (item.ownerCt && item.ownerCt !== this) {
item.ownerCt.remove(item, false);
}
},
remove : function(comp, autoDestroy) {
var me = this,
c = me.getComponent(comp);
if (c && (!me.hasListeners.beforeremove || me.fireEvent('beforeremove', me, c) !== false)) {
me.doRemove(c, autoDestroy);
if (me.hasListeners.remove) {
me.fireEvent('remove', me, c);
}
if (!me.destroying && !c.floating) {
me.updateLayout();
}
}
return c;
},
doRemove : function(component, doDestroy) {
doDestroy = doDestroy === true || (doDestroy !== false && this.autoDestroy);
var me = this,
layout = me.layout,
hasLayout = layout && me.rendered,
isDestroying = component.destroying || doDestroy,
floating = component.floating;
if (floating) {
me.floatingItems.remove(component);
} else {
me.items.remove(component);
}
if (hasLayout && !floating) {
if (layout.running) {
Ext.AbstractComponent.cancelLayout(component, isDestroying);
}
layout.onRemove(component, isDestroying);
}
component.onRemoved(isDestroying);
me.onRemove(component, isDestroying);
if (doDestroy) {
component.destroy();
}
else {
if (hasLayout && !floating) {
layout.afterRemove(component);
}
if (me.detachOnRemove && component.rendered) {
me.detachComponent(component);
}
}
},
detachComponent: function(component){
Ext.getDetachedBody().appendChild(component.getEl());
},
removeAll : function(autoDestroy) {
var me = this,
removeItems = me.items.items.slice().concat(me.floatingItems.items),
items = [],
i = 0,
len = removeItems.length,
item;
me.suspendLayouts();
for (; i < len; i++) {
item = removeItems[i];
me.remove(item, autoDestroy);
if (item.ownerCt !== me) {
items.push(item);
}
}
me.resumeLayouts(!!len);
return items;
},
getRefItems : function(deep) {
var me = this,
items = me.items.items,
len = items.length,
i = 0,
item,
result = [];
for (; i < len; i++) {
item = items[i];
result[result.length] = item;
if (deep && item.getRefItems) {
result.push.apply(result, item.getRefItems(true));
}
}
items = me.floatingItems.items;
len = items.length;
for (i = 0; i < len; i++) {
item = items[i];
result[result.length] = item;
if (deep && item.getRefItems) {
result.push.apply(result, item.getRefItems(true));
}
}
return result;
},
cascade : function(fn, scope, origArgs){
var me = this,
cs = me.items ? me.items.items : [],
len = cs.length,
i = 0,
c,
args = origArgs ? origArgs.concat(me) : [me],
componentIndex = args.length - 1;
if (fn.apply(scope || me, args) !== false) {
for (; i < len; i++){
c = cs[i];
if (c.cascade) {
c.cascade(fn, scope, origArgs);
} else {
args[componentIndex] = c;
fn.apply(scope || cs, args);
}
}
}
return this;
},
isAncestor: function(possibleDescendant) {
while (possibleDescendant) {
if (possibleDescendant.ownerCt === this) {
return true;
}
possibleDescendant = possibleDescendant.ownerCt;
}
},
getComponent : function(comp) {
if (Ext.isObject(comp)) {
comp = comp.getItemId();
}
var c = this.items.get(comp);
if (!c && typeof comp != 'number') {
c = this.floatingItems.get(comp);
}
return c;
},
contains: function(comp, deep) {
var result = false;
if (deep) {
this.cascade(function(c) {
if (c.contains && c.contains(comp)) {
result = true;
return false;
}
});
return result;
} else {
return this.items.contains(comp) || this.floatingItems.contains(comp);
}
},
nextChild: function(child, selector) {
var me = this,
result,
childIndex = me.items.indexOf(child);
if (childIndex !== -1) {
result = selector ? Ext.ComponentQuery(selector, me.items.items.slice(childIndex + 1)) : me.items.getAt(childIndex + 1);
if (!result && me.ownerCt) {
result = me.ownerCt.nextChild(me, selector);
}
}
return result;
},
prevChild: function(child, selector) {
var me = this,
result,
childIndex = me.items.indexOf(child);
if (childIndex !== -1) {
result = selector ? Ext.ComponentQuery(selector, me.items.items.slice(childIndex + 1)) : me.items.getAt(childIndex + 1);
if (!result && me.ownerCt) {
result = me.ownerCt.nextChild(me, selector);
}
}
return result;
},
enable: function() {
this.callParent(arguments);
var itemsToDisable = this.getChildItemsToDisable(),
length         = itemsToDisable.length,
item, i;
for (i = 0; i < length; i++) {
item = itemsToDisable[i];
if (item.resetDisable) {
item.enable();
}
}
return this;
},
disable: function() {
this.callParent(arguments);
var itemsToDisable = this.getChildItemsToDisable(),
length         = itemsToDisable.length,
item, i;
for (i = 0; i < length; i++) {
item = itemsToDisable[i];
if (item.resetDisable !== false && !item.disabled) {
item.disable();
item.resetDisable = true;
}
}
return this;
},
getChildItemsToDisable: function(){
return this.query('[isFormField],button');
},
beforeDestroy : function() {
var me = this,
items = me.items,
floatingItems = me.floatingItems,
c;
if (items) {
while ((c = items.first())) {
me.doRemove(c, true);
}
}
if (floatingItems) {
while ((c = floatingItems.first())) {
me.doRemove(c, true);
}
}
Ext.destroy(
me.layout
);
me.callParent();
}
});
Ext.define('Ext.container.Container', {
extend:  Ext.container.AbstractContainer ,
alias: 'widget.container',
alternateClassName: 'Ext.Container',
getChildByElement: function(el, deep) {
var item,
itemEl,
i = 0,
it = this.getRefItems(),
ln = it.length;
el = Ext.getDom(el);
for (; i < ln; i++) {
item = it[i];
itemEl = item.getEl();
if (itemEl && ((itemEl.dom === el) || itemEl.contains(el))) {
return (deep && item.getChildByElement) ? item.getChildByElement(el, deep) : item;
}
}
return null;
}
});
Ext.define('Ext.util.KeyMap', {
alternateClassName: 'Ext.KeyMap',
eventName: 'keydown',
constructor: function(config) {
var me = this;
if ((arguments.length !== 1) || (typeof config === 'string') || config.dom || config.tagName || config === document || config.isComponent) {
me.legacyConstructor.apply(me, arguments);
return;
}
Ext.apply(me, config);
me.bindings = [];
if (!me.target.isComponent) {
me.target = Ext.get(me.target);
}
if (me.binding) {
me.addBinding(me.binding);
} else if (config.key) {
me.addBinding(config);
}
me.enable();
},
legacyConstructor: function(el, binding, eventName){
var me = this;
Ext.apply(me, {
target: Ext.get(el),
eventName: eventName || me.eventName,
bindings: []
});
if (binding) {
me.addBinding(binding);
}
me.enable();
},
addBinding : function(binding){
var me = this,
keyCode = binding.key,
i,
len;
if (me.processing) {
me.bindings = bindings.slice(0);
}
if (Ext.isArray(binding)) {
for (i = 0, len = binding.length; i < len; i++) {
me.addBinding(binding[i]);
}
return;
}
me.bindings.push(Ext.apply({
keyCode: me.processKeys(keyCode)
}, binding));
},
removeBinding: function(binding){
var me = this,
bindings = me.bindings,
len = bindings.length,
i, item, keys;
if (me.processing) {
me.bindings = bindings.slice(0);
}
keys = me.processKeys(binding.key);
for (i = 0; i < len; ++i) {
item = bindings[i];
if (item.fn === binding.fn && item.scope === binding.scope) {
if (binding.alt == item.alt && binding.crtl == item.crtl && binding.shift == item.shift) {
if (Ext.Array.equals(item.keyCode, keys)) {
Ext.Array.erase(me.bindings, i, 1);
return;
}
}
}
}
},
processKeys: function(keyCode){
var processed = false,
key, keys, keyString, len, i;
if (Ext.isString(keyCode)) {
keys = [];
keyString = keyCode.toUpperCase();
for (i = 0, len = keyString.length; i < len; ++i){
keys.push(keyString.charCodeAt(i));
}
keyCode = keys;
processed = true;
}
if (!Ext.isArray(keyCode)) {
keyCode = [keyCode];
}
if (!processed) {
for (i = 0, len = keyCode.length; i < len; ++i) {
key = keyCode[i];
if (Ext.isString(key)) {
keyCode[i] = key.toUpperCase().charCodeAt(0);
}
}
}
return keyCode;
},
handleTargetEvent: (function() {
var tagRe = /input|textarea/i;
return function(event) {
var me = this,
bindings, i, len,
target, contentEditable;
if (me.enabled) { 
bindings = me.bindings;
i = 0;
len = bindings.length;
event = me.processEvent.apply(me||me.processEventScope, arguments);
if (me.ignoreInputFields) {
target = event.target;
contentEditable = target.contentEditable;
if (tagRe.test(target.tagName) || (contentEditable === '' || contentEditable === 'true')) {
return;
}
}
if (!event.getKey) {
return event;
}
me.processing = true;
for(; i < len; ++i){
me.processBinding(bindings[i], event);
}
me.processing = false;
}
}
}()),
processEvent: Ext.identityFn,
processBinding: function(binding, event){
if (this.checkModifiers(binding, event)) {
var key = event.getKey(),
handler = binding.fn || binding.handler,
scope = binding.scope || this,
keyCode = binding.keyCode,
defaultEventAction = binding.defaultEventAction,
i,
len,
keydownEvent = new Ext.EventObjectImpl(event);
for (i = 0, len = keyCode.length; i < len; ++i) {
if (key === keyCode[i]) {
if (handler.call(scope, key, event) !== true && defaultEventAction) {
keydownEvent[defaultEventAction]();
}
break;
}
}
}
},
checkModifiers: function(binding, e) {
var keys = ['shift', 'ctrl', 'alt'],
i = 0,
len = keys.length,
val, key;
for (; i < len; ++i){
key = keys[i];
val = binding[key];
if (!(val === undefined || (val === e[key + 'Key']))) {
return false;
}
}
return true;
},
on: function(key, fn, scope) {
var keyCode, shift, ctrl, alt;
if (Ext.isObject(key) && !Ext.isArray(key)) {
keyCode = key.key;
shift = key.shift;
ctrl = key.ctrl;
alt = key.alt;
} else {
keyCode = key;
}
this.addBinding({
key: keyCode,
shift: shift,
ctrl: ctrl,
alt: alt,
fn: fn,
scope: scope
});
},
un: function(key, fn, scope) {
var keyCode, shift, ctrl, alt;
if (Ext.isObject(key) && !Ext.isArray(key)) {
keyCode = key.key;
shift = key.shift;
ctrl = key.ctrl;
alt = key.alt;
} else {
keyCode = key;
}
this.removeBinding({
key: keyCode,
shift: shift,
ctrl: ctrl,
alt: alt,
fn: fn,
scope: scope
});
},
isEnabled : function() {
return this.enabled;
},
enable: function() {
var me = this;
if (!me.enabled) {
me.target.on(me.eventName, me.handleTargetEvent, me);
me.enabled = true;
}
},
disable: function() {
var me = this;
if (me.enabled) {
me.target.removeListener(me.eventName, me.handleTargetEvent, me);
me.enabled = false;
}
},
setDisabled : function(disabled) {
if (disabled) {
this.disable();
} else {
this.enable();
}
},
destroy: function(removeTarget) {
var me = this,
target = me.target;
me.bindings = [];
me.disable();
if (removeTarget === true) {
if (target.isComponent) {
target.destroy();
} else {
target.remove();
}
}
delete me.target;
}
});
Ext.define('Ext.util.KeyNav', {
alternateClassName: 'Ext.KeyNav',
statics: {
keyOptions: {
left: 37,
right: 39,
up: 38,
down: 40,
space: 32,
pageUp: 33,
pageDown: 34,
del: 46,
backspace: 8,
home: 36,
end: 35,
enter: 13,
esc: 27,
tab: 9
}
},
constructor: function(config) {
var me = this;
if (arguments.length === 2) {
me.legacyConstructor.apply(me, arguments);
return;
}
me.setConfig(config);
},
legacyConstructor: function(el, config) {
this.setConfig(Ext.apply({
target: el
}, config));
},
setConfig: function(config) {
var me = this,
keymapCfg = {
target: config.target,
ignoreInputFields: config.ignoreInputFields,
eventName: me.getKeyEvent('forceKeyDown' in config ? config.forceKeyDown : me.forceKeyDown, config.eventName)
},
map, keyCodes, defaultScope, keyName, binding;
if (me.map) {
me.map.destroy();
}
if (config.processEvent) {
keymapCfg.processEvent = config.processEvent;
keymapCfg.processEventScope = config.processEventScope||me;
}
if (config.keyMap) {
map = me.map = config.keyMap;
}
else {
map = me.map = new Ext.util.KeyMap(keymapCfg);
me.destroyKeyMap = true;
}
keyCodes = Ext.util.KeyNav.keyOptions;
defaultScope = config.scope || me;
for (keyName in keyCodes) {
if (keyCodes.hasOwnProperty(keyName)) {
if (binding = config[keyName]) {
if (typeof binding === 'function') {
binding = {
handler: binding,
defaultEventAction: (config.defaultEventAction !== undefined) ? config.defaultEventAction : me.defaultEventAction
};
}
map.addBinding({
key: keyCodes[keyName],
handler: Ext.Function.bind(me.handleEvent, binding.scope||defaultScope, binding.handler||binding.fn, true),
defaultEventAction: (binding.defaultEventAction !== undefined) ? binding.defaultEventAction : me.defaultEventAction
});
}
}
}
map.disable();
if (!config.disabled) {
map.enable();
}
},
handleEvent: function(keyCode, event, handler){
return handler.call(this, event);
},
disabled: false,
defaultEventAction: "stopEvent",
forceKeyDown: false,
eventName: 'keypress',
destroy: function(removeEl) {
if (this.destroyKeyMap) {
this.map.destroy(removeEl);
}
delete this.map;
},
enable: function() {
if (this.map) {
this.map.enable();
this.disabled = false;
}
},
disable: function() {
if (this.map) {
this.map.disable();
}
this.disabled = true;
},
setDisabled : function(disabled) {
this.map.setDisabled(disabled);
this.disabled = disabled;
},
getKeyEvent: function(forceKeyDown, configuredEventName) {
if (forceKeyDown || (Ext.EventManager.useKeyDown && !configuredEventName)) {
return 'keydown';
} else {
return configuredEventName||this.eventName;
}
}
});
Ext.define('Ext.FocusManager', {
singleton: true,
alternateClassName: ['Ext.FocusMgr' ],
mixins: {
observable:  Ext.util.Observable 
},
enabled: false,
focusElementCls: Ext.baseCSSPrefix + 'focus-element',
focusFrameCls: Ext.baseCSSPrefix + 'focus-frame',
whitelist: [
'textfield'
],
constructor: function(config) {
var me = this,
CQ = Ext.ComponentQuery;
me.mixins.observable.constructor.call(me, config);
me.addEvents(
'beforecomponentfocus',
'componentfocus',
'disable',
'enable'
);
me.focusTask = new Ext.util.DelayedTask(me.handleComponentFocus, me);
Ext.override(Ext.AbstractComponent, {
onFocus: function() {
this.callParent(arguments);
if (me.enabled && this.hasFocus) {
Array.prototype.unshift.call(arguments, this);
me.onComponentFocus.apply(me, arguments);
}
},
onBlur: function() {
this.callParent(arguments);
if (me.enabled && !this.hasFocus) {
Array.prototype.unshift.call(arguments, this);
me.onComponentBlur.apply(me, arguments);
}
},
onDestroy: function() {
this.callParent(arguments);
if (me.enabled) {
Array.prototype.unshift.call(arguments, this);
me.onComponentDestroy.apply(me, arguments);
}
}
});
Ext.override(Ext.Component, {
afterHide: function() {
this.callParent(arguments);
if (me.enabled) {
Array.prototype.unshift.call(arguments, this);
me.onComponentHide.apply(me, arguments);
}
}
});
me.keyNav = new Ext.util.KeyNav(Ext.getDoc(), {
disabled: true,
scope: me,
backspace: me.focusLast,
enter: me.navigateIn,
esc: me.navigateOut,
tab: me.navigateSiblings,
space: me.navigateIn,
del: me.focusLast,
left: me.navigateSiblings,
right: me.navigateSiblings,
down: me.navigateSiblings,
up: me.navigateSiblings
});
me.focusData = {};
me.subscribers = new Ext.util.HashMap();
me.focusChain = {};
Ext.apply(CQ.pseudos, {
nextFocus: function(cmps, idx, step) {
step = step || 1;
idx = parseInt(idx, 10);
var len = cmps.length,
i = idx, c;
for (;;) {
if ((i += step) >= len) {
i = 0;
} else if (i < 0) {
i = len - 1;
}
if (i === idx) {
return [];
}
if ((c = cmps[i]).isFocusable()) {
return [c];
}
}
return [];
},
prevFocus: function(cmps, idx) {
return this.nextFocus(cmps, idx, -1);
},
root: function(cmps) {
var len = cmps.length,
results = [],
i = 0,
c;
for (; i < len; i++) {
c = cmps[i];
if (!c.ownerCt) {
results.push(c);
}
}
return results;
}
});
},
addXTypeToWhitelist: function(xtype) {
var me = this;
if (Ext.isArray(xtype)) {
Ext.Array.forEach(xtype, me.addXTypeToWhitelist, me);
return;
}
if (!Ext.Array.contains(me.whitelist, xtype)) {
me.whitelist.push(xtype);
}
},
clearComponent: function(cmp) {
clearTimeout(this.cmpFocusDelay);
if (!cmp.isDestroyed) {
cmp.blur();
}
},
disable: function() {
var me = this;
if (!me.enabled) {
return;
}
delete me.options;
me.enabled = false;
me.removeDOM();
me.keyNav.disable();
me.fireEvent('disable', me);
},
enable: function(options) {
var me = this;
if (options === true) {
options = { focusFrame: true };
}
me.options = options = options || {};
if (me.enabled) {
return;
}
me.enabled = true;
me.initDOM(options);
me.keyNav.enable();
me.focusEl.focus();
delete me.focusedCmp;
me.fireEvent('enable', me);
},
focusLast: function(e) {
var me = this;
if (me.isWhitelisted(me.focusedCmp)) {
return true;
}
if (me.previousFocusedCmp) {
me.previousFocusedCmp.focus();
}
},
getRootComponents: function() {
var CQ = Ext.ComponentQuery,
inline = CQ.query(':focusable:root:not([floating])'),
floating = CQ.query(':focusable:root[floating]');
floating.sort(function(a, b) {
return a.el.getZIndex() > b.el.getZIndex();
});
return floating.concat(inline);
},
initDOM: function(options) {
var me = this,
cls = me.focusFrameCls,
needListeners = Ext.ComponentQuery.query('{getFocusEl()}:not([focusListenerAdded])'),
i = 0, len = needListeners.length;
if (!Ext.isReady) {
return Ext.onReady(me.initDOM, me);
}
for (; i < len; i++) {
needListeners[i].addFocusListener();
}
if (!me.focusEl) {
me.focusEl = Ext.getBody();
me.focusEl.dom.tabIndex = -1;
}
if (!me.focusFrame && options.focusFrame) {
me.focusFrame = Ext.getBody().createChild({
cls: cls,
children: [
{ cls: cls + '-top' },
{ cls: cls + '-bottom' },
{ cls: cls + '-left' },
{ cls: cls + '-right' }
],
style: 'top: -100px; left: -100px;'
});
me.focusFrame.setVisibilityMode(Ext.Element.DISPLAY);
me.focusFrame.hide().setLocalXY(0, 0);
}
},
isWhitelisted: function(cmp) {
return cmp && Ext.Array.some(this.whitelist, function(x) {
return cmp.isXType(x);
});
},
navigateIn: function(e) {
var me = this,
focusedCmp = me.focusedCmp,
defaultRoot,
firstChild;
if (me.isWhitelisted(focusedCmp)) {
return true;
}
if (!focusedCmp) {
defaultRoot = me.getRootComponents()[0];
if (defaultRoot) {
if (defaultRoot.getFocusEl() === me.focusEl) {
me.focusEl.blur();
}
defaultRoot.focus();
}
} else {
firstChild = focusedCmp.hasFocus ? Ext.ComponentQuery.query('>:focusable', focusedCmp)[0] : focusedCmp;
if (firstChild) {
firstChild.focus();
} else {
if (Ext.isFunction(focusedCmp.onClick)) {
e.button = 0;
focusedCmp.onClick(e);
if (focusedCmp.isVisible(true)) {
focusedCmp.focus();
} else {
me.navigateOut();
}
}
}
}
},
navigateOut: function(e) {
var me = this,
parent;
if (!me.focusedCmp || !(parent = me.focusedCmp.up(':focusable'))) {
me.focusEl.focus();
} else {
parent.focus();
}
return true;
},
navigateSiblings: function(e, source, parent) {
var me = this,
src = source || me,
key = e.getKey(),
EO = Ext.EventObject,
goBack = e.shiftKey || key == EO.LEFT || key == EO.UP,
checkWhitelist = key == EO.LEFT || key == EO.RIGHT || key == EO.UP || key == EO.DOWN,
nextSelector = goBack ? 'prev' : 'next',
idx, next, focusedCmp, siblings;
focusedCmp = (src.focusedCmp && src.focusedCmp.comp) || src.focusedCmp;
if (!focusedCmp && !parent) {
return true;
}
if (checkWhitelist && me.isWhitelisted(focusedCmp)) {
return true;
}
if (!focusedCmp || focusedCmp.is(':root')) {
siblings = me.getRootComponents();
} else {
parent = parent || focusedCmp.up();
if (parent) {
siblings = parent.getRefItems();
}
}
if (siblings) {
idx = focusedCmp ? Ext.Array.indexOf(siblings, focusedCmp) : -1;
next = Ext.ComponentQuery.query(':' + nextSelector + 'Focus(' + idx + ')', siblings)[0];
if (next && focusedCmp !== next) {
next.focus();
return next;
}
}
},
onComponentBlur: function(cmp, e) {
var me = this;
if (me.focusedCmp === cmp) {
me.previousFocusedCmp = cmp;
delete me.focusedCmp;
}
if (me.focusFrame) {
me.focusFrame.hide();
}
},
onComponentFocus: function(cmp, e) {
var me = this,
chain = me.focusChain,
parent;
if (!cmp.isFocusable()) {
me.clearComponent(cmp);
if (chain[cmp.id]) {
return;
}
parent = cmp.up();
if (parent) {
chain[cmp.id] = true;
parent.focus();
}
return;
}
me.focusChain = {};
me.focusTask.delay(10, null, null, [cmp, cmp.getFocusEl()]);
},
handleComponentFocus: function(cmp, focusEl) {
var me = this,
cls,
ff,
box,
bt,
bl,
bw,
bh,
ft,
fb,
fl,
fr;
if (me.fireEvent('beforecomponentfocus', me, cmp, me.previousFocusedCmp) === false) {
me.clearComponent(cmp);
return;
}
me.focusedCmp = cmp;
if (me.shouldShowFocusFrame(cmp)) {
cls = '.' + me.focusFrameCls + '-';
ff = me.focusFrame;
box = (focusEl.dom ? focusEl : focusEl.el).getBox();
bt = box.top;
bl = box.left;
bw = box.width;
bh = box.height;
ft = ff.child(cls + 'top');
fb = ff.child(cls + 'bottom');
fl = ff.child(cls + 'left');
fr = ff.child(cls + 'right');
ft.setWidth(bw).setLocalXY(bl, bt);
fb.setWidth(bw).setLocalXY(bl, bt + bh - 2);
fl.setHeight(bh - 2).setLocalXY(bl, bt + 2);
fr.setHeight(bh - 2).setLocalXY(bl + bw - 2, bt + 2);
ff.show();
}
me.fireEvent('componentfocus', me, cmp, me.previousFocusedCmp);
},
onComponentHide: function(cmp) {
var me = this,
cmpHadFocus = false,
focusedCmp = me.focusedCmp,
parent;
if (focusedCmp) {
cmpHadFocus = cmp.hasFocus || (cmp.isContainer && cmp.isAncestor(me.focusedCmp));
}
me.clearComponent(cmp);
if (cmpHadFocus && (parent = cmp.up(':focusable'))) {
parent.focus();
} else {
me.focusEl.focus();
}
},
onComponentDestroy: function() {
},
removeDOM: function() {
var me = this;
if (me.enabled || me.subscribers.length) {
return;
}
Ext.destroy(
me.focusFrame
);
delete me.focusEl;
delete me.focusFrame;
},
removeXTypeFromWhitelist: function(xtype) {
var me = this;
if (Ext.isArray(xtype)) {
Ext.Array.forEach(xtype, me.removeXTypeFromWhitelist, me);
return;
}
Ext.Array.remove(me.whitelist, xtype);
},
setupSubscriberKeys: function(container, keys) {
var me = this,
el = container.getFocusEl(),
scope = keys.scope,
handlers = {
backspace: me.focusLast,
enter: me.navigateIn,
esc: me.navigateOut,
scope: me
},
navSiblings = function(e) {
if (me.focusedCmp === container) {
return me.navigateSiblings(e, me, container);
} else {
return me.navigateSiblings(e);
}
};
Ext.iterate(keys, function(key, cb) {
handlers[key] = function(e) {
var ret = navSiblings(e);
if (Ext.isFunction(cb) && cb.call(scope || container, e, ret) === true) {
return true;
}
return ret;
};
}, me);
return new Ext.util.KeyNav(el, handlers);
},
shouldShowFocusFrame: function(cmp) {
var me = this,
opts = me.options || {};
if (!me.focusFrame || !cmp) {
return false;
}
if (opts.focusFrame) {
return true;
}
if (me.focusData[cmp.id].focusFrame) {
return true;
}
return false;
}
});
Ext.define('Ext.Img', {
extend:  Ext.Component ,
alias: ['widget.image', 'widget.imagecomponent'],
autoEl: 'img',
baseCls: Ext.baseCSSPrefix + 'img',
src: '',
alt: '',
title: '',
imgCls: '',
ariaRole: 'img',
initComponent: function() {
if (this.glyph) {
this.autoEl = 'div';
}
this.callParent();
},
getElConfig: function() {
var me = this,
autoEl = me.autoEl,
config = me.callParent(),
glyphFontFamily = Ext._glyphFontFamily,
glyph = me.glyph,
img, glyphParts;
if (autoEl === 'img' || (Ext.isObject(autoEl) && autoEl.tag === 'img')) {
img = config;
} else if (me.glyph) {
if (typeof glyph === 'string') {
glyphParts = glyph.split('@');
glyph = glyphParts[0];
glyphFontFamily = glyphParts[1];
}
config.html = '&#' + glyph + ';';
if (glyphFontFamily) {
config.style = 'font-family:' + glyphFontFamily;
}
} else {
config.cn = [img = {
tag: 'img',
role: me.ariaRole,
id: me.id + '-img'
}];
}
if (img) {
if (me.imgCls) {
img.cls = (img.cls ? img.cls + ' ' : '') + me.imgCls;
}
img.src = me.src || Ext.BLANK_IMAGE_URL;
}
if (me.alt) {
(img || config).alt = me.alt;
}
if (me.title) {
(img || config).title = me.title;
}
return config;
},
onRender: function () {
var me = this,
autoEl = me.autoEl,
el;
me.callParent(arguments);
el = me.el;
if (autoEl === 'img' || (Ext.isObject(autoEl) && autoEl.tag === 'img')) {
me.imgEl = el;
}
else {
me.imgEl = el.getById(me.id + '-img');
}
},
onDestroy: function () {
Ext.destroy(this.imgEl);
this.imgEl = null;
this.callParent();
},
setSrc: function(src) {
var me = this,
imgEl = me.imgEl;
me.src = src;
if (imgEl) {
imgEl.dom.src = src || Ext.BLANK_IMAGE_URL;
}
},
setGlyph: function(glyph) {
var me = this,
glyphFontFamily = Ext._glyphFontFamily,
glyphParts, dom;
if (glyph != me.glyph) {
if (typeof glyph === 'string') {
glyphParts = glyph.split('@');
glyph = glyphParts[0];
glyphFontFamily = glyphParts[1];
}
dom = me.el.dom;
dom.innerHTML = '&#' + glyph + ';';
if (glyphFontFamily) {
dom.style = 'font-family:' + glyphFontFamily;
}
}
}
});
Ext.define('Ext.util.Bindable', {
bindStore: function(store, initial, propertyName) {
propertyName = propertyName || 'store';
var me = this,
oldStore = me[propertyName];
if (!initial && oldStore) {
me.onUnbindStore(oldStore, initial, propertyName);
if (store !== oldStore && oldStore.autoDestroy) {
oldStore.destroyStore();
} else {
me.unbindStoreListeners(oldStore);
}
}
if (store) {
store = Ext.data.StoreManager.lookup(store);
me.bindStoreListeners(store);
me.onBindStore(store, initial, propertyName);
}
me[propertyName] = store || null;
return me;
},
getStore: function(){
return this.store;
},
unbindStoreListeners: function(store) {
var listeners = this.storeListeners;
if (listeners) {
store.un(listeners);
}
},
bindStoreListeners: function(store) {
var me = this,
listeners = Ext.apply({}, me.getStoreListeners(store));
if (!listeners.scope) {
listeners.scope = me;
}
me.storeListeners = listeners;
store.on(listeners);
},
getStoreListeners: Ext.emptyFn,
onUnbindStore: Ext.emptyFn,
onBindStore: Ext.emptyFn    
});
Ext.define('Ext.data.association.Association', {
alternateClassName: 'Ext.data.Association',
primaryKey: 'id',
associationKeyFunction : null,
defaultReaderType: 'json',
isAssociation: true,
initialConfig: null,
statics: {
AUTO_ID: 1000,
create: function(association){
if (Ext.isString(association)) {
association = {
type: association
};
}
switch (association.type) {
case 'belongsTo':
return new Ext.data.association.BelongsTo(association);
case 'hasMany':
return new Ext.data.association.HasMany(association);
case 'hasOne':
return new Ext.data.association.HasOne(association);
default:
}
return association;
}
},
constructor: function(config) {
Ext.apply(this, config);
var me              = this,
types           = Ext.ModelManager.types,
ownerName       = config.ownerModel,
associatedName  = config.associatedModel,
ownerModel      = types[ownerName],
associatedModel = types[associatedName],
associationKey  = config.associationKey,
keyReIdx;
if (associationKey) {
keyReIdx = String(associationKey).search(/[\[\.]/);
if (keyReIdx >= 0) {
me.associationKeyFunction = Ext.functionFactory('obj', 'return obj' + (keyReIdx > 0 ? '.' : '') + associationKey);
}
}
me.initialConfig = config;
me.ownerModel = ownerModel;
me.associatedModel = associatedModel;
Ext.applyIf(me, {
ownerName : ownerName,
associatedName: associatedName
});
me.associationId = 'association' + (++me.statics().AUTO_ID);
},
getReader: function(){
var me = this,
reader = me.reader,
model = me.associatedModel;
if (reader) {
if (Ext.isString(reader)) {
reader = {
type: reader
};
}
if (reader.isReader) {
reader.setModel(model);
} else {
Ext.applyIf(reader, {
model: model,
type : me.defaultReaderType
});
}
me.reader = Ext.createByAlias('reader.' + reader.type, reader);
}
return me.reader || null;
}
});
Ext.define('Ext.ModelManager', {
extend:  Ext.AbstractManager ,
alternateClassName: 'Ext.ModelMgr',
singleton: true,
typeName: 'mtype',
associationStack: [],
registerType: function(name, config) {
var proto = config.prototype,
model;
if (proto && proto.isModel) {
model = config;
} else {
if (!config.extend) {
config.extend = 'Ext.data.Model';
}
model = Ext.define(name, config);
}
this.types[name] = model;
return model;
},
unregisterType: function(name) {
delete this.types[name];
},
onModelDefined: function(model) {
var stack  = this.associationStack,
length = stack.length,
create = [],
association, i, created;
for (i = 0; i < length; i++) {
association = stack[i];
if (association.associatedModel == model.modelName) {
create.push(association);
}
}
for (i = 0, length = create.length; i < length; i++) {
created = create[i];
this.types[created.ownerModel].prototype.associations.add(Ext.data.association.Association.create(created));
Ext.Array.remove(stack, created);
}
},
registerDeferredAssociation: function(association){
this.associationStack.push(association);
},
getModel: function(id) {
var model = id;
if (typeof model == 'string') {
model = this.types[model];
}
return model;
},
create: function(config, name, id) {
var Con = typeof name == 'function' ? name : this.types[name || config.name];
return new Con(config, id);
}
}, function() {
Ext.regModel = function() {
return this.ModelManager.registerType.apply(this.ModelManager, arguments);
};
});
Ext.define('Ext.data.StoreManager', {
extend:  Ext.util.MixedCollection ,
alternateClassName: ['Ext.StoreMgr', 'Ext.data.StoreMgr', 'Ext.StoreManager'],
singleton: true,
register : function() {
for (var i = 0, s; (s = arguments[i]); i++) {
this.add(s);
}
},
unregister : function() {
for (var i = 0, s; (s = arguments[i]); i++) {
this.remove(this.lookup(s));
}
},
lookup : function(store) {
if ('string' == typeof store) {
return this.get(store);
}
if (Ext.isArray(store)) {
var fields = ['field1'], 
expand = !Ext.isArray(store[0]),
data = store,
i,
len;
if(expand){
data = [];
for (i = 0, len = store.length; i < len; ++i) {
data.push([store[i]]);
}
} else {
for(i = 2, len = store[0].length; i <= len; ++i){
fields.push('field' + i);
}
}
return new Ext.data.ArrayStore({
data  : data,
fields: fields,
autoDestroy: true,
autoCreated: true,
expanded: expand
});
} else {
return Ext.data.AbstractStore.create(store);
}
},
getKey : function(o) {
return o.storeId;
}
}, function() {    
Ext.regStore = function(name, config) {
var store;
if (Ext.isObject(name)) {
config = name;
} else {
config.storeId = name;
}
if (config instanceof Ext.data.Store) {
store = config;
} else {
store = new Ext.data.Store(config);
}
return Ext.data.StoreManager.register(store);
};
Ext.getStore = function(name) {
return Ext.data.StoreManager.lookup(name);
};
});
Ext.define('Ext.data.ResultSet', {
loaded: true,
count: 0,
total: 0,
success: false,
constructor: function(config) {
Ext.apply(this, config);
this.totalRecords = this.total;
if (config.count === undefined) {
this.count = this.records.length;
}
}
});
Ext.define('Ext.data.reader.Reader', {
alternateClassName: ['Ext.data.Reader', 'Ext.data.DataReader'],
mixins: {
observable:  Ext.util.Observable 
},
totalProperty: 'total',
successProperty: 'success',
root: '',
implicitIncludes: true,
readRecordsOnFailure: true,
isReader: true,
applyDefaults: true,
lastFieldGeneration: null,
constructor: function(config) {
var me = this;
me.mixins.observable.constructor.call(me, config);
me.model = Ext.ModelManager.getModel(me.model);
if (me.model && me.model.prototype.fields) {
me.buildExtractors();
}
this.addEvents(
'exception'
);
},
setModel: function(model, setOnProxy) {
var me = this,
oldModel = me.model,
force = true;
model = me.model = Ext.ModelManager.getModel(model);
if (model && oldModel === model) {
force = me.lastFieldGeneration !== model.prototype.fields.generation;
}
if (model) {
me.buildExtractors(force);
}
if (setOnProxy && me.proxy) {
me.proxy.setModel(model, true);
}
},
read: function(response) {
var data;
if (response) {
data = response.responseText ? this.getResponseData(response) : this.readRecords(response);
}
return data || this.nullResultSet;
},
readRecords: function(data) {
var me = this,
success,
recordCount,
records,
root,
total,
value,
message;
if (me.lastFieldGeneration !== me.model.prototype.fields.generation) {
me.buildExtractors(true);
}
me.rawData = data;
data = me.getData(data);
success = true;
recordCount = 0;
records = [];
if (me.successProperty) {
value = me.getSuccess(data);
if (value === false || value === 'false') {
success = false;
}
}
if (me.messageProperty) {
message = me.getMessage(data);
}
if (me.readRecordsOnFailure || success) {
root = Ext.isArray(data) ? data : me.getRoot(data);
if (root) {
total = root.length;
}
if (me.totalProperty) {
value = parseInt(me.getTotal(data), 10);
if (!isNaN(value)) {
total = value;
}
}
if (root) {
records = me.extractData(root);
recordCount = records.length;
}
}
return new Ext.data.ResultSet({
total  : total || recordCount,
count  : recordCount,
records: records,
success: success,
message: message
});
},
extractData : function(root) {
var me = this,
Model   = me.model,
length  = root.length,
records = new Array(length),
convertedValues, node, record, i;
if (!root.length && Ext.isObject(root)) {
root = [root];
length = 1;
}
for (i = 0; i < length; i++) {
node = root[i];
if (node.isModel) {
records[i] = node;
} else {
records[i] = record = new Model(undefined, me.getId(node), node, convertedValues = {});
record.phantom = false;
me.convertRecordData(convertedValues, node, record);
if (me.implicitIncludes && record.associations.length) {
me.readAssociated(record, node);
}
}
}
return records;
},
readAssociated: function(record, data) {
var associations = record.associations.items,
i            = 0,
length       = associations.length,
association, associationData, proxy, reader;
for (; i < length; i++) {
association     = associations[i];
associationData = this.getAssociatedDataRoot(data, association.associationKeyFunction || association.associationKey || association.name);
if (associationData) {
reader = association.getReader();
if (!reader) {
proxy = association.associatedModel.getProxy();
if (proxy) {
reader = proxy.getReader();
} else {
reader = new this.constructor({
model: association.associatedName
});
}
}
association.read(record, reader, associationData);
}  
}
},
getAssociatedDataRoot: function(data, associationName) {
if (Ext.isFunction(associationName)) {
return associationName(data);
}
return data[associationName];
},
getFields: function() {
return this.model.prototype.fields.items;
},
getData: Ext.identityFn,
getRoot: Ext.identityFn,
getResponseData: function(response) {
},
onMetaChange : function(meta) {
var me = this,
fields = meta.fields || me.getFields(),
newModel,
clientIdProperty;
me.metaData = meta;
me.root = meta.root || me.root;
me.idProperty = meta.idProperty || me.idProperty;
me.totalProperty = meta.totalProperty || me.totalProperty;
me.successProperty = meta.successProperty || me.successProperty;
me.messageProperty = meta.messageProperty || me.messageProperty;
clientIdProperty = meta.clientIdProperty;
if (me.model) {
me.model.setFields(fields, me.idProperty, clientIdProperty);
me.setModel(me.model, true);
}
else {
newModel = Ext.define("Ext.data.reader.Json-Model" + Ext.id(), {
extend: 'Ext.data.Model',
fields: fields,
clientIdProperty: clientIdProperty
});
if (me.idProperty) {
newModel.idProperty = me.idProperty;
}
me.setModel(newModel, true);
}
},
getIdProperty: function() {
var idField = this.model.prototype.idField,
idProperty = this.idProperty;
if (!idProperty && idField  && (idProperty = idField.mapping) == null) {
idProperty = idField.name;
}
return idProperty;
},
buildExtractors: function(force) {
var me          = this,
idProp      = me.getIdProperty(),
totalProp   = me.totalProperty,
successProp = me.successProperty,
messageProp = me.messageProperty,
accessor;
if (force === true) {
delete me.convertRecordData;
}
if (me.convertRecordData) {
return;
}   
if (totalProp) {
me.getTotal = me.createAccessor(totalProp);
}
if (successProp) {
me.getSuccess = me.createAccessor(successProp);
}
if (messageProp) {
me.getMessage = me.createAccessor(messageProp);
}
if (idProp) {
accessor = me.createAccessor(idProp);
me.getId = function(record) {
var id = accessor.call(me, record);
return (id === undefined || id === '') ? null : id;
};
} else {
me.getId = function() {
return null;
};
}
me.convertRecordData = me.buildRecordDataExtractor();
me.lastFieldGeneration = me.model.prototype.fields.generation;
},
recordDataExtractorTemplate : [
'var me = this\n',
'    ,fields = me.model.prototype.fields\n',
'    ,value\n',
'    ,internalId\n',
'<tpl for="fields">',
'    ,__field{#} = fields.map["{name}"]\n',
'</tpl>', ';\n',
'return function(dest, source, record) {\n',
'<tpl for="fields">',
'{% var fieldAccessExpression =  this.createFieldAccessExpression(values, "__field" + xindex, "source");',
'   if (fieldAccessExpression) { %}',
'    value = {[ this.createFieldAccessExpression(values, "__field" + xindex, "source") ]};\n',
'<tpl if="hasCustomConvert">',
'    dest["{name}"] = value === undefined ? __field{#}.convert(__field{#}.defaultValue, record) : __field{#}.convert(value, record);\n',
'<tpl elseif="defaultValue !== undefined">',
'    if (value === undefined) {\n',
'        if (me.applyDefaults) {\n',
'<tpl if="convert">',
'            dest["{name}"] = __field{#}.convert(__field{#}.defaultValue, record);\n',
'<tpl else>',
'            dest["{name}"] = __field{#}.defaultValue\n',
'</tpl>',
'        };\n',
'    } else {\n',
'<tpl if="convert">',
'        dest["{name}"] = __field{#}.convert(value, record);\n',
'<tpl else>',
'        dest["{name}"] = value;\n',
'</tpl>',
'    };\n',
'<tpl else>',
'    if (value !== undefined) {\n',
'<tpl if="convert">',
'        dest["{name}"] = __field{#}.convert(value, record);\n',
'<tpl else>',
'        dest["{name}"] = value;\n',
'</tpl>',
'    }\n',
'</tpl>',
'{% } else { %}',
'<tpl if="defaultValue !== undefined">',
'<tpl if="convert">',
'    dest["{name}"] = __field{#}.convert(__field{#}.defaultValue, record);\n',
'<tpl else>',
'    dest["{name}"] = __field{#}.defaultValue\n',
'</tpl>',
'</tpl>',
'{% } %}',
'</tpl>',
'<tpl if="clientIdProp">',
'    if (record && (internalId = {[ this.createFieldAccessExpression(\{mapping: values.clientIdProp\}, null, "source") ]})) {\n',
'        record.{["internalId"]} = internalId;\n',
'    }\n',
'</tpl>',
'};'
],
buildRecordDataExtractor: function() {
var me = this,
modelProto = me.model.prototype,
templateData = {
clientIdProp: modelProto.clientIdProperty,
fields: modelProto.fields.items
};
me.recordDataExtractorTemplate.createFieldAccessExpression = function() { 
return me.createFieldAccessExpression.apply(me,arguments);
};
return Ext.functionFactory(me.recordDataExtractorTemplate.apply(templateData)).call(me);
},
destroyReader: function() {
var me = this;
delete me.proxy;
delete me.model;
delete me.convertRecordData;
delete me.getId;
delete me.getTotal;
delete me.getSuccess;
delete me.getMessage;
}
}, function() {
var proto = this.prototype;
Ext.apply(proto, {
nullResultSet: new Ext.data.ResultSet({
total  : 0,
count  : 0,
records: [],
success: true,
message: ''
}),
recordDataExtractorTemplate: new Ext.XTemplate(proto.recordDataExtractorTemplate)
});
});
Ext.define('Ext.data.reader.Json', {
extend:  Ext.data.reader.Reader ,
alternateClassName: 'Ext.data.JsonReader',
alias : 'reader.json',
root: '',
metaProperty: 'metaData',
useSimpleAccessors: false,
readRecords: function(data) {
var me = this,
meta;
if (me.getMeta) {
meta = me.getMeta(data);
if (meta) {
me.onMetaChange(meta);
}
} else if (data.metaData) {
me.onMetaChange(data.metaData);
}
me.jsonData = data;
return me.callParent([data]);
},
getResponseData: function(response) {
var data, error;
try {
data = Ext.decode(response.responseText);
return this.readRecords(data);
} catch (ex) {
error = new Ext.data.ResultSet({
total  : 0,
count  : 0,
records: [],
success: false,
message: ex.message
});
this.fireEvent('exception', this, response, error);
Ext.Logger.warn('Unable to parse the JSON returned by the server');
return error;
}
},
buildExtractors : function() {
var me = this,
metaProp = me.metaProperty;
me.callParent(arguments);
if (me.root) {
me.getRoot = me.createAccessor(me.root);
} else {
me.getRoot = Ext.identityFn;
}
if (metaProp) {
me.getMeta = me.createAccessor(metaProp);
}
},
extractData: function(root) {
var recordName = this.record,
data = [],
length, i;
if (recordName) {
length = root.length;
if (!length && Ext.isObject(root)) {
length = 1;
root = [root];
}
for (i = 0; i < length; i++) {
data[i] = root[i][recordName];
}
} else {
data = root;
}
return this.callParent([data]);
},
createAccessor: (function() {
var re = /[\[\.]/;
return function(expr) {
if (Ext.isEmpty(expr)) {
return Ext.emptyFn;
}
if (Ext.isFunction(expr)) {
return expr;
}
if (this.useSimpleAccessors !== true) {
var i = String(expr).search(re);
if (i >= 0) {
return Ext.functionFactory('obj', 'return obj' + (i > 0 ? '.' : '') + expr);
}
}
return function(obj) {
return obj[expr];
};
};
}()),
createFieldAccessExpression: (function() {
var re = /[\[\.]/;
return function(field, fieldVarName, dataName) {
var mapping = field.mapping,
hasMap = mapping || mapping === 0,
map    = hasMap ? mapping : field.name,
result,
operatorIndex;
if (mapping === false) {
return;
}
if (typeof map === 'function') {
result = fieldVarName + '.mapping(' + dataName + ', this)';
} else if (this.useSimpleAccessors === true || ((operatorIndex = String(map).search(re)) < 0)) {
if (!hasMap || isNaN(map)) {
map = '"' + map + '"';
}
result = dataName + "[" + map + "]";
} else if (operatorIndex === 0) {
result = dataName + map;
} else {
var parts = map.split('.'),
len = parts.length,
i = 1,
tempResult = dataName + '.' + parts[0],
buffer = [tempResult]; 
for (; i < len; i++) {
tempResult += '.' + parts[i];
buffer.push(tempResult);
}
result = buffer.join(' && ');
}
return result;
};
}())
});
Ext.define('Ext.data.writer.Writer', {
alias: 'writer.base',
alternateClassName: ['Ext.data.DataWriter', 'Ext.data.Writer'],
writeAllFields: true,
nameProperty: 'name',
writeRecordId: true,
isWriter: true,
constructor: function(config) {
Ext.apply(this, config);
},
write: function(request) {
var operation = request.operation,
records   = operation.records || [],
len       = records.length,
i         = 0,
data      = [];
for (; i < len; i++) {
data.push(this.getRecordData(records[i], operation));
}
return this.writeRecords(request, data);
},
getRecordData: function(record, operation) {
var isPhantom = record.phantom === true,
writeAll = this.writeAllFields || isPhantom,
fields = record.fields,
fieldItems = fields.items,
data = {},
clientIdProperty = record.clientIdProperty,
changes,
field,
key,
mappedIdProperty,
f, fLen;
if (writeAll) {
fLen = fieldItems.length;
for (f = 0; f < fLen; f++) {
field = fieldItems[f];
if (field.persist) {
this.writeValue(data, field, record);
}
}
} else if (operation.action === 'destroy') {
this.writeValue(data, record.idField, record);
} else {
changes = record.getChanges();
for (key in changes) {
if (changes.hasOwnProperty(key)) {
field = fields.get(key);
if (field.persist) {
this.writeValue(data, field, record);
}
}
}
}
if (isPhantom) {
if (clientIdProperty && operation && operation.records.length > 1) {
data[clientIdProperty] = record.internalId;
}
} else if (this.writeRecordId) {
mappedIdProperty = fields.get(record.idProperty)[this.nameProperty] || record.idProperty;
data[mappedIdProperty] = record.getId();
}
return data;
},
writeValue: function(data, field, record){
var name = field[this.nameProperty],
dateFormat = this.dateFormat || field.dateWriteFormat || field.dateFormat,
value = record.get(field.name);
if (name == null) {
name = field.name;
}
if (field.serialize) {
data[name] = field.serialize(value, record);
} else if (field.type === Ext.data.Types.DATE && dateFormat && Ext.isDate(value)) {
data[name] = Ext.Date.format(value, dateFormat);
} else {
data[name] = value;
}
}
});
Ext.define('Ext.data.writer.Json', {
extend:  Ext.data.writer.Writer ,
alternateClassName: 'Ext.data.JsonWriter',
alias: 'writer.json',
root: undefined,
encode: false,
allowSingle: true,
expandData: false,
getExpandedData: function(data) {
var dataLength = data.length,
i = 0,
item,
prop,
nameParts,
j,
tempObj,
toObject = function(name, value) {
var o = {};
o[name] = value;
return o;
};
for (; i < dataLength; i++) {
item = data[i];
for (prop in item) {
if (item.hasOwnProperty(prop)) {
nameParts = prop.split('.');
j = nameParts.length - 1;
if (j > 0) {
tempObj = item[prop];
for (; j > 0; j--) {
tempObj = toObject(nameParts[j], tempObj);
}
item[nameParts[0]] = item[nameParts[0]] || {};
Ext.Object.merge(item[nameParts[0]], tempObj);
delete item[prop];
}
}
}
}
return data;
},
writeRecords: function(request, data) {
var root = this.root;
if (this.expandData) {
data = this.getExpandedData(data);
}
if (this.allowSingle && data.length === 1) {
data = data[0];
}
if (this.encode) {
if (root) {
request.params[root] = Ext.encode(data);
} else {
}
} else {
request.jsonData = request.jsonData || {};
if (root) {
request.jsonData[root] = data;
} else {
request.jsonData = data;
}
}
return request;
}
});
Ext.define('Ext.data.proxy.Proxy', {
alias: 'proxy.proxy',
alternateClassName: ['Ext.data.DataProxy', 'Ext.data.Proxy'],
mixins: {
observable:  Ext.util.Observable 
},
batchOrder: 'create,update,destroy',
batchActions: true,
defaultReaderType: 'json',
defaultWriterType: 'json',
isProxy: true,
isSynchronous: false,
constructor: function(config) {
var me = this;
config = config || {};
me.proxyConfig = config;
me.mixins.observable.constructor.call(me, config);
if (me.model !== undefined && !(me.model instanceof Ext.data.Model)) {
me.setModel(me.model);
} else {
if (me.reader) {
me.setReader(me.reader);
}
if (me.writer) {
me.setWriter(me.writer);
}
}
},
setModel: function(model, setOnStore) {
var me = this;
me.model = Ext.ModelManager.getModel(model);
me.setReader(this.reader);
me.setWriter(this.writer);
if (setOnStore && me.store) {
me.store.setModel(me.model);
}
},
getModel: function() {
return this.model;
},
setReader: function(reader) {
var me = this,
needsCopy = true,
current = me.reader;
if (reader === undefined || typeof reader == 'string') {
reader = {
type: reader
};
needsCopy = false;
}
if (reader.isReader) {
reader.setModel(me.model);
} else {
if (needsCopy) {
reader = Ext.apply({}, reader);
}
Ext.applyIf(reader, {
proxy: me,
model: me.model,
type : me.defaultReaderType
});
reader = Ext.createByAlias('reader.' + reader.type, reader);
}
if (reader !== current && reader.onMetaChange) {
reader.onMetaChange = Ext.Function.createSequence(reader.onMetaChange, this.onMetaChange, this);
}
me.reader = reader;
return me.reader;
},
getReader: function() {
return this.reader;
},
onMetaChange: function(meta) {
this.fireEvent('metachange', this, meta);
},
setWriter: function(writer) {
var me = this,
needsCopy = true;
if (writer === undefined || typeof writer == 'string') {
writer = {
type: writer
};
needsCopy = false;
}
if (!writer.isWriter) {
if (needsCopy) {
writer = Ext.apply({}, writer);
}
Ext.applyIf(writer, {
model: me.model,
type : me.defaultWriterType
});
writer = Ext.createByAlias('writer.' + writer.type, writer);
}
me.writer = writer;
return me.writer;
},
getWriter: function() {
return this.writer;
},
create: Ext.emptyFn,
read: Ext.emptyFn,
update: Ext.emptyFn,
destroy: Ext.emptyFn,
batch: function(options, listeners) {
var me = this,
useBatch = me.batchActions,
batch,
records,
actions, aLen, action, a, r, rLen, record;
if (options.operations === undefined) {
options = {
operations: options,
listeners: listeners
};
}
if (options.batch) {
if (Ext.isDefined(options.batch.runOperation)) {
batch = Ext.applyIf(options.batch, {
proxy: me,
listeners: {}
});
}
} else {
options.batch = {
proxy: me,
listeners: options.listeners || {}
};
}
if (!batch) {
batch = new Ext.data.Batch(options.batch);
}
batch.on('complete', Ext.bind(me.onBatchComplete, me, [options], 0));
actions = me.batchOrder.split(',');
aLen    = actions.length;
for (a = 0; a < aLen; a++) {
action  = actions[a];
records = options.operations[action];
if (records) {
if (useBatch) {
batch.add(new Ext.data.Operation({
action  : action,
records : records
}));
} else {
rLen = records.length;
for (r = 0; r < rLen; r++) {
record = records[r];
batch.add(new Ext.data.Operation({
action  : action,
records : [record]
}));
}
}
}
}
batch.start();
return batch;
},
onBatchComplete: function(batchOptions, batch) {
var scope = batchOptions.scope || this;
if (batch.hasException) {
if (Ext.isFunction(batchOptions.failure)) {
Ext.callback(batchOptions.failure, scope, [batch, batchOptions]);
}
} else if (Ext.isFunction(batchOptions.success)) {
Ext.callback(batchOptions.success, scope, [batch, batchOptions]);
}
if (Ext.isFunction(batchOptions.callback)) {
Ext.callback(batchOptions.callback, scope, [batch, batchOptions]);
}
},
clone: function() {
return new this.self(this.proxyConfig);
}
});
Ext.define('Ext.data.AbstractStore', {
mixins: {
observable:  Ext.util.Observable ,
sortable:  Ext.util.Sortable 
},
statics: {
create: function(store) {
if (!store.isStore) {
if (!store.type) {
store.type = 'store';
}
store = Ext.createByAlias('store.' + store.type, store);
}
return store;
}
},
onClassExtended: function(cls, data, hooks) {
var model = data.model,
onBeforeClassCreated;
if (typeof model == 'string') {
onBeforeClassCreated = hooks.onBeforeCreated;
hooks.onBeforeCreated = function() {
var me = this,
args = arguments;
Ext.require(model, function() {
onBeforeClassCreated.apply(me, args);
});
};
}
},
remoteSort  : false,
remoteFilter: false,
autoLoad: undefined,
autoSync: false,
batchUpdateMode: 'operation',
filterOnLoad: true,
sortOnLoad: true,
implicitModel: false,
defaultProxyType: 'memory',
isDestroyed: false,
isStore: true,
sortRoot: 'data',
constructor: function(config) {
var me = this,
filters;
Ext.apply(me, config);
me.removed = [];
me.mixins.observable.constructor.apply(me, arguments);
me.model = Ext.ModelManager.getModel(me.model);
Ext.applyIf(me, {
modelDefaults: null
});
if (!me.model && me.fields) {
me.model = Ext.define('Ext.data.Store.ImplicitModel-' + (me.storeId || Ext.id()), {
extend: 'Ext.data.Model',
fields: me.fields,
proxy: me.proxy || me.defaultProxyType
});
delete me.fields;
me.implicitModel = true;
}
me.setProxy(me.proxy || me.model.getProxy());
if (me.id && !me.storeId) {
me.storeId = me.id;
delete me.id;
}
if (me.storeId) {
Ext.data.StoreManager.register(me);
}
me.mixins.sortable.initSortable.call(me);
filters = me.decodeFilters(me.filters);
me.filters = new Ext.util.MixedCollection();
me.filters.addAll(filters);
},
setProxy: function(proxy) {
var me = this,
model = me.model;
if (proxy instanceof Ext.data.proxy.Proxy) {
proxy.setModel(model);
} else {
if (Ext.isString(proxy)) {
proxy = {
type: proxy,
model: model
};
} else if (!proxy.model) {
proxy = Ext.apply({
model: model
}, proxy)
}
proxy = Ext.createByAlias('proxy.' + proxy.type, proxy);
}
if (!me.disableMetaChangeEvent) {
proxy.on('metachange', me.onMetaChange, me);
}
me.proxy = proxy;
return me.proxy;
},
getProxy: function() {
return this.proxy;
},
onMetaChange: function(proxy, meta) {
this.fireEvent('metachange', this, meta);
},
create: function(data, options) {
var me = this,
instance = Ext.ModelManager.create(Ext.applyIf(data, me.modelDefaults), me.model.modelName),
operation;
options = options || {};
Ext.applyIf(options, {
action : 'create',
records: [instance]
});
operation = new Ext.data.Operation(options);
me.proxy.create(operation, me.onProxyWrite, me);
return instance;
},
read: function() {
return this.load.apply(this, arguments);
},
update: function(options) {
var me = this,
operation;
options = options || {};
Ext.applyIf(options, {
action : 'update',
records: me.getUpdatedRecords()
});
operation = new Ext.data.Operation(options);
return me.proxy.update(operation, me.onProxyWrite, me);
},
onProxyWrite: function(operation) {
var me = this,
success = operation.wasSuccessful(),
records = operation.getRecords();
switch (operation.action) {
case 'create':
me.onCreateRecords(records, operation, success);
break;
case 'update':
me.onUpdateRecords(records, operation, success);
break;
case 'destroy':
me.onDestroyRecords(records, operation, success);
break;
}
if (success) {
me.fireEvent('write', me, operation);
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
Ext.callback(operation.callback, operation.scope || me, [records, operation, success]);
},
onCreateRecords: Ext.emptyFn,
onUpdateRecords: Ext.emptyFn,
onDestroyRecords: function(records, operation, success) {
if (success) {
this.removed = [];
}
},
destroy: function(options) {
var me = this,
operation;
options = options || {};
Ext.applyIf(options, {
action : 'destroy',
records: me.getRemovedRecords()
});
operation = new Ext.data.Operation(options);
return me.proxy.destroy(operation, me.onProxyWrite, me);
},
onBatchOperationComplete: function(batch, operation) {
return this.onProxyWrite(operation);
},
onBatchComplete: function(batch, operation) {
var me = this,
operations = batch.operations,
length = operations.length,
i;
me.suspendEvents();
for (i = 0; i < length; i++) {
me.onProxyWrite(operations[i]);
}
me.resumeEvents();
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
},
onBatchException: function(batch, operation) {
},
filterNew: function(item) {
return item.phantom === true && item.isValid();
},
getNewRecords: function() {
return [];
},
getUpdatedRecords: function() {
return [];
},
getModifiedRecords : function(){
return [].concat(this.getNewRecords(), this.getUpdatedRecords());
},
filterUpdated: function(item) {
return item.dirty === true && item.phantom !== true && item.isValid();
},
getRemovedRecords: function() {
return this.removed;
},
filter: function(filters, value) {
},
decodeFilters: function(filters) {
if (!Ext.isArray(filters)) {
if (filters === undefined) {
filters = [];
} else {
filters = [filters];
}
}
var length = filters.length,
Filter = Ext.util.Filter,
config, i;
for (i = 0; i < length; i++) {
config = filters[i];
if (!(config instanceof Filter)) {
Ext.apply(config, {
root: 'data'
});
if (config.fn) {
config.filterFn = config.fn;
}
if (typeof config == 'function') {
config = {
filterFn: config
};
}
filters[i] = new Filter(config);
}
}
return filters;
},
clearFilter: function(supressEvent) {
},
isFiltered: function() {
},
filterBy: function(fn, scope) {
},
sync: function(options) {
var me = this,
operations = {},
toCreate = me.getNewRecords(),
toUpdate = me.getUpdatedRecords(),
toDestroy = me.getRemovedRecords(),
needsSync = false;
if (toCreate.length > 0) {
operations.create = toCreate;
needsSync = true;
}
if (toUpdate.length > 0) {
operations.update = toUpdate;
needsSync = true;
}
if (toDestroy.length > 0) {
operations.destroy = toDestroy;
needsSync = true;
}
if (needsSync && me.fireEvent('beforesync', operations) !== false) {
options = options || {};
me.proxy.batch(Ext.apply(options, {
operations: operations,
listeners: me.getBatchListeners()
}));
}
return needsSync;
},
getBatchListeners: function() {
var me = this,
listeners = {
scope: me,
exception: me.onBatchException
};
if (me.batchUpdateMode == 'operation') {
listeners.operationcomplete = me.onBatchOperationComplete;
} else {
listeners.complete = me.onBatchComplete;
}
return listeners;
},
save: function() {
return this.sync.apply(this, arguments);
},
load: function(options) {
var me = this,
operation = {
action: 'read'
};
if (me.remoteFilter) {
operation.filters = me.filters.items;
}
if (me.remoteSort) {
operation.sorters = me.getSorters();
}
Ext.apply(operation, options);
me.lastOptions = operation;
operation = new Ext.data.Operation(operation);
if (me.fireEvent('beforeload', me, operation) !== false) {
me.loading = true;
me.proxy.read(operation, me.onProxyLoad, me);
}
return me;
},
reload: function(options) {
var o = Ext.apply({}, options, this.lastOptions);
return this.load(o);
},
afterEdit : function(record, modifiedFieldNames) {
var me = this,
i, shouldSync;
if (me.autoSync && !me.autoSyncSuspended) {
for (i = modifiedFieldNames.length; i--;) {
if (record.fields.get(modifiedFieldNames[i]).persist) {
shouldSync = true;
break;
}
}
if (shouldSync) {
me.sync();
}
}
me.onUpdate(record, Ext.data.Model.EDIT, modifiedFieldNames);
me.fireEvent('update', me, record, Ext.data.Model.EDIT, modifiedFieldNames);
},
afterReject : function(record) {
this.onUpdate(record, Ext.data.Model.REJECT, null);
this.fireEvent('update', this, record, Ext.data.Model.REJECT, null);
},
afterCommit : function(record, modifiedFieldNames) {
if (!modifiedFieldNames) {
modifiedFieldNames = null;
}
this.onUpdate(record, Ext.data.Model.COMMIT, modifiedFieldNames);
this.fireEvent('update', this, record, Ext.data.Model.COMMIT, modifiedFieldNames);
},
onUpdate: Ext.emptyFn,
onIdChanged: function(model, oldId, newId, oldInternalId){
this.fireEvent('idchanged', this, model, oldId, newId, oldInternalId);
},
destroyStore: function() {
var implicitModelName,
me = this;
if (!me.isDestroyed) {
me.clearListeners();
if (me.storeId) {
Ext.data.StoreManager.unregister(me);
}
me.clearData();
me.data = me.tree = me.sorters = me.filters = me.groupers = null;
if (me.reader) {
me.reader.destroyReader();
}
me.proxy = me.reader = me.writer = null;
me.isDestroyed = true;
if (me.implicitModel) {
implicitModelName = Ext.getClassName(me.model);
Ext.undefine(implicitModelName);
Ext.ModelManager.unregisterType(implicitModelName);
} else {
me.model = null;
}
}
},
getState: function() {
var me = this,
hasState,
result,
hasGroupers = !!me.groupers,
groupers = [],
sorters = [],
filters = [];
if (hasGroupers) {
me.groupers.each(function(g) {
groupers[groupers.length] = g.serialize();
hasState = true;
});
}
if (me.sorters) {
me.sorters.each(function(s) {
if (hasGroupers && !me.groupers.contains(s)) {
sorters[sorters.length] = s.serialize();
hasState = true;
}
});
}
if (me.filters && me.statefulFilters) {
me.filters.each(function(f) {
filters[filters.length] = f.serialize();
hasState = true;
});
}
if (hasState) {
result = {};
if (groupers.length) {
result.groupers = groupers;
}
if (sorters.length) {
result.sorters = sorters;
}
if (filters.length) {
result.filters = filters;
}
return result;
}
},
applyState: function(state) {
var me = this,
hasSorters = !!me.sorters,
hasGroupers = !!me.groupers,
hasFilters = !!me.filters,
locallySorted;
if (hasGroupers && state.groupers) {
me.groupers.clear();
me.groupers.addAll(me.decodeGroupers(state.groupers));
}
if (hasSorters && state.sorters) {
me.sorters.clear();
me.sorters.addAll(me.decodeSorters(state.sorters));
}
if (hasFilters && state.filters) {
me.filters.clear();
me.filters.addAll(me.decodeFilters(state.filters));
}
if (hasSorters && hasGroupers) {
me.sorters.insert(0, me.groupers.getRange());
}
if (me.autoLoad && (me.remoteSort || me.remoteGroup || me.remoteFilter)) {
if (me.autoLoad === true) {
me.reload();
} else {
me.reload(me.autoLoad);
}
}
if (hasFilters && me.filters.length && !me.remoteFilter) {
me.filter();
locallySorted = me.sortOnFilter;
}
if (hasSorters && me.sorters.length && !me.remoteSort && !locallySorted) {
me.sort();
}
},
doSort: function(sorterFn) {
var me = this;
if (me.remoteSort) {
me.load();
} else {
me.data.sortBy(sorterFn);
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
me.fireEvent('sort', me, me.sorters.getRange());
},
clearData: Ext.emptyFn,
getCount: Ext.emptyFn,
getById: Ext.emptyFn,
removeAll: Ext.emptyFn,
isLoading: function() {
return !!this.loading;
},
suspendAutoSync: function() {
this.autoSyncSuspended = true;
},
resumeAutoSync: function() {
this.autoSyncSuspended = false;
}
});
Ext.define('Ext.container.DockingContainer', {
isDockingContainer: true,
defaultDockWeights: {
top:    { render: 1, visual: 1 },
left:   { render: 3, visual: 5 },
right:  { render: 5, visual: 7 },
bottom: { render: 7, visual: 3 }
},
dockOrder: {
top: -1,
left: -1,
right: 1,
bottom: 1
},
horizontalDocks: 0,
addDocked : function(items, pos) {
var me = this,
i = 0,
item, length;
items = me.prepareItems(items);
length = items.length;
for (; i < length; i++) {
item = items[i];
item.dock = item.dock || 'top';
if (item.dock === 'left' || item.dock === 'right') {
me.horizontalDocks++;
}
if (pos !== undefined) {
i += pos;
me.dockedItems.insert(i, item);
} else {
me.dockedItems.add(item);
}
item.onAdded(me, i);
if (me.hasListeners.dockedadd) {
me.fireEvent('dockedadd', me, item, i);
}
if (me.onDockedAdd !== Ext.emptyFn) {
me.onDockedAdd(item);
}
}
if (me.rendered && !me.suspendLayout) {
me.updateLayout();
}
return items;
},
destroyDockedItems: function(){
var dockedItems = this.dockedItems,
c;
if (dockedItems) {
while ((c = dockedItems.first())) {
this.removeDocked(c, true);
}
}
},
doRenderDockedItems: function (out, renderData, after) {
var me = renderData.$comp,
layout = me.componentLayout,
items,
tree;
if (layout.getDockedItems && !renderData.$skipDockedItems) {
items = layout.getDockedItems('render', !after);
tree = items && layout.getItemsRenderTree(items);
if (tree) {
Ext.DomHelper.generateMarkup(tree, out);
}
}
},
getDockedComponent: function(comp) {
if (Ext.isObject(comp)) {
comp = comp.getItemId();
}
return this.dockedItems.get(comp);
},
getDockedItems : function(selector, beforeBody) {
var dockedItems = this.getComponentLayout().getDockedItems('render', beforeBody);
if (selector && dockedItems.length) {
dockedItems = Ext.ComponentQuery.query(selector, dockedItems);
}
return dockedItems;
},
getDockingRefItems: function(deep, containerItems) {
var selector = deep && '*,* *',
dockedItems = this.getDockedItems(selector, true),
items;
dockedItems.push.apply(dockedItems, containerItems);
items = this.getDockedItems(selector, false);
dockedItems.push.apply(dockedItems, items);
return dockedItems;
},
initDockingItems: function() {
var me = this,
items = me.dockedItems;
me.dockedItems = new Ext.util.AbstractMixedCollection(false, me.getComponentId);
if (items) {
me.addDocked(items);
}
},
insertDocked : function(pos, items) {
this.addDocked(items, pos);
},
onDockedAdd : Ext.emptyFn,
onDockedRemove : Ext.emptyFn,
removeDocked : function(item, autoDestroy) {
var me = this,
layout,
hasLayout;
autoDestroy = autoDestroy === true || (autoDestroy !== false && me.autoDestroy);
if (!me.dockedItems.contains(item)) {
return item;
}
if (item.dock === 'left' || item.dock === 'right') {
me.horizontalDocks--;
}
layout = me.componentLayout;
hasLayout = layout && me.rendered;
if (hasLayout) {
layout.onRemove(item);
}
me.dockedItems.remove(item);
item.onRemoved(item.destroying || autoDestroy);
me.onDockedRemove(item);
if (autoDestroy) {
item.destroy();
} else if (hasLayout) {
layout.afterRemove(item);
}
if (me.hasListeners.dockedremove) {
me.fireEvent('dockedremove', me, item);
}
if (!me.destroying && !me.suspendLayout) {
me.updateLayout();
}
return item;
},
setupDockingRenderTpl: function (renderTpl) {
renderTpl.renderDockedItems = this.doRenderDockedItems;
}
});
Ext.define('Ext.button.Manager', {
singleton: true,
alternateClassName: 'Ext.ButtonToggleManager',
groups: {},
pressedButton: null,
buttonSelector: '.' + Ext.baseCSSPrefix + 'btn',
init: function() {
var me = this;
if (!me.initialized) {
Ext.getDoc().on({
keydown: me.onDocumentKeyDown,
mouseup: me.onDocumentMouseUp,
scope: me
});
me.initialized = true;
}
},
onDocumentKeyDown: function(e) {
var k = e.getKey(),
btn;
if (k === e.SPACE || k === e.ENTER) {
btn = e.getTarget(this.buttonSelector);
if (btn) {
Ext.getCmp(btn.id).onClick(e);
}
}
},
onButtonMousedown: function(button, e) {
var pressed = this.pressedButton;
if (pressed) {
pressed.onMouseUp(e);
}
this.pressedButton = button;
},
onDocumentMouseUp: function(e) {
var pressed = this.pressedButton;
if (pressed) {
pressed.onMouseUp(e);
this.pressedButton = null;
}
},
toggleGroup: function(btn, state) {
if (state) {
var g = this.groups[btn.toggleGroup],
length = g.length,
i;
for (i = 0; i < length; i++) {
if (g[i] !== btn) {
g[i].toggle(false);
}
}
}
},
register: function(btn) {
var me = this,
groups = this.groups,
group = groups[btn.toggleGroup];
me.init();
if (!btn.toggleGroup) {
return;
}
if (!group) {
group = groups[btn.toggleGroup] = [];
}
group.push(btn);
btn.on('toggle', me.toggleGroup, me);
},
unregister: function(btn) {
if (!btn.toggleGroup) {
return;
}
var me = this,
group = me.groups[btn.toggleGroup];
if (group) {
Ext.Array.remove(group, btn);
btn.un('toggle', me.toggleGroup, me);
}
},
getPressed: function(group) {
var g = this.groups[group],
i = 0,
len;
if (g) {
for (len = g.length; i < len; i++) {
if (g[i].pressed === true) {
return g[i];
}
}
}
return null;
} 
});
Ext.define('Ext.util.ClickRepeater', {
extend:  Ext.util.Observable ,
constructor : function(el, config){
var me = this;
me.el = Ext.get(el);
me.el.unselectable();
Ext.apply(me, config);
me.callParent();
me.addEvents(
"mousedown",
"click",
"mouseup"
);
if(!me.disabled){
me.disabled = true;
me.enable();
}
if(me.handler){
me.on("click", me.handler,  me.scope || me);
}
},
interval : 20,
delay: 250,
preventDefault : true,
stopDefault : false,
timer : 0,
enable: function(){
if(this.disabled){
this.el.on('mousedown', this.handleMouseDown, this);
if (Ext.isIE && !(Ext.isIE10p || (Ext.isStrict && Ext.isIE9))){
this.el.on('dblclick', this.handleDblClick, this);
}
if(this.preventDefault || this.stopDefault){
this.el.on('click', this.eventOptions, this);
}
}
this.disabled = false;
},
disable: function( force){
if(force || !this.disabled){
clearTimeout(this.timer);
if(this.pressedCls){
this.el.removeCls(this.pressedCls);
}
Ext.getDoc().un('mouseup', this.handleMouseUp, this);
this.el.removeAllListeners();
}
this.disabled = true;
},
setDisabled: function(disabled){
this[disabled ? 'disable' : 'enable']();
},
eventOptions: function(e){
if(this.preventDefault){
e.preventDefault();
}
if(this.stopDefault){
e.stopEvent();
}
},
destroy : function() {
this.disable(true);
Ext.destroy(this.el);
this.clearListeners();
},
handleDblClick : function(e){
clearTimeout(this.timer);
this.el.blur();
this.fireEvent("mousedown", this, e);
this.fireEvent("click", this, e);
},
handleMouseDown : function(e){
clearTimeout(this.timer);
this.el.blur();
if(this.pressedCls){
this.el.addCls(this.pressedCls);
}
this.mousedownTime = new Date();
Ext.getDoc().on("mouseup", this.handleMouseUp, this);
this.el.on("mouseout", this.handleMouseOut, this);
this.fireEvent("mousedown", this, e);
this.fireEvent("click", this, e);
if (this.accelerate) {
this.delay = 400;
}
e = new Ext.EventObjectImpl(e);
this.timer =  Ext.defer(this.click, this.delay || this.interval, this, [e]);
},
click : function(e){
this.fireEvent("click", this, e);
this.timer =  Ext.defer(this.click, this.accelerate ?
this.easeOutExpo(Ext.Date.getElapsed(this.mousedownTime),
400,
-390,
12000) :
this.interval, this, [e]);
},
easeOutExpo : function (t, b, c, d) {
return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
},
handleMouseOut : function(){
clearTimeout(this.timer);
if(this.pressedCls){
this.el.removeCls(this.pressedCls);
}
this.el.on("mouseover", this.handleMouseReturn, this);
},
handleMouseReturn : function(){
this.el.un("mouseover", this.handleMouseReturn, this);
if(this.pressedCls){
this.el.addCls(this.pressedCls);
}
this.click();
},
handleMouseUp : function(e){
clearTimeout(this.timer);
this.el.un("mouseover", this.handleMouseReturn, this);
this.el.un("mouseout", this.handleMouseOut, this);
Ext.getDoc().un("mouseup", this.handleMouseUp, this);
if(this.pressedCls){
this.el.removeCls(this.pressedCls);
}
this.fireEvent("mouseup", this, e);
}
});
Ext.define('Ext.layout.component.Button', {
alias: ['layout.button'],
extend:  Ext.layout.component.Auto ,
type: 'button',
htmlRE: /<.*>/,
beginLayout: function(ownerContext) {
var me = this,
owner = me.owner,
text = owner.text;
me.callParent(arguments);
ownerContext.btnWrapContext = ownerContext.getEl('btnWrap');
ownerContext.btnElContext = ownerContext.getEl('btnEl');
ownerContext.btnInnerElContext = ownerContext.getEl('btnInnerEl');
ownerContext.btnIconElContext = ownerContext.getEl('btnIconEl');
if (text && me.htmlRE.test(text)) {
ownerContext.isHtmlText = true;
owner.btnInnerEl.setStyle('line-height', 'normal');
owner.btnInnerEl.setStyle('padding-top', '');
}
},
beginLayoutCycle: function(ownerContext) {
var owner = this.owner,
lastWidthModel = this.lastWidthModel;
this.callParent(arguments);
if (lastWidthModel && !this.lastWidthModel.shrinkWrap &&
ownerContext.widthModel.shrinkWrap) {
owner.btnWrap.setStyle('height', '');
owner.btnEl.setStyle('height', '');
owner.btnInnerEl.setStyle('line-height', '');
}
},
calculate: function(ownerContext) {
var me = this,
owner = me.owner,
btnElContext = ownerContext.btnElContext,
btnInnerElContext = ownerContext.btnInnerElContext,
btnWrapContext = ownerContext.btnWrapContext,
mmax = Math.max,
ownerHeight, contentHeight, btnElHeight, innerElHeight;
me.callParent(arguments);
if (ownerContext.heightModel.shrinkWrap) {
btnElHeight = owner.btnEl.getHeight();
if (ownerContext.isHtmlText) {
me.centerInnerEl(
ownerContext,
btnElHeight
);
me.ieCenterIcon(ownerContext, btnElHeight);
}
} else {
ownerHeight = ownerContext.getProp('height');
if (ownerHeight) {
contentHeight = ownerHeight - ownerContext.getFrameInfo().height - ownerContext.getPaddingInfo().height;
btnElHeight = contentHeight;
if ((owner.menu || owner.split) && owner.arrowAlign === 'bottom') {
btnElHeight -= btnWrapContext.getPaddingInfo().bottom;
}
innerElHeight = btnElHeight;
if ((owner.icon || owner.iconCls || owner.glyph) &&
(owner.iconAlign === 'top' || owner.iconAlign === 'bottom')) {
innerElHeight -= btnInnerElContext.getPaddingInfo().height;
}
btnWrapContext.setProp('height', mmax(0, contentHeight));
btnElContext.setProp('height', mmax(0, btnElHeight));
if (ownerContext.isHtmlText) {
me.centerInnerEl(ownerContext, btnElHeight);
} else {
btnInnerElContext.setProp('line-height', mmax(0, innerElHeight) + 'px');
}
me.ieCenterIcon(ownerContext, btnElHeight);
} else if (ownerHeight !== 0) {
me.done = false;
}
}
},
centerInnerEl: function(ownerContext, btnElHeight) {
var me = this,
btnInnerElContext = ownerContext.btnInnerElContext,
innerElHeight = me.owner.btnInnerEl.getHeight();
if (ownerContext.heightModel.shrinkWrap && (btnElHeight < innerElHeight)) {
ownerContext.btnElContext.setHeight(innerElHeight);
} else if (btnElHeight > innerElHeight) {
btnInnerElContext.setProp(
'padding-top', 
Math.round((btnElHeight - innerElHeight) / 2) +
btnInnerElContext.getPaddingInfo().top 
);
}
},
ieCenterIcon: function(ownerContext, btnElHeight) {
var iconAlign = this.owner.iconAlign;
if ((Ext.isIEQuirks || Ext.isIE6) &&
(iconAlign === 'left' || iconAlign === 'right')) {
ownerContext.btnIconElContext.setHeight(btnElHeight);
}
},
publishInnerWidth: function(ownerContext, width) {
if (this.owner.getFrameInfo().table) {
ownerContext.btnInnerElContext.setWidth(
width -
ownerContext.getFrameInfo().width - ownerContext.getPaddingInfo().width -
ownerContext.btnWrapContext.getPaddingInfo().width
);
}
}
});
Ext.define('Ext.util.TextMetrics', {
statics: {
shared: null,
measure: function(el, text, fixedWidth){
var me = this,
shared = me.shared;
if(!shared){
shared = me.shared = new me(el, fixedWidth);
}
shared.bind(el);
shared.setFixedWidth(fixedWidth || 'auto');
return shared.getSize(text);
},
destroy: function(){
var me = this;
Ext.destroy(me.shared);
me.shared = null;
}
},
constructor: function(bindTo, fixedWidth){
var me = this,
measure = Ext.getBody().createChild({
role: 'presentation',
cls: Ext.baseCSSPrefix + 'textmetrics'
});
me.measure = measure; 
if (bindTo) {
me.bind(bindTo);
}
measure.position('absolute');
measure.setLocalXY(-1000, -1000);
measure.hide();
if (fixedWidth) {
measure.setWidth(fixedWidth);
}
},
getSize: function(text){
var measure = this.measure,
size;
measure.update(text);
size = measure.getSize();
measure.update('');
return size;
},
bind: function(el){
var me = this;
me.el = Ext.get(el);
me.measure.setStyle(
me.el.getStyles('font-size','font-style', 'font-weight', 'font-family','line-height', 'text-transform', 'letter-spacing')
);
},
setFixedWidth : function(width){
this.measure.setWidth(width);
},
getWidth : function(text){
this.measure.dom.style.width = 'auto';
return this.getSize(text).width;
},
getHeight : function(text){
return this.getSize(text).height;
},
destroy: function(){
var me = this;
me.measure.remove();
delete me.el;
delete me.measure;
}
}, function(){
Ext.Element.addMethods({
getTextWidth : function(text, min, max){
return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.value(text, this.dom.innerHTML, true)).width, min || 0, max || 1000000);
}
});
});
Ext.define('Ext.button.Button', {
alias: 'widget.button',
extend:  Ext.Component ,
mixins: {
queryable:  Ext.Queryable 
},
alternateClassName: 'Ext.Button',
isButton: true,
componentLayout: 'button',
hidden: false,
disabled: false,
pressed: false,
tabIndex: 0,
enableToggle: false,
menuAlign: 'tl-bl?',
showEmptyMenu: false,
textAlign: 'center',
clickEvent: 'click',
preventDefault: true,
handleMouseEvents: true,
tooltipType: 'qtip',
baseCls: Ext.baseCSSPrefix + 'btn',
pressedCls: 'pressed',
overCls: 'over',
focusCls: 'focus',
menuActiveCls: 'menu-active',
hrefTarget: '_blank',
ariaRole: 'button',
childEls: [
'btnEl', 'btnWrap', 'btnInnerEl', 'btnIconEl'
],
renderTpl: [
'<span id="{id}-btnWrap" role="presentation" class="{baseCls}-wrap',
'<tpl if="splitCls"> {splitCls}</tpl>',
'{childElCls}" unselectable="on">',
'<span id="{id}-btnEl" class="{baseCls}-button" role="presentation">',
'<span id="{id}-btnInnerEl" class="{baseCls}-inner {innerCls}',
'{childElCls}" unselectable="on">',
'{text}',
'</span>',
'<span role="presentation" id="{id}-btnIconEl" class="{baseCls}-icon-el {iconCls}',
'{childElCls} {glyphCls}" unselectable="on" style="',
'<tpl if="iconUrl">background-image:url({iconUrl});</tpl>',
'<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">',
'<tpl if="glyph">&#{glyph};</tpl><tpl if="iconCls || iconUrl">&#160;</tpl>',
'</span>',
'</span>',
'</span>',
'<tpl if="closable">',
'<span id="{id}-closeEl" role="presentation"',
' class="{baseCls}-close-btn"',
'<tpl if="closeText">',
' title="{closeText}" aria-label="{closeText}"',
'</tpl>',
'>',
'</span>',
'</tpl>'
],
scale: 'small',
allowedScales: ['small', 'medium', 'large'],
iconAlign: 'left',
arrowAlign: 'right',
arrowCls: 'arrow',
maskOnDisable: false,
shrinkWrap: 3,
frame: true,
hasFrameTable: function () {
return this.href && this.frameTable;
},
frameTableListener: function () {
if (!this.disabled) {
this.doNavigate();
}
},
doNavigate: function () {
if (this.hrefTarget === '_blank') {
window.open(this.href, this.hrefTarget);
} else {
location.href = this.href;
}
},
_triggerRegion: {},
initComponent: function() {
var me = this;
me.autoEl = {
tag: 'a',
hidefocus: 'on',
unselectable: 'on'
};
me.addCls(Ext.baseCSSPrefix + 'unselectable');
me.callParent(arguments);
me.addEvents(
'click',
'toggle',
'mouseover',
'mouseout',
'menushow',
'menuhide',
'menutriggerover',
'menutriggerout',
'textchange',
'iconchange',
'glyphchange'
);
if (me.menu) {
me.split = true;
me.menu = Ext.menu.Manager.get(me.menu);
me.menu.ownerButton = me;
}
if (me.url) {
me.href = me.url;
}
if (me.href && !me.hasOwnProperty('preventDefault')) {
me.preventDefault = false;
}
if (Ext.isString(me.toggleGroup) && me.toggleGroup !== '') {
me.enableToggle = true;
}
if (me.html && !me.text) {
me.text = me.html;
delete me.html;
}
me.glyphCls = me.baseCls + '-glyph';
},
getActionEl: function() {
return this.el;
},
getFocusEl: function() {
return this.el;
},
onDisable: function(){
this.callParent(arguments);
},
setComponentCls: function() {
var me = this,
cls = me.getComponentCls();
if (!Ext.isEmpty(me.oldCls)) {
me.removeClsWithUI(me.oldCls);
me.removeClsWithUI(me.pressedCls);
}
me.oldCls = cls;
me.addClsWithUI(cls);
},
getComponentCls: function() {
var me = this,
cls;
if (me.iconCls || me.icon || me.glyph) {
cls = [me.text ? 'icon-text-' + me.iconAlign : 'icon'];
} else if (me.text) {
cls = ['noicon'];
} else {
cls = [];
}
if (me.pressed) {
cls[cls.length] = me.pressedCls;
}
return cls;
},
beforeRender: function () {
var me = this,
autoEl = me.autoEl,
href = me.getHref(),
hrefTarget = me.hrefTarget;
if (!me.disabled) {
autoEl.tabIndex = me.tabIndex;
}
if (href) {
autoEl.href = href;
if (hrefTarget) {
autoEl.target = hrefTarget;
}
}
me.callParent();
me.oldCls = me.getComponentCls();
me.addClsWithUI(me.oldCls);
Ext.applyIf(me.renderData, me.getTemplateArgs());
},
onRender: function() {
var me = this,
addOnclick,
btn,
btnListeners;
me.doc = Ext.getDoc();
me.callParent(arguments);
btn = me.el;
if (me.tooltip) {
me.setTooltip(me.tooltip, true);
}
if (me.handleMouseEvents) {
btnListeners = {
scope: me,
mouseover: me.onMouseOver,
mouseout: me.onMouseOut,
mousedown: me.onMouseDown
};
if (me.split) {
btnListeners.mousemove = me.onMouseMove;
}
} else {
btnListeners = {
scope: me
};
}
if (me.menu) {
me.mon(me.menu, {
scope: me,
show: me.onMenuShow,
hide: me.onMenuHide
});
me.keyMap = new Ext.util.KeyMap({
target: me.el,
key: Ext.EventObject.DOWN,
handler: me.onDownKey,
scope: me
});
}
if (me.repeat) {
me.mon(new Ext.util.ClickRepeater(btn, Ext.isObject(me.repeat) ? me.repeat: {}), 'click', me.onRepeatClick, me);
} else {
if (btnListeners[me.clickEvent]) {
addOnclick = true;
} else {
btnListeners[me.clickEvent] = me.onClick;
}
}
me.mon(btn, btnListeners);
if (me.hasFrameTable()) {
me.mon(me.frameTable, 'click', me.frameTableListener, me);
}
if (addOnclick) {
me.mon(btn, me.clickEvent, me.onClick, me);
}
Ext.button.Manager.register(me);
},
getTemplateArgs: function() {
var me = this,
glyph = me.glyph,
glyphFontFamily = Ext._glyphFontFamily,
glyphParts;
if (typeof glyph === 'string') {
glyphParts = glyph.split('@');
glyph = glyphParts[0];
glyphFontFamily = glyphParts[1];
}
return {
innerCls : me.getInnerCls(),
splitCls : me.getSplitCls(),
iconUrl  : me.icon,
iconCls  : me.iconCls,
glyph: glyph,
glyphCls: glyph ? me.glyphCls : '', 
glyphFontFamily: glyphFontFamily,
text     : me.text || '&#160;',
closeText: me.closeText
};
},
setHref: function(href) {
this.href = href;
this.el.dom.href = this.getHref();
},
getHref: function() {
var me = this,
href = me.href;
return href ? Ext.urlAppend(href, Ext.Object.toQueryString(Ext.apply({}, me.params, me.baseParams))) : false;
},
setParams: function(params) {
this.params = params;
this.el.dom.href = this.getHref();
},
getSplitCls: function() {
var me = this;
return me.split ? (me.baseCls + '-' + me.arrowCls) + ' ' + (me.baseCls + '-' + me.arrowCls + '-' + me.arrowAlign) : '';
},
getInnerCls: function() {
return this.textAlign ? this.baseCls + '-inner-' + this.textAlign : '';
},
setIcon: function(icon) {
icon = icon || '';
var me = this,
btnIconEl = me.btnIconEl,
oldIcon = me.icon || '';
me.icon = icon;
if (icon != oldIcon) {
if (btnIconEl) {
btnIconEl.setStyle('background-image', icon ? 'url(' + icon + ')': '');
me.setComponentCls();
if (me.didIconStateChange(oldIcon, icon)) {
me.updateLayout();
}
}
me.fireEvent('iconchange', me, oldIcon, icon);
}
return me;
},
setIconCls: function(cls) {
cls = cls || '';
var me = this,
btnIconEl = me.btnIconEl,
oldCls = me.iconCls || '';
me.iconCls = cls;
if (oldCls != cls) {
if (btnIconEl) {
btnIconEl.removeCls(oldCls);
btnIconEl.addCls(cls);
me.setComponentCls();
if (me.didIconStateChange(oldCls, cls)) {
me.updateLayout();
}
}
me.fireEvent('iconchange', me, oldCls, cls);
}
return me;
},
setGlyph: function(glyph) {
glyph = glyph || 0;
var me = this,
btnIconEl = me.btnIconEl,
oldGlyph = me.glyph,
fontFamily, glyphParts;
me.glyph = glyph;
if (btnIconEl) {
if (typeof glyph === 'string') {
glyphParts = glyph.split('@');
glyph = glyphParts[0];
fontFamily = glyphParts[1] || Ext._glyphFontFamily;
}
if (!glyph) {
btnIconEl.dom.innerHTML = '';
} else if (oldGlyph != glyph) {
btnIconEl.dom.innerHTML = '&#' + glyph + ';';
}
if (fontFamily) {
btnIconEl.setStyle('font-family', fontFamily);
}
}
me.fireEvent('glyphchange', me, me.glyph, oldGlyph);
return me;
},
setTooltip: function(tooltip, initial) {
var me = this;
if (me.rendered) {
if (!initial || !tooltip) {
me.clearTip();
}
if (tooltip) {
if (Ext.quickTipsActive && Ext.isObject(tooltip)) {
Ext.tip.QuickTipManager.register(Ext.apply({
target: me.el.id
},
tooltip));
me.tooltip = tooltip;
} else {
me.el.dom.setAttribute(me.getTipAttr(), tooltip);
}
}
} else {
me.tooltip = tooltip;
}
return me;
},
setTextAlign: function(align) {
var me = this,
btnEl = me.btnEl;
if (btnEl) {
btnEl.removeCls(me.baseCls + '-inner-' + me.textAlign);
btnEl.addCls(me.baseCls + '-inner-' + align);
}
me.textAlign = align;
return me;
},
getTipAttr: function(){
return this.tooltipType == 'qtip' ? 'data-qtip' : 'title';
},
getRefItems: function(deep){
var menu = this.menu,
items;
if (menu) {
items = menu.getRefItems(deep);
items.unshift(menu);
}
return items || [];
},
clearTip: function() {
var me = this,
el = me.el;
if (Ext.quickTipsActive && Ext.isObject(me.tooltip)) {
Ext.tip.QuickTipManager.unregister(el);
} else {
el.dom.removeAttribute(me.getTipAttr());
}
},
beforeDestroy: function() {
var me = this;
if (me.rendered) {
me.clearTip();
}
if (me.menu && me.destroyMenu !== false) {
Ext.destroy(me.menu);
}
Ext.destroy(me.btnInnerEl, me.repeater);
me.callParent();
},
onDestroy: function() {
var me = this;
if (me.rendered) {
me.doc.un('mouseover', me.monitorMouseOver, me);
delete me.doc;
Ext.destroy(me.keyMap);
delete me.keyMap;
}
Ext.button.Manager.unregister(me);
me.callParent();
},
setHandler: function(handler, scope) {
this.handler = handler;
this.scope = scope;
return this;
},
setText: function(text) {
text = text || '';
var me = this,
oldText = me.text || '';
if (text != oldText) {
me.text = text;
if (me.rendered) {
me.btnInnerEl.update(text || '&#160;');
me.setComponentCls();
if (Ext.isStrict && Ext.isIE8) {
me.el.repaint();
}
me.updateLayout();
}
me.fireEvent('textchange', me, oldText, text);
}
return me;
},
didIconStateChange: function(old, current) {
var currentEmpty = Ext.isEmpty(current);
return Ext.isEmpty(old) ? !currentEmpty : currentEmpty;
},
getText: function() {
return this.text;
},
toggle: function(state, suppressEvent) {
var me = this;
state = state === undefined ? !me.pressed: !!state;
if (state !== me.pressed) {
if (me.rendered) {
me[state ? 'addClsWithUI': 'removeClsWithUI'](me.pressedCls);
}
me.pressed = state;
if (!suppressEvent) {
me.fireEvent('toggle', me, state);
Ext.callback(me.toggleHandler, me.scope || me, [me, state]);
}
}
return me;
},
maybeShowMenu: function(){
var me = this;
if (me.menu && !me.hasVisibleMenu() && !me.ignoreNextClick) {
me.showMenu(true);
}
},
showMenu: function( fromEvent) {
var me = this,
menu = me.menu;
if (me.rendered) {
if (me.tooltip && Ext.quickTipsActive && me.getTipAttr() != 'title') {
Ext.tip.QuickTipManager.getQuickTip().cancelShow(me.el);
}
if (menu.isVisible()) {
menu.hide();
}
if (!fromEvent || me.showEmptyMenu || menu.items.getCount() > 0) {
menu.showBy(me.el, me.menuAlign);
}
}
return me;
},
hideMenu: function() {
if (this.hasVisibleMenu()) {
this.menu.hide();
}
return this;
},
hasVisibleMenu: function() {
var menu = this.menu;
return menu && menu.rendered && menu.isVisible();
},
onRepeatClick: function(repeat, e) {
this.onClick(e);
},
onClick: function(e) {
var me = this;
me.doPreventDefault(e);
if (e.type !== 'keydown' && e.button !== 0) {
return;
}
if (!me.disabled) {
me.doToggle();
me.maybeShowMenu();
me.fireHandler(e);
}
},
doPreventDefault: function(e) {
if (this.preventDefault || (this.disabled && this.getHref()) && e) {
e.preventDefault();
}
},
fireHandler: function(e) {
var me = this,
handler = me.handler;
if (me.fireEvent('click', me, e) !== false) {
if (handler) {
handler.call(me.scope || me, me, e);
}
}
},
doToggle: function() {
var me = this;    
if (me.enableToggle && (me.allowDepress !== false || !me.pressed)) {
me.toggle();
}
},
onMouseOver: function(e) {
var me = this;
if (!me.disabled && !e.within(me.el, true, true)) {
me.onMouseEnter(e);
}
},
onMouseOut: function(e) {
var me = this;
if (!e.within(me.el, true, true)) {
if (me.overMenuTrigger) {
me.onMenuTriggerOut(e);
}
me.onMouseLeave(e);
}
},
onMouseMove: function(e) {
var me = this,
el = me.el,
over = me.overMenuTrigger,
overPosition, triggerRegion;
if (me.split) {
overPosition = (me.arrowAlign === 'right') ?
e.getX() - me.getX() : e.getY() - el.getY();
triggerRegion = me.getTriggerRegion();
if (overPosition > triggerRegion.begin && overPosition < triggerRegion.end) {
if (!over) {
me.onMenuTriggerOver(e);
}
} else {
if (over) {
me.onMenuTriggerOut(e);
}
}
}
},
getTriggerRegion: function() {
var me = this,
region = me._triggerRegion,
triggerSize = me.getTriggerSize(),
btnSize = me.arrowAlign === 'right' ? me.getWidth() : me.getHeight();
region.begin = btnSize - triggerSize;
region.end = btnSize;
return region;
},
getTriggerSize: function() {
var me = this,
size = me.triggerSize,
side, sideFirstLetter;
if (size == null) { 
side = me.arrowAlign;
sideFirstLetter = side.charAt(0);
size = me.triggerSize = me.el.getFrameWidth(sideFirstLetter) + me.getBtnWrapFrameWidth(sideFirstLetter)
if (me.frameSize) {
size = me.triggerSize += me.frameSize[side];
}
}
return size;
},
getBtnWrapFrameWidth: function(side) {
return this.btnWrap.getFrameWidth(side);
},
addOverCls: function() {
if (!this.disabled) {
this.addClsWithUI(this.overCls);
}
},
removeOverCls: function() {
this.removeClsWithUI(this.overCls);
},
onMouseEnter: function(e) {
this.fireEvent('mouseover', this, e);
},
onMouseLeave: function(e) {
this.fireEvent('mouseout', this, e);
},
onMenuTriggerOver: function(e) {
var me = this,
arrowTip = me.arrowTooltip;
me.overMenuTrigger = true;
if (me.split && arrowTip) {
me.btnWrap.dom.setAttribute(me.getTipAttr(), arrowTip);
}
me.fireEvent('menutriggerover', me, me.menu, e);
},
onMenuTriggerOut: function(e) {
var me = this;
delete me.overMenuTrigger;
if (me.split && me.arrowTooltip) {
me.btnWrap.dom.setAttribute(me.getTipAttr(), '');
}
me.fireEvent('menutriggerout', me, me.menu, e);
},
enable: function(silent) {
var me = this;
if(!me.disabled) return me;
me.callParent([silent]);
me.removeClsWithUI('disabled');
if (me.rendered) {
me.el.dom.setAttribute('tabIndex', me.tabIndex);
}
return me;
},
disable: function(silent) {
var me = this;
if(me.disabled) return me;
me.callParent([silent]);
me.addClsWithUI('disabled');
me.removeClsWithUI(me.overCls);
if (me.rendered) {
me.el.dom.removeAttribute('tabIndex');
}
if (me.btnInnerEl && Ext.isIE7m) {
me.btnInnerEl.repaint();
}
return me;
},
setScale: function(scale) {
var me = this,
ui = me.ui.replace('-' + me.scale, '');
if (!Ext.Array.contains(me.allowedScales, scale)) {
throw('#setScale: scale must be an allowed scale (' + me.allowedScales.join(', ') + ')');
}
me.scale = scale;
me.setUI(ui);
},
setUI: function(ui) {
var me = this;
if (me.scale && !ui.match(me.scale)) {
ui = ui + '-' + me.scale;
}
me.callParent([ui]);
},
onMouseDown: function(e) {
var me = this;
if (Ext.isIE) {
me.getFocusEl().focus();
}
if (!me.disabled && e.button === 0) {
Ext.button.Manager.onButtonMousedown(me, e);
me.addClsWithUI(me.pressedCls);
}
},
onMouseUp: function(e) {
var me = this;
if (!me.isDestroyed && e.button === 0) {
if (!me.pressed) {
me.removeClsWithUI(me.pressedCls);
}
}
},
onMenuShow: function(e) {
var me = this;
me.ignoreNextClick = 0;
me.addClsWithUI(me.menuActiveCls);
me.fireEvent('menushow', me, me.menu);
},
onMenuHide: function(e) {
var me = this;
me.removeClsWithUI(me.menuActiveCls);
me.ignoreNextClick = Ext.defer(me.restoreClick, 250, me);
me.fireEvent('menuhide', me, me.menu);
me.focus();
},
restoreClick: function() {
this.ignoreNextClick = 0;
},
onDownKey: function(k, e) {
var me = this;
if (me.menu && !me.disabled) {
me.showMenu();
e.stopEvent();
return false;
}
}
});
Ext.define('Ext.util.Offset', {
statics: {
fromObject: function(obj) {
return new this(obj.x, obj.y);
}
},
constructor: function(x, y) {
this.x = (x != null && !isNaN(x)) ? x : 0;
this.y = (y != null && !isNaN(y)) ? y : 0;
return this;
},
copy: function() {
return new Ext.util.Offset(this.x, this.y);
},
copyFrom: function(p) {
this.x = p.x;
this.y = p.y;
},
toString: function() {
return "Offset[" + this.x + "," + this.y + "]";
},
equals: function(offset) {
return (this.x == offset.x && this.y == offset.y);
},
round: function(to) {
if (!isNaN(to)) {
var factor = Math.pow(10, to);
this.x = Math.round(this.x * factor) / factor;
this.y = Math.round(this.y * factor) / factor;
} else {
this.x = Math.round(this.x);
this.y = Math.round(this.y);
}
},
isZero: function() {
return this.x == 0 && this.y == 0;
}
});
Ext.define('Ext.util.Region', {
statics: {
getRegion: function(el) {
return Ext.fly(el).getRegion();
},
from: function(o) {
return new this(o.top, o.right, o.bottom, o.left);
}
},
constructor : function(t, r, b, l) {
var me = this;
me.y = me.top = me[1] = t;
me.right = r;
me.bottom = b;
me.x = me.left = me[0] = l;
},
contains : function(region) {
var me = this;
return (region.x >= me.x &&
region.right <= me.right &&
region.y >= me.y &&
region.bottom <= me.bottom);
},
intersect : function(region) {
var me = this,
t = Math.max(me.y, region.y),
r = Math.min(me.right, region.right),
b = Math.min(me.bottom, region.bottom),
l = Math.max(me.x, region.x);
if (b > t && r > l) {
return new this.self(t, r, b, l);
}
else {
return false;
}
},
union : function(region) {
var me = this,
t = Math.min(me.y, region.y),
r = Math.max(me.right, region.right),
b = Math.max(me.bottom, region.bottom),
l = Math.min(me.x, region.x);
return new this.self(t, r, b, l);
},
constrainTo : function(r) {
var me = this,
constrain = Ext.Number.constrain;
me.top = me.y = constrain(me.top, r.y, r.bottom);
me.bottom = constrain(me.bottom, r.y, r.bottom);
me.left = me.x = constrain(me.left, r.x, r.right);
me.right = constrain(me.right, r.x, r.right);
return me;
},
adjust : function(t, r, b, l) {
var me = this;
me.top = me.y += t;
me.left = me.x += l;
me.right += r;
me.bottom += b;
return me;
},
getOutOfBoundOffset: function(axis, p) {
if (!Ext.isObject(axis)) {
if (axis == 'x') {
return this.getOutOfBoundOffsetX(p);
} else {
return this.getOutOfBoundOffsetY(p);
}
} else {
p = axis;
var d = new Ext.util.Offset();
d.x = this.getOutOfBoundOffsetX(p.x);
d.y = this.getOutOfBoundOffsetY(p.y);
return d;
}
},
getOutOfBoundOffsetX: function(p) {
if (p <= this.x) {
return this.x - p;
} else if (p >= this.right) {
return this.right - p;
}
return 0;
},
getOutOfBoundOffsetY: function(p) {
if (p <= this.y) {
return this.y - p;
} else if (p >= this.bottom) {
return this.bottom - p;
}
return 0;
},
isOutOfBound: function(axis, p) {
if (!Ext.isObject(axis)) {
if (axis == 'x') {
return this.isOutOfBoundX(p);
} else {
return this.isOutOfBoundY(p);
}
} else {
p = axis;
return (this.isOutOfBoundX(p.x) || this.isOutOfBoundY(p.y));
}
},
isOutOfBoundX: function(p) {
return (p < this.x || p > this.right);
},
isOutOfBoundY: function(p) {
return (p < this.y || p > this.bottom);
},
restrict: function(axis, p, factor) {
if (Ext.isObject(axis)) {
var newP;
factor = p;
p = axis;
if (p.copy) {
newP = p.copy();
}
else {
newP = {
x: p.x,
y: p.y
};
}
newP.x = this.restrictX(p.x, factor);
newP.y = this.restrictY(p.y, factor);
return newP;
} else {
if (axis == 'x') {
return this.restrictX(p, factor);
} else {
return this.restrictY(p, factor);
}
}
},
restrictX : function(p, factor) {
if (!factor) {
factor = 1;
}
if (p <= this.x) {
p -= (p - this.x) * factor;
}
else if (p >= this.right) {
p -= (p - this.right) * factor;
}
return p;
},
restrictY : function(p, factor) {
if (!factor) {
factor = 1;
}
if (p <= this.y) {
p -= (p - this.y) * factor;
}
else if (p >= this.bottom) {
p -= (p - this.bottom) * factor;
}
return p;
},
getSize: function() {
return {
width: this.right - this.x,
height: this.bottom - this.y
};
},
copy: function() {
return new this.self(this.y, this.right, this.bottom, this.x);
},
copyFrom: function(p) {
var me = this;
me.top = me.y = me[1] = p.y;
me.right = p.right;
me.bottom = p.bottom;
me.left = me.x = me[0] = p.x;
return this;
},
toString: function() {
return "Region[" + this.top + "," + this.right + "," + this.bottom + "," + this.left + "]";
},
translateBy: function(x, y) {
if (arguments.length == 1) {
y = x.y;
x = x.x;
}
var me = this;
me.top = me.y += y;
me.right += x;
me.bottom += y;
me.left = me.x += x;
return me;
},
round: function() {
var me = this;
me.top = me.y = Math.round(me.y);
me.right = Math.round(me.right);
me.bottom = Math.round(me.bottom);
me.left = me.x = Math.round(me.x);
return me;
},
equals: function(region) {
return (this.top == region.top && this.right == region.right && this.bottom == region.bottom && this.left == region.left);
}
});
Ext.define('Ext.dd.DragDropManager', {
singleton: true,
alternateClassName: ['Ext.dd.DragDropMgr', 'Ext.dd.DDM'],
ids: {},
handleIds: {},
dragCurrent: null,
dragOvers: {},
deltaX: 0,
deltaY: 0,
preventDefault: true,
stopPropagation: true,
initialized: false,
locked: false,
init: function() {
this.initialized = true;
},
POINT: 0,
INTERSECT: 1,
mode: 0,
notifyOccluded: false,
dragCls: Ext.baseCSSPrefix + 'dd-drag-current',
_execOnAll: function(sMethod, args) {
var ids = this.ids,
i, j, oDD, item;
for (i in ids) {
if (ids.hasOwnProperty(i)) {
item = ids[i];
for (j in item) {
if (item.hasOwnProperty(j)) {
oDD = item[j];
if (! this.isTypeOfDD(oDD)) {
continue;
}
oDD[sMethod].apply(oDD, args);
}
}
}
}
},
_onLoad: function() {
this.init();
var Event = Ext.EventManager;
Event.on(document, "mouseup",   this.handleMouseUp, this, true);
Event.on(document, "mousemove", this.handleMouseMove, this, true);
Event.on(window,   "unload",    this._onUnload, this, true);
Event.on(window,   "resize",    this._onResize, this, true);
},
_onResize: function(e) {
this._execOnAll("resetConstraints", []);
},
lock: function() { this.locked = true; },
unlock: function() { this.locked = false; },
isLocked: function() { return this.locked; },
locationCache: {},
useCache: true,
clickPixelThresh: 3,
clickTimeThresh: 350,
dragThreshMet: false,
clickTimeout: null,
startX: 0,
startY: 0,
regDragDrop: function(oDD, sGroup) {
if (!this.initialized) { this.init(); }
if (!this.ids[sGroup]) {
this.ids[sGroup] = {};
}
this.ids[sGroup][oDD.id] = oDD;
},
removeDDFromGroup: function(oDD, sGroup) {
if (!this.ids[sGroup]) {
this.ids[sGroup] = {};
}
var obj = this.ids[sGroup];
if (obj && obj[oDD.id]) {
delete obj[oDD.id];
}
},
_remove: function(oDD, clearGroup) {
if (this.clearingAll) {
return;
}
var ids = this.ids,
groups = oDD.groups,
g;
for (g in groups) {
if (groups.hasOwnProperty(g)) {
if (clearGroup) {
delete ids[g];
} else if (ids[g]) {
delete ids[g][oDD.id];
}
}
}
delete this.handleIds[oDD.id];
},
regHandle: function(sDDId, sHandleId) {
if (!this.handleIds[sDDId]) {
this.handleIds[sDDId] = {};
}
this.handleIds[sDDId][sHandleId] = sHandleId;
},
isDragDrop: function(id) {
return ( this.getDDById(id) ) ? true : false;
},
getRelated: function(p_oDD, bTargetsOnly) {
var oDDs = [],
i, j, dd;
for (i in p_oDD.groups) {
for (j in this.ids[i]) {
dd = this.ids[i][j];
if (! this.isTypeOfDD(dd)) {
continue;
}
if (!bTargetsOnly || dd.isTarget) {
oDDs[oDDs.length] = dd;
}
}
}
return oDDs;
},
isLegalTarget: function (oDD, oTargetDD) {
var targets = this.getRelated(oDD, true),
i, len;
for (i=0, len=targets.length;i<len;++i) {
if (targets[i].id == oTargetDD.id) {
return true;
}
}
return false;
},
isTypeOfDD: function (oDD) {
return (oDD && oDD.__ygDragDrop);
},
isHandle: function(sDDId, sHandleId) {
return ( this.handleIds[sDDId] &&
this.handleIds[sDDId][sHandleId] );
},
getDDById: function(id) {
var i, dd;
for (i in this.ids) {
dd = this.ids[i][id];
if (dd instanceof Ext.dd.DDTarget) {
return dd;
}
}
return null;
},
handleMouseDown: function(e, oDD) {
var me = this,
el;
if (Ext.quickTipsActive){
Ext.tip.QuickTipManager.ddDisable();
}
if (me.dragCurrent){
me.handleMouseUp(e);
}
me.mousedownEvent = e.clone();
me.currentTarget = e.getTarget();
me.dragCurrent = oDD;
el = oDD.getEl();
if (Ext.isIE9m && el.setCapture) {
el.setCapture();
}
me.startX = e.getPageX();
me.startY = e.getPageY();
me.deltaX = me.startX - el.offsetLeft;
me.deltaY = me.startY - el.offsetTop;
me.dragThreshMet = false;
me.clickTimeout = setTimeout(
function() {
me.startDrag(me.startX, me.startY);
},
me.clickTimeThresh
);
},
startDrag: function(x, y) {
var me = this,
current = me.dragCurrent,
dragEl;
clearTimeout(me.clickTimeout);
if (current) {
current.b4StartDrag(x, y);
current.startDrag(x, y);
dragEl = current.getDragEl();
if (dragEl) {
Ext.fly(dragEl).addCls(me.dragCls);
}
}
me.dragThreshMet = true;
},
handleMouseUp: function(e) {
var me = this;
if (Ext.quickTipsActive){
Ext.tip.QuickTipManager.ddEnable();
}
if (!me.dragCurrent) {
return;
}
if (Ext.isIE && document.releaseCapture) {
document.releaseCapture();
}
clearTimeout(me.clickTimeout);
if (me.dragThreshMet) {
me.fireEvents(e, true);
}
me.stopDrag(e);
me.stopEvent(e);
},
stopEvent: function(e) {
if (this.stopPropagation) {
e.stopPropagation();
}
if (this.preventDefault) {
e.preventDefault();
}
},
stopDrag: function(e) {
var me = this,
current = me.dragCurrent,
dragEl;
if (current) {
if (me.dragThreshMet) {
dragEl = current.getDragEl();
if (dragEl) {
Ext.fly(dragEl).removeCls(me.dragCls);
}
current.b4EndDrag(e);
current.endDrag(e);
}
me.dragCurrent.onMouseUp(e);
}
me.dragCurrent = null;
me.dragOvers = {};
},
handleMouseMove: function(e) {
var me = this,
current = me.dragCurrent,
diffX,
diffY;
if (!current) {
return true;
}
if (!me.dragThreshMet) {
diffX = Math.abs(me.startX - e.getPageX());
diffY = Math.abs(me.startY - e.getPageY());
if (diffX > me.clickPixelThresh || diffY > me.clickPixelThresh) {
me.startDrag(me.startX, me.startY);
}
}
if (me.dragThreshMet) {
current.b4Drag(e);
current.onDrag(e);
if (!current.moveOnly) {
me.fireEvents(e, false);
}
}
me.stopEvent(e);
return true;
},
fireEvents: function(e, isDrop) {
var me = this,
dragCurrent = me.dragCurrent,
dragEl,
oldDragElTop,
mousePoint = e.getPoint(),
overTarget,
overTargetEl,
allTargets = [],
oldOvers  = [],  
outEvts   = [],
overEvts  = [],
dropEvts  = [],
enterEvts = [],
xy,
needsSort,
i,
len,
sGroup;
if (!dragCurrent || dragCurrent.isLocked()) {
return;
}
if (!me.notifyOccluded && (!Ext.supports.PointerEvents || Ext.isIE10m || Ext.isOpera) && !(dragCurrent.deltaX < 0 || dragCurrent.deltaY < 0)) {
dragEl = dragCurrent.getDragEl();
oldDragElTop = dragEl.style.top;
dragEl.style.top = '-10000px';
xy = e.getXY();
e.target = document.elementFromPoint(xy[0], xy[1]);
dragEl.style.top = oldDragElTop;
}
for (i in me.dragOvers) {
overTarget = me.dragOvers[i];
if (!me.isTypeOfDD(overTarget)) {
continue;
}
if (me.notifyOccluded) {
if (!this.isOverTarget(mousePoint, overTarget, me.mode)) {
outEvts.push(overTarget);
}
}
else {
if (!e.within(overTarget.getEl())) {
outEvts.push(overTarget);
}
}
oldOvers[i] = true;
delete me.dragOvers[i];
}
for (sGroup in dragCurrent.groups) {
if ("string" != typeof sGroup) {
continue;
}
for (i in me.ids[sGroup]) {
overTarget = me.ids[sGroup][i];
if (me.isTypeOfDD(overTarget) &&
(overTargetEl = overTarget.getEl()) &&
(overTarget.isTarget) &&
(!overTarget.isLocked()) &&
(Ext.fly(overTargetEl).isVisible(true)) &&
((overTarget != dragCurrent) || (dragCurrent.ignoreSelf === false))) {
if (me.notifyOccluded) {
if ((overTarget.zIndex = me.getZIndex(overTargetEl)) !== -1) {
needsSort = true;
}
allTargets.push(overTarget);
}
else {
if (e.within(overTarget.getEl())) {
allTargets.push(overTarget);
break;
}
}
}
}
}
if (needsSort) {
Ext.Array.sort(allTargets, me.byZIndex);
}
for (i = 0, len = allTargets.length; i < len; i++) {
overTarget = allTargets[i];
if (me.isOverTarget(mousePoint, overTarget, me.mode)) {
if (isDrop) {
dropEvts.push( overTarget );
} else {
if (!oldOvers[overTarget.id]) {
enterEvts.push( overTarget );
} else {
overEvts.push( overTarget );
}
me.dragOvers[overTarget.id] = overTarget;
}
if (!me.notifyOccluded) {
break;
}
}
}
if (me.mode) {
if (outEvts.length) {
dragCurrent.b4DragOut(e, outEvts);
dragCurrent.onDragOut(e, outEvts);
}
if (enterEvts.length) {
dragCurrent.onDragEnter(e, enterEvts);
}
if (overEvts.length) {
dragCurrent.b4DragOver(e, overEvts);
dragCurrent.onDragOver(e, overEvts);
}
if (dropEvts.length) {
dragCurrent.b4DragDrop(e, dropEvts);
dragCurrent.onDragDrop(e, dropEvts);
}
} else {
for (i=0, len=outEvts.length; i<len; ++i) {
dragCurrent.b4DragOut(e, outEvts[i].id);
dragCurrent.onDragOut(e, outEvts[i].id);
}
for (i=0,len=enterEvts.length; i<len; ++i) {
dragCurrent.onDragEnter(e, enterEvts[i].id);
}
for (i=0,len=overEvts.length; i<len; ++i) {
dragCurrent.b4DragOver(e, overEvts[i].id);
dragCurrent.onDragOver(e, overEvts[i].id);
}
for (i=0, len=dropEvts.length; i<len; ++i) {
dragCurrent.b4DragDrop(e, dropEvts[i].id);
dragCurrent.onDragDrop(e, dropEvts[i].id);
}
}
if (isDrop && !dropEvts.length) {
dragCurrent.onInvalidDrop(e);
}
},
getZIndex: function(element) {
var body = document.body,
z,
zIndex = -1;
element = Ext.getDom(element);
while (element !== body) {
if (!isNaN(z = Number(Ext.fly(element).getStyle('zIndex')))) {
zIndex = z;
}
element = element.parentNode;
}
return zIndex;
},
byZIndex: function(d1, d2) {
return d1.zIndex < d2.zIndex;
},
getBestMatch: function(dds) {
var winner = null,
len = dds.length,
i, dd;
if (len == 1) {
winner = dds[0];
} else {
for (i=0; i<len; ++i) {
dd = dds[i];
if (dd.cursorIsOver) {
winner = dd;
break;
} else {
if (!winner ||
winner.overlap.getArea() < dd.overlap.getArea()) {
winner = dd;
}
}
}
}
return winner;
},
refreshCache: function(groups) {
var sGroup, i, oDD, loc;
for (sGroup in groups) {
if ("string" != typeof sGroup) {
continue;
}
for (i in this.ids[sGroup]) {
oDD = this.ids[sGroup][i];
if (this.isTypeOfDD(oDD)) {
loc = this.getLocation(oDD);
if (loc) {
this.locationCache[oDD.id] = loc;
} else {
delete this.locationCache[oDD.id];
}
}
}
}
},
verifyEl: function(el) {
if (el) {
var parent;
if(Ext.isIE){
try{
parent = el.offsetParent;
}catch(e){}
}else{
parent = el.offsetParent;
}
if (parent) {
return true;
}
}
return false;
},
getLocation: function(oDD) {
if (! this.isTypeOfDD(oDD)) {
return null;
}
if (oDD.getRegion) {
return oDD.getRegion();
}
var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;
try {
pos= Ext.Element.getXY(el);
} catch (e) { }
if (!pos) {
return null;
}
x1 = pos[0];
x2 = x1 + el.offsetWidth;
y1 = pos[1];
y2 = y1 + el.offsetHeight;
t = y1 - oDD.padding[0];
r = x2 + oDD.padding[1];
b = y2 + oDD.padding[2];
l = x1 - oDD.padding[3];
return new Ext.util.Region(t, r, b, l);
},
isOverTarget: function(pt, oTarget, intersect) {
var loc = this.locationCache[oTarget.id],
dc,
pos,
el,
curRegion,
overlap;
if (!loc || !this.useCache) {
loc = this.getLocation(oTarget);
this.locationCache[oTarget.id] = loc;
}
if (!loc) {
return false;
}
oTarget.cursorIsOver = loc.contains( pt );
dc = this.dragCurrent;
if (!dc || !dc.getTargetCoord ||
(!intersect && !dc.constrainX && !dc.constrainY)) {
return oTarget.cursorIsOver;
}
oTarget.overlap = null;
pos = dc.getTargetCoord(pt.x, pt.y);
el = dc.getDragEl();
curRegion = new Ext.util.Region(pos.y,
pos.x + el.offsetWidth,
pos.y + el.offsetHeight,
pos.x
);
overlap = curRegion.intersect(loc);
if (overlap) {
oTarget.overlap = overlap;
return (intersect) ? true : oTarget.cursorIsOver;
} else {
return false;
}
},
_onUnload: function(e, me) {
Ext.dd.DragDropManager.unregAll();
},
unregAll: function() {
var me = this,
cache = me.elementCache,
i;
if (me.dragCurrent) {
me.stopDrag();
me.dragCurrent = null;
}
me.clearingAll = true;
me._execOnAll("unreg", []);
delete me.clearingAll;
for (i in cache) {
delete cache[i];
}
me.elementCache = {};
me.ids = {};
me.handleIds = {};
},
elementCache: {},
getElWrapper: function(id) {
var oWrapper = this.elementCache[id];
if (!oWrapper || !oWrapper.el) {
oWrapper = this.elementCache[id] =
new this.ElementWrapper(Ext.getDom(id));
}
return oWrapper;
},
getElement: function(id) {
return Ext.getDom(id);
},
getCss: function(id) {
var el = Ext.getDom(id);
return (el) ? el.style : null;
},
ElementWrapper: function(el) {
this.el = el || null;
this.id = this.el && el.id;
this.css = this.el && el.style;
},
getPosX: function(el) {
return Ext.Element.getX(el);
},
getPosY: function(el) {
return Ext.Element.getY(el);
},
swapNode: function(n1, n2) {
if (n1.swapNode) {
n1.swapNode(n2);
} else {
var p = n2.parentNode,
s = n2.nextSibling;
if (s == n1) {
p.insertBefore(n1, n2);
} else if (n2 == n1.nextSibling) {
p.insertBefore(n2, n1);
} else {
n1.parentNode.replaceChild(n2, n1);
p.insertBefore(n1, s);
}
}
},
getScroll: function () {
var doc   = window.document,
docEl = doc.documentElement,
body  = doc.body,
top   = 0,
left  = 0;
if (Ext.isGecko4) {
top  = window.scrollYOffset;
left = window.scrollXOffset;
} else {
if (docEl && (docEl.scrollTop || docEl.scrollLeft)) {
top  = docEl.scrollTop;
left = docEl.scrollLeft;
} else if (body) {
top  = body.scrollTop;
left = body.scrollLeft;
}
}
return {
top: top,
left: left
};
},
getStyle: function(el, styleProp) {
return Ext.fly(el).getStyle(styleProp);
},
getScrollTop: function () {
return this.getScroll().top;
},
getScrollLeft: function () {
return this.getScroll().left;
},
moveToEl: function (moveEl, targetEl) {
var aCoord = Ext.Element.getXY(targetEl);
Ext.Element.setXY(moveEl, aCoord);
},
numericSort: function(a, b) {
return (a - b);
},
_timeoutCount: 0,
_addListeners: function() {
if ( document ) {
this._onLoad();
} else {
if (this._timeoutCount <= 2000) {
setTimeout(this._addListeners, 10);
if (document && document.body) {
this._timeoutCount += 1;
}
}
}
},
handleWasClicked: function(node, id) {
if (this.isHandle(id, node.id)) {
return true;
} else {
var p = node.parentNode;
while (p) {
if (this.isHandle(id, p.id)) {
return true;
} else {
p = p.parentNode;
}
}
}
return false;
}
}, function() {
this._addListeners();
});
Ext.define('Ext.dd.DragDrop', {
constructor: function(id, sGroup, config) {
if(id) {
this.init(id, sGroup, config);
}
},
id: null,
config: null,
dragElId: null,
handleElId: null,
invalidHandleTypes: null,
invalidHandleIds: null,
invalidHandleClasses: null,
startPageX: 0,
startPageY: 0,
groups: null,
locked: false,
lock: function() {
this.locked = true;
},
moveOnly: false,
unlock: function() {
this.locked = false;
},
isTarget: true,
padding: null,
_domRef: null,
__ygDragDrop: true,
constrainX: false,
constrainY: false,
minX: 0,
maxX: 0,
minY: 0,
maxY: 0,
maintainOffset: false,
xTicks: null,
yTicks: null,
primaryButtonOnly: true,
available: false,
hasOuterHandles: false,
b4StartDrag: function(x, y) { },
startDrag: function(x, y) {  },
b4Drag: function(e) { },
onDrag: function(e) {  },
onDragEnter: function(e, id) {  },
b4DragOver: function(e) { },
onDragOver: function(e, id) {  },
b4DragOut: function(e) { },
onDragOut: function(e, id) {  },
b4DragDrop: function(e) { },
onDragDrop: function(e, id) {  },
onInvalidDrop: function(e) {  },
b4EndDrag: function(e) { },
endDrag: function(e) {  },
b4MouseDown: function(e) {  },
onMouseDown: function(e) {  },
onMouseUp: function(e) {  },
onAvailable: function () {
},
defaultPadding: {
left: 0,
right: 0,
top: 0,
bottom: 0
},
constrainTo : function(constrainTo, pad, inContent){
if(Ext.isNumber(pad)){
pad = {left: pad, right:pad, top:pad, bottom:pad};
}
pad = pad || this.defaultPadding;
var b = Ext.get(this.getEl()).getBox(),
ce = Ext.get(constrainTo),
s = ce.getScroll(),
c,
cd = ce.dom,
xy,
topSpace,
leftSpace;
if(cd == document.body){
c = { x: s.left, y: s.top, width: Ext.Element.getViewWidth(), height: Ext.Element.getViewHeight()};
}else{
xy = ce.getXY();
c = {x : xy[0], y: xy[1], width: cd.clientWidth, height: cd.clientHeight};
}
topSpace = b.y - c.y;
leftSpace = b.x - c.x;
this.resetConstraints();
this.setXConstraint(leftSpace - (pad.left||0), 
c.width - leftSpace - b.width - (pad.right||0), 
this.xTickSize
);
this.setYConstraint(topSpace - (pad.top||0), 
c.height - topSpace - b.height - (pad.bottom||0), 
this.yTickSize
);
},
getEl: function() {
if (!this._domRef) {
this._domRef = Ext.getDom(this.id);
}
return this._domRef;
},
getDragEl: function() {
return Ext.getDom(this.dragElId);
},
init: function(id, sGroup, config) {
this.initTarget(id, sGroup, config);
Ext.EventManager.on(this.id, "mousedown", this.handleMouseDown, this);
},
initTarget: function(id, sGroup, config) {
this.config = config || {};
this.DDMInstance = Ext.dd.DragDropManager;
this.groups = {};
if (typeof id !== "string") {
id = Ext.id(id);
}
this.id = id;
this.addToGroup((sGroup) ? sGroup : "default");
this.handleElId = id;
this.setDragElId(id);
this.invalidHandleTypes = { A: "A" };
this.invalidHandleIds = {};
this.invalidHandleClasses = [];
this.applyConfig();
this.handleOnAvailable();
},
applyConfig: function() {
this.padding           = this.config.padding || [0, 0, 0, 0];
this.isTarget          = (this.config.isTarget !== false);
this.maintainOffset    = (this.config.maintainOffset);
this.primaryButtonOnly = (this.config.primaryButtonOnly !== false);
},
handleOnAvailable: function() {
this.available = true;
this.resetConstraints();
this.onAvailable();
},
setPadding: function(iTop, iRight, iBot, iLeft) {
if (!iRight && 0 !== iRight) {
this.padding = [iTop, iTop, iTop, iTop];
} else if (!iBot && 0 !== iBot) {
this.padding = [iTop, iRight, iTop, iRight];
} else {
this.padding = [iTop, iRight, iBot, iLeft];
}
},
setInitPosition: function(diffX, diffY) {
var el = this.getEl(),
dx, dy, p;
if (!this.DDMInstance.verifyEl(el)) {
return;
}
dx = diffX || 0;
dy = diffY || 0;
p = Ext.Element.getXY( el );
this.initPageX = p[0] - dx;
this.initPageY = p[1] - dy;
this.lastPageX = p[0];
this.lastPageY = p[1];
this.setStartPosition(p);
},
setStartPosition: function(pos) {
var p = pos || Ext.Element.getXY( this.getEl() );
this.deltaSetXY = null;
this.startPageX = p[0];
this.startPageY = p[1];
},
addToGroup: function(sGroup) {
this.groups[sGroup] = true;
this.DDMInstance.regDragDrop(this, sGroup);
},
removeFromGroup: function(sGroup) {
if (this.groups[sGroup]) {
delete this.groups[sGroup];
}
this.DDMInstance.removeDDFromGroup(this, sGroup);
},
setDragElId: function(id) {
this.dragElId = id;
},
setHandleElId: function(id) {
if (typeof id !== "string") {
id = Ext.id(id);
}
this.handleElId = id;
this.DDMInstance.regHandle(this.id, id);
},
setOuterHandleElId: function(id) {
if (typeof id !== "string") {
id = Ext.id(id);
}
Ext.EventManager.on(id, "mousedown", this.handleMouseDown, this);
this.setHandleElId(id);
this.hasOuterHandles = true;
},
unreg: function() {
var me = this;
Ext.EventManager.un(me.id, "mousedown", me.handleMouseDown, me);
me._domRef = null;
me.DDMInstance._remove(me, me.autoGroup);
},
destroy : function(){
this.unreg();
},
isLocked: function() {
return (this.DDMInstance.isLocked() || this.locked);
},
handleMouseDown: function(e, oDD){
var me = this;
if ((me.primaryButtonOnly && e.button != 0) || me.isLocked()) {
return;
}
me.DDMInstance.refreshCache(me.groups);
if (me.hasOuterHandles || me.DDMInstance.isOverTarget(e.getPoint(), me))  {
if (me.clickValidator(e)) {
me.setStartPosition();
me.b4MouseDown(e);
me.onMouseDown(e);
me.DDMInstance.handleMouseDown(e, me);
me.DDMInstance.stopEvent(e);
}
}
},
clickValidator: function(e) {
var target = e.getTarget();
return ( this.isValidHandleChild(target) &&
(this.id == this.handleElId ||
this.DDMInstance.handleWasClicked(target, this.id)) );
},
addInvalidHandleType: function(tagName) {
var type = tagName.toUpperCase();
this.invalidHandleTypes[type] = type;
},
addInvalidHandleId: function(id) {
if (typeof id !== "string") {
id = Ext.id(id);
}
this.invalidHandleIds[id] = id;
},
addInvalidHandleClass: function(cssClass) {
this.invalidHandleClasses.push(cssClass);
},
removeInvalidHandleType: function(tagName) {
var type = tagName.toUpperCase();
delete this.invalidHandleTypes[type];
},
removeInvalidHandleId: function(id) {
if (typeof id !== "string") {
id = Ext.id(id);
}
delete this.invalidHandleIds[id];
},
removeInvalidHandleClass: function(cssClass) {
for (var i=0, len=this.invalidHandleClasses.length; i<len; ++i) {
if (this.invalidHandleClasses[i] == cssClass) {
delete this.invalidHandleClasses[i];
}
}
},
isValidHandleChild: function(node) {
var valid = true,
nodeName,
i, len;
try {
nodeName = node.nodeName.toUpperCase();
} catch(e) {
nodeName = node.nodeName;
}
valid = valid && !this.invalidHandleTypes[nodeName];
valid = valid && !this.invalidHandleIds[node.id];
for (i=0, len=this.invalidHandleClasses.length; valid && i<len; ++i) {
valid = !Ext.fly(node).hasCls(this.invalidHandleClasses[i]);
}
return valid;
},
setXTicks: function(iStartX, iTickSize) {
this.xTicks = [];
this.xTickSize = iTickSize;
var tickMap = {},
i;
for (i = this.initPageX; i >= this.minX; i = i - iTickSize) {
if (!tickMap[i]) {
this.xTicks[this.xTicks.length] = i;
tickMap[i] = true;
}
}
for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
if (!tickMap[i]) {
this.xTicks[this.xTicks.length] = i;
tickMap[i] = true;
}
}
Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort);
},
setYTicks: function(iStartY, iTickSize) {
this.yTicks = [];
this.yTickSize = iTickSize;
var tickMap = {},
i;
for (i = this.initPageY; i >= this.minY; i = i - iTickSize) {
if (!tickMap[i]) {
this.yTicks[this.yTicks.length] = i;
tickMap[i] = true;
}
}
for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
if (!tickMap[i]) {
this.yTicks[this.yTicks.length] = i;
tickMap[i] = true;
}
}
Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort);
},
setXConstraint: function(iLeft, iRight, iTickSize) {
this.leftConstraint = iLeft;
this.rightConstraint = iRight;
this.minX = this.initPageX - iLeft;
this.maxX = this.initPageX + iRight;
if (iTickSize) { this.setXTicks(this.initPageX, iTickSize); }
this.constrainX = true;
},
clearConstraints: function() {
this.constrainX = false;
this.constrainY = false;
this.clearTicks();
},
clearTicks: function() {
this.xTicks = null;
this.yTicks = null;
this.xTickSize = 0;
this.yTickSize = 0;
},
setYConstraint: function(iUp, iDown, iTickSize) {
this.topConstraint = iUp;
this.bottomConstraint = iDown;
this.minY = this.initPageY - iUp;
this.maxY = this.initPageY + iDown;
if (iTickSize) { this.setYTicks(this.initPageY, iTickSize); }
this.constrainY = true;
},
resetConstraints: function() {
if (this.initPageX || this.initPageX === 0) {
var dx = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0,
dy = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;
this.setInitPosition(dx, dy);
} else {
this.setInitPosition();
}
if (this.constrainX) {
this.setXConstraint( this.leftConstraint,
this.rightConstraint,
this.xTickSize        );
}
if (this.constrainY) {
this.setYConstraint( this.topConstraint,
this.bottomConstraint,
this.yTickSize         );
}
},
getTick: function(val, tickArray) {
if (!tickArray) {
return val;
} else if (tickArray[0] >= val) {
return tickArray[0];
} else {
var i, len, next, diff1, diff2;
for (i=0, len=tickArray.length; i<len; ++i) {
next = i + 1;
if (tickArray[next] && tickArray[next] >= val) {
diff1 = val - tickArray[i];
diff2 = tickArray[next] - val;
return (diff2 > diff1) ? tickArray[i] : tickArray[next];
}
}
return tickArray[tickArray.length - 1];
}
},
toString: function() {
return ("DragDrop " + this.id);
}
});
Ext.define('Ext.dd.DD', {
extend:  Ext.dd.DragDrop ,
constructor: function(id, sGroup, config) {
if (id) {
this.init(id, sGroup, config);
}
},
scroll: true,
autoOffset: function(iPageX, iPageY) {
var x = iPageX - this.startPageX,
y = iPageY - this.startPageY;
this.setDelta(x, y);
},
setDelta: function(iDeltaX, iDeltaY) {
this.deltaX = iDeltaX;
this.deltaY = iDeltaY;
},
setDragElPos: function(iPageX, iPageY) {
var el = this.getDragEl();
this.alignElWithMouse(el, iPageX, iPageY);
},
alignElWithMouse: function(el, iPageX, iPageY) {
var oCoord = this.getTargetCoord(iPageX, iPageY),
fly = el.dom ? el : Ext.fly(el, '_dd'),
elSize = fly.getSize(),
EL = Ext.Element,
vpSize,
aCoord,
newLeft,
newTop;
if (!this.deltaSetXY) {
vpSize = this.cachedViewportSize = { width: EL.getDocumentWidth(), height: EL.getDocumentHeight() };
aCoord = [
Math.max(0, Math.min(oCoord.x, vpSize.width - elSize.width)),
Math.max(0, Math.min(oCoord.y, vpSize.height - elSize.height))
];
fly.setXY(aCoord);
newLeft = this.getLocalX(fly);
newTop  = fly.getLocalY();
this.deltaSetXY = [newLeft - oCoord.x, newTop - oCoord.y];
} else {
vpSize = this.cachedViewportSize;
this.setLocalXY(
fly,
Math.max(0, Math.min(oCoord.x + this.deltaSetXY[0], vpSize.width - elSize.width)),
Math.max(0, Math.min(oCoord.y + this.deltaSetXY[1], vpSize.height - elSize.height))
);
}
this.cachePosition(oCoord.x, oCoord.y);
this.autoScroll(oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
return oCoord;
},
cachePosition: function(iPageX, iPageY) {
if (iPageX) {
this.lastPageX = iPageX;
this.lastPageY = iPageY;
} else {
var aCoord = Ext.Element.getXY(this.getEl());
this.lastPageX = aCoord[0];
this.lastPageY = aCoord[1];
}
},
autoScroll: function(x, y, h, w) {
if (this.scroll) {
var clientH = Ext.Element.getViewHeight(),
clientW = Ext.Element.getViewWidth(),
st = this.DDMInstance.getScrollTop(),
sl = this.DDMInstance.getScrollLeft(),
bot = h + y,
right = w + x,
toBot = (clientH + st - y - this.deltaY),
toRight = (clientW + sl - x - this.deltaX),
thresh = 40,
scrAmt = (document.all) ? 80 : 30;
if ( bot > clientH && toBot < thresh ) {
window.scrollTo(sl, st + scrAmt);
}
if ( y < st && st > 0 && y - st < thresh ) {
window.scrollTo(sl, st - scrAmt);
}
if ( right > clientW && toRight < thresh ) {
window.scrollTo(sl + scrAmt, st);
}
if ( x < sl && sl > 0 && x - sl < thresh ) {
window.scrollTo(sl - scrAmt, st);
}
}
},
getTargetCoord: function(iPageX, iPageY) {
var x = iPageX - this.deltaX,
y = iPageY - this.deltaY;
if (this.constrainX) {
if (x < this.minX) {
x = this.minX;
}
if (x > this.maxX) {
x = this.maxX;
}
}
if (this.constrainY) {
if (y < this.minY) {
y = this.minY;
}
if (y > this.maxY) {
y = this.maxY;
}
}
x = this.getTick(x, this.xTicks);
y = this.getTick(y, this.yTicks);
return {x: x, y: y};
},
applyConfig: function() {
this.callParent();
this.scroll = (this.config.scroll !== false);
},
b4MouseDown: function(e) {
this.autoOffset(e.getPageX(), e.getPageY());
},
b4Drag: function(e) {
this.setDragElPos(e.getPageX(), e.getPageY());
},
toString: function() {
return ("DD " + this.id);
},
getLocalX: function(el) {
return el.getLocalX();
},
setLocalXY: function(el, x, y) {
el.setLocalXY(x, y);
}
});
Ext.define('Ext.dd.DDProxy', {
extend:  Ext.dd.DD ,
statics: {
dragElId: "ygddfdiv"
},
constructor: function(id, sGroup, config) {
if (id) {
this.init(id, sGroup, config);
this.initFrame();
}
},
resizeFrame: true,
centerFrame: false,
createFrame: function() {
var self = this,
body = document.body,
div,
s;
if (!body || !body.firstChild) {
setTimeout( function() { self.createFrame(); }, 50 );
return;
}
div = this.getDragEl();
if (!div) {
div    = document.createElement("div");
div.id = this.dragElId;
div.setAttribute('role', 'presentation');
s  = div.style;
s.position   = "absolute";
s.visibility = "hidden";
s.cursor     = "move";
s.border     = "2px solid #aaa";
s.zIndex     = 999;
body.insertBefore(div, body.firstChild);
}
},
initFrame: function() {
this.createFrame();
},
applyConfig: function() {
this.callParent();
this.resizeFrame = (this.config.resizeFrame !== false);
this.centerFrame = (this.config.centerFrame);
this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId);
},
showFrame: function(iPageX, iPageY) {
var el = this.getEl(),
dragEl = this.getDragEl(),
s = dragEl.style;
this._resizeProxy();
if (this.centerFrame) {
this.setDelta( Math.round(parseInt(s.width,  10)/2),
Math.round(parseInt(s.height, 10)/2) );
}
this.setDragElPos(iPageX, iPageY);
Ext.fly(dragEl).show();
},
_resizeProxy: function() {
if (this.resizeFrame) {
var el = this.getEl();
Ext.fly(this.getDragEl()).setSize(el.offsetWidth, el.offsetHeight);
}
},
b4MouseDown: function(e) {
var x = e.getPageX(),
y = e.getPageY();
this.autoOffset(x, y);
this.setDragElPos(x, y);
},
b4StartDrag: function(x, y) {
this.showFrame(x, y);
},
b4EndDrag: function(e) {
Ext.fly(this.getDragEl()).hide();
},
endDrag: function(e) {
var lel = this.getEl(),
del = this.getDragEl();
del.style.visibility = "";
this.beforeMove();
lel.style.visibility = "hidden";
Ext.dd.DDM.moveToEl(lel, del);
del.style.visibility = "hidden";
lel.style.visibility = "";
this.afterDrag();
},
beforeMove : function(){
},
afterDrag : function(){
},
toString: function() {
return ("DDProxy " + this.id);
}
});
Ext.define('Ext.dd.StatusProxy', {
extend:  Ext.Component ,
animRepair: false,
childEls: [
'ghost'
],
renderTpl: [
'<div class="' + Ext.baseCSSPrefix + 'dd-drop-icon" role="presentation"></div>' +
'<div id="{id}-ghost" class="' + Ext.baseCSSPrefix + 'dd-drag-ghost" role="presentation"></div>'
],
repairCls: Ext.baseCSSPrefix + 'dd-drag-repair',
ariaRole: 'presentation',
constructor: function(config) {
var me = this;
config = config || {};
Ext.apply(me, {
hideMode: 'visibility',
hidden: true,
floating: true,
id: me.id || Ext.id(),
cls: Ext.baseCSSPrefix + 'dd-drag-proxy ' + this.dropNotAllowed,
shadow: config.shadow || false,
renderTo: Ext.getDetachedBody()
});
me.callParent(arguments);
this.dropStatus = this.dropNotAllowed;
},
dropAllowed : Ext.baseCSSPrefix + 'dd-drop-ok',
dropNotAllowed : Ext.baseCSSPrefix + 'dd-drop-nodrop',
setStatus : function(cssClass){
cssClass = cssClass || this.dropNotAllowed;
if (this.dropStatus != cssClass) {
this.el.replaceCls(this.dropStatus, cssClass);
this.dropStatus = cssClass;
}
},
reset : function(clearGhost){
var me = this,
clsPrefix = Ext.baseCSSPrefix + 'dd-drag-proxy ';
me.el.replaceCls(clsPrefix + me.dropAllowed, clsPrefix + me.dropNotAllowed);
me.dropStatus = me.dropNotAllowed;
if (clearGhost) {
me.ghost.update('');
}
},
update : function(html){
if (typeof html == "string") {
this.ghost.update(html);
} else {
this.ghost.update("");
html.style.margin = "0";
this.ghost.dom.appendChild(html);
}
var el = this.ghost.dom.firstChild;
if (el) {
Ext.fly(el).setStyle('float', 'none');
}
},
getGhost : function(){
return this.ghost;
},
hide : function(clear) {
this.callParent();
if (clear) {
this.reset(true);
}
},
stop : function(){
if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) {
this.anim.stop();
}
},
sync : function(){
this.el.sync();
},
repair : function(xy, callback, scope) {
var me = this;
me.callback = callback;
me.scope = scope;
if (xy && me.animRepair !== false) {
me.el.addCls(me.repairCls);
me.el.hideUnders(true);
me.anim = me.el.animate({
duration: me.repairDuration || 500,
easing: 'ease-out',
to: {
x: xy[0],
y: xy[1]
},
stopAnimation: true,
callback: me.afterRepair,
scope: me
});
} else {
me.afterRepair();
}
},
afterRepair : function() {
var me = this;
me.hide(true);
me.el.removeCls(me.repairCls);
if (typeof me.callback == "function") {
me.callback.call(me.scope || me);
}
delete me.callback;
delete me.scope;
}
});
Ext.define('Ext.dd.DragSource', {
extend:  Ext.dd.DDProxy ,
dropAllowed : Ext.baseCSSPrefix + 'dd-drop-ok',
dropNotAllowed : Ext.baseCSSPrefix + 'dd-drop-nodrop',
animRepair: true,
repairHighlightColor: 'c3daf9',
constructor: function(el, config) {
this.el = Ext.get(el);
if(!this.dragData){
this.dragData = {};
}
Ext.apply(this, config);
if(!this.proxy){
this.proxy = new Ext.dd.StatusProxy({
id: this.el.id + '-drag-status-proxy',
animRepair: this.animRepair
});
}
this.callParent([this.el.dom, this.ddGroup || this.group,
{dragElId : this.proxy.id, resizeFrame: false, isTarget: false, scroll: this.scroll === true}]);
this.dragging = false;
},
getDragData : function(e){
return this.dragData;
},
onDragEnter : function(e, id){
var target = Ext.dd.DragDropManager.getDDById(id),
status;
this.cachedTarget = target;
if (this.beforeDragEnter(target, e, id) !== false) {
if (target.isNotifyTarget) {
status = target.notifyEnter(this, e, this.dragData);
this.proxy.setStatus(status);
} else {
this.proxy.setStatus(this.dropAllowed);
}
if (this.afterDragEnter) {
this.afterDragEnter(target, e, id);
}
}
},
beforeDragEnter: function(target, e, id) {
return true;
},
onDragOver: function(e, id) {
var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id),
status;
if (this.beforeDragOver(target, e, id) !== false) {
if(target.isNotifyTarget){
status = target.notifyOver(this, e, this.dragData);
this.proxy.setStatus(status);
}
if (this.afterDragOver) {
this.afterDragOver(target, e, id);
}
}
},
beforeDragOver: function(target, e, id) {
return true;
},
onDragOut: function(e, id) {
var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id);
if (this.beforeDragOut(target, e, id) !== false) {
if (target.isNotifyTarget) {
target.notifyOut(this, e, this.dragData);
}
this.proxy.reset();
if (this.afterDragOut) {
this.afterDragOut(target, e, id);
}
}
this.cachedTarget = null;
},
beforeDragOut: function(target, e, id){
return true;
},
onDragDrop: function(e, id){
var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id);
if (this.beforeDragDrop(target, e, id) !== false) {
if (target.isNotifyTarget) {
if (target.notifyDrop(this, e, this.dragData) !== false) { 
this.onValidDrop(target, e, id);
} else {
this.onInvalidDrop(target, e, id);
}
} else {
this.onValidDrop(target, e, id);
}
if (this.afterDragDrop) {
this.afterDragDrop(target, e, id);
}
}
delete this.cachedTarget;
},
beforeDragDrop: function(target, e, id){
return true;
},
onValidDrop: function(target, e, id){
this.hideProxy();
if(this.afterValidDrop){
this.afterValidDrop(target, e, id);
}
},
getRepairXY: function(e, data){
return this.el.getXY();
},
onInvalidDrop: function(target, e, id) {
var me = this;
if (!e) {
e = target;
target = null;
id = e.getTarget().id;
}
if (me.beforeInvalidDrop(target, e, id) !== false) {
if (me.cachedTarget) {
if(me.cachedTarget.isNotifyTarget){
me.cachedTarget.notifyOut(me, e, me.dragData);
}
me.cacheTarget = null;
}
me.proxy.repair(me.getRepairXY(e, me.dragData), me.afterRepair, me);
if (me.afterInvalidDrop) {
me.afterInvalidDrop(e, id);
}
}
},
afterRepair: function() {
var me = this;
if (Ext.enableFx) {
me.el.highlight(me.repairHighlightColor);
}
me.dragging = false;
},
beforeInvalidDrop: function(target, e, id) {
return true;
},
handleMouseDown: function(e) {
if (this.dragging) {
return;
}
var data = this.getDragData(e);
if (data && this.onBeforeDrag(data, e) !== false) {
this.dragData = data;
this.proxy.stop();
this.callParent(arguments);
}
},
onBeforeDrag: function(data, e){
return true;
},
onStartDrag: Ext.emptyFn,
alignElWithMouse: function() {
this.proxy.ensureAttachedToBody(true);
return this.callParent(arguments);
},
startDrag: function(x, y) {
this.proxy.reset();
this.proxy.hidden = false;
this.dragging = true;
this.proxy.update("");
this.onInitDrag(x, y);
this.proxy.show();
},
onInitDrag: function(x, y) {
var clone = this.el.dom.cloneNode(true);
clone.id = Ext.id(); 
this.proxy.update(clone);
this.onStartDrag(x, y);
return true;
},
getProxy: function() {
return this.proxy;
},
hideProxy: function() {
this.proxy.hide();
this.proxy.reset(true);
this.dragging = false;
},
triggerCacheRefresh: function() {
Ext.dd.DDM.refreshCache(this.groups);
},
b4EndDrag: function(e) {
},
endDrag : function(e){
this.onEndDrag(this.dragData, e);
},
onEndDrag : function(data, e){
},
autoOffset : function(x, y) {
this.setDelta(-12, -20);
},
destroy: function(){
this.callParent();
Ext.destroy(this.proxy);
}
});
Ext.define('Ext.util.Memento', (function () {
function captureOne (src, target, prop, prefix) {
src[prefix ? prefix + prop : prop] = target[prop];
}
function removeOne (src, target, prop) {
delete src[prop];
}
function restoreOne (src, target, prop, prefix) {
var name = prefix ? prefix + prop : prop,
value = src[name];
if (value || src.hasOwnProperty(name)) {
restoreValue(target, prop, value);
}
}
function restoreValue (target, prop, value) {
if (Ext.isDefined(value)) {
target[prop] = value;
} else {
delete target[prop];
}
}
function doMany (doOne, src, target, props, prefix) {
if (src) {
if (Ext.isArray(props)) {
var p, pLen = props.length;
for (p = 0; p < pLen; p++) {
doOne(src, target, props[p], prefix);
}
} else {
doOne(src, target, props, prefix);
}
}
}
return {
data: null,
target: null,
constructor: function (target, props) {
if (target) {
this.target = target;
if (props) {
this.capture(props);
}
}
},
capture: function (props, target, prefix) {
var me = this;
doMany(captureOne, me.data || (me.data = {}), target || me.target, props, prefix);
},
remove: function (props) {
doMany(removeOne, this.data, null, props);
},
restore: function (props, clear, target, prefix) {
doMany(restoreOne, this.data, target || this.target, props, prefix);
if (clear !== false) {
this.remove(props);
}
},
restoreAll: function (clear, target) {
var me   = this,
t    = target || this.target,
data = me.data,
prop;
for (prop in data) {
if (data.hasOwnProperty(prop)) {
restoreValue(t, prop, data[prop]);
}
}
if (clear !== false) {
delete me.data;
}
}
};
}()));
Ext.chart = Ext.chart || {};
Ext.define('Ext.container.Monitor', {
target: null,
selector: '',
scope: null,
addHandler: null,
removeHandler: null,
disabled: 0,
constructor: function(config){
Ext.apply(this, config);
},
bind: function(target){
var me = this;
me.target = target;
target.on('beforedestroy', me.disable, me);
me.onContainerAdd(target);
},
unbind: function() {
var me = this,
target = me.target;
if (target) {
target.un('beforedestroy', me.disable, me);
}
me.items = null;
},
disable: function(){
++this.disabled;    
},
enable: function(){
if (this.disabled > 0) {
--this.disabled;
}
},
handleAdd: function(ct, comp) {
if (!this.disabled) {
if (comp.is(this.selector)) {
this.onItemAdd(comp.ownerCt, comp);
}
if (comp.isQueryable) {
this.onContainerAdd(comp);
}
}
},
onItemAdd: function(ct, comp){
var me = this,
items = me.items,
handler = me.addHandler;
if (!me.disabled) {
if (handler) {
handler.call(me.scope || comp, comp);
}
if (items) {
items.add(comp);
}
}
},
onItemRemove: function(ct, comp){
var me = this,
items = me.items,
handler = me.removeHandler;
if (!me.disabled) {
if (handler) {
handler.call(me.scope || comp, comp);
}
if (items) {
items.remove(comp);
}
}
},
onContainerAdd: function(ct, preventChildren) {
var me = this,
items, len,
handleAdd = me.handleAdd,
handleRemove = me.handleRemove,
i, comp;
if (ct.isContainer) {
ct.on('add', handleAdd, me);
ct.on('dockedadd', handleAdd, me);
ct.on('remove', handleRemove, me);
ct.on('dockedremove', handleRemove, me);
}
if (preventChildren !== true) {
items = ct.query(me.selector);
for (i = 0, len = items.length; i < len; ++i) {
comp = items[i];
me.onItemAdd(comp.ownerCt, comp);
}
}
items = ct.query('>container');
for (i = 0, len = items.length; i < len; ++i) {
me.onContainerAdd(items[i], true);
}
},
handleRemove: function(ct, comp) {
var me = this;
if (!me.disabled) {
if (comp.is(me.selector)) {
me.onItemRemove(ct, comp);
}
if (comp.isQueryable) {
me.onContainerRemove(ct, comp);
}
}
},
onContainerRemove: function(ct, comp){
var me = this,
items, i, len, item;
if (!comp.isDestroyed && !comp.destroying && comp.isContainer) {
me.removeCtListeners(comp);
items = comp.query(me.selector);
for (i = 0, len = items.length; i < len; ++i) {
item = items[i];
me.onItemRemove(item.ownerCt, item);
}
items = comp.query('container');
for (i = 0, len = items.length; i < len; ++i) {
me.removeCtListeners(items[i]);
}
} else {
me.invalidateItems();
}
},
removeCtListeners: function(comp){
var me = this;
comp.un('add', me.handleAdd, me);
comp.un('dockedadd', me.handleAdd, me);
comp.un('remove', me.handleRemove, me);
comp.un('dockedremove', me.handleRemove, me);
},
getItems: function(){
var me = this,
items = me.items;
if (!items) {
items = me.items = new Ext.util.MixedCollection();
items.addAll(me.target.query(me.selector));
}
return items;
},
invalidateItems: function(){
this.items = null;
}
});
Ext.define('Ext.data.IdGenerator', {
isGenerator: true,
constructor: function(config) {
var me = this;
Ext.apply(me, config);
if (me.id) {
Ext.data.IdGenerator.all[me.id] = me;
}
},
getRecId: function (rec) {
return rec.modelName + '-' + rec.internalId;
},
statics: {
all: {},
get: function (config) {
var generator,
id,
type;
if (typeof config == 'string') {
id = type = config;
config = null;
} else if (config.isGenerator) {
return config;
} else {
id = config.id || config.type;
type = config.type;
}
generator = this.all[id];
if (!generator) {
generator = Ext.create('idgen.' + type, config);
}
return generator;
}
}
});
Ext.define('Ext.data.SortTypes', {
singleton: true,
none : Ext.identityFn,
stripTagsRE : /<\/?[^>]+>/gi,
asText : function(s) {
return String(s).replace(this.stripTagsRE, "");
},
asUCText : function(s) {
return String(s).toUpperCase().replace(this.stripTagsRE, "");
},
asUCString : function(s) {
return String(s).toUpperCase();
},
asDate : function(s) {
if(!s){
return 0;
}
if(Ext.isDate(s)){
return s.getTime();
}
return Date.parse(String(s));
},
asFloat : function(s) {
var val = parseFloat(String(s).replace(/,/g, ""));
return isNaN(val) ? 0 : val;
},
asInt : function(s) {
var val = parseInt(String(s).replace(/,/g, ""), 10);
return isNaN(val) ? 0 : val;
}
});
Ext.define('Ext.data.Types', {
singleton: true 
}, function() {
var st = Ext.data.SortTypes;
Ext.apply(Ext.data.Types, {
stripRe: /[\$,%]/g,
AUTO: {
sortType: st.none,
type: 'auto'
},
STRING: {
convert: function(v) {
var defaultValue = this.useNull ? null : '';
return (v === undefined || v === null) ? defaultValue : String(v);
},
sortType: st.asUCString,
type: 'string'
},
INT: {
convert: function(v) {
if (typeof v == 'number') {
return parseInt(v);
}
return v !== undefined && v !== null && v !== '' ?
parseInt(String(v).replace(Ext.data.Types.stripRe, ''), 10) : (this.useNull ? null : 0);
},
sortType: st.none,
type: 'int'
},
FLOAT: {
convert: function(v) {
if (typeof v === 'number') {
return v;
}
return v !== undefined && v !== null && v !== '' ?
parseFloat(String(v).replace(Ext.data.Types.stripRe, ''), 10) : (this.useNull ? null : 0);
},
sortType: st.none,
type: 'float'
},
BOOL: {
convert: function(v) {
if (typeof v === 'boolean') {
return v;
}
if (this.useNull && (v === undefined || v === null || v === '')) {
return null;
}
return v === 'true' || v == 1;
},
sortType: st.none,
type: 'bool'
},
DATE: {
convert: function(v) {
var df = this.dateReadFormat || this.dateFormat,
parsed;
if (!v) {
return null;
}
if (v instanceof Date) {
return v;
}
if (df) {
return Ext.Date.parse(v, df);
}
parsed = Date.parse(v);
return parsed ? new Date(parsed) : null;
},
sortType: st.asDate,
type: 'date'
}
});
Ext.apply(Ext.data.Types, {
BOOLEAN: this.BOOL,
INTEGER: this.INT,
NUMBER: this.FLOAT
});
});
Ext.define('Ext.data.Field', {
alias: 'data.field',
isField: true,
constructor : function(config) {
var me = this,
types = Ext.data.Types,
st;
if (Ext.isString(config)) {
config = {name: config};
}
Ext.apply(me, config);
st = me.sortType;
if (me.type) {
if (Ext.isString(me.type)) {
me.type = types[me.type.toUpperCase()] || types.AUTO;
}
} else {
me.type = types.AUTO;
}
if (Ext.isString(st)) {
me.sortType = Ext.data.SortTypes[st];
} else if(Ext.isEmpty(st)) {
me.sortType = me.type.sortType;
}
if (!config.hasOwnProperty('convert')) {
me.convert = me.type.convert; 
} else if (!me.convert && me.type.convert && !config.hasOwnProperty('defaultValue')) {
me.defaultValue = me.type.convert(me.defaultValue);
}
if (config.convert) {
me.hasCustomConvert = true;
}
},
dateFormat: null,
dateReadFormat: null,
dateWriteFormat: null,
useNull: false,
defaultValue: "",
mapping: null,
sortType : null,
sortDir : "ASC",
allowBlank : true,
persist: true
});
Ext.define('Ext.data.Errors', {
extend:  Ext.util.MixedCollection ,
isValid: function() {
return this.length === 0;
},
getByField: function(fieldName) {
var errors = [],
error, i;
for (i = 0; i < this.length; i++) {
error = this.items[i];
if (error.field == fieldName) {
errors.push(error);
}
}
return errors;
}
});
Ext.define('Ext.data.validations', {
singleton: true,
presenceMessage: 'must be present',
lengthMessage: 'is the wrong length',
formatMessage: 'is the wrong format',
inclusionMessage: 'is not included in the list of acceptable values',
exclusionMessage: 'is not an acceptable value',
emailMessage: 'is not a valid email address',
emailRe: /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/,
presence: function(config, value) {
if (arguments.length === 1) {
value = config;
}
return !!value || value === 0 || value === false;
},
length: function(config, value) {
if (value === undefined || value === null) {
return false;
}
var length = value.length,
min    = config.min,
max    = config.max;
if ((min && length < min) || (max && length > max)) {
return false;
} else {
return true;
}
},
email: function(config, email) {
return Ext.data.validations.emailRe.test(email);
},
format: function(config, value) {
return !!(config.matcher && config.matcher.test(value));
},
inclusion: function(config, value) {
return config.list && Ext.Array.indexOf(config.list,value) != -1;
},
exclusion: function(config, value) {
return config.list && Ext.Array.indexOf(config.list,value) == -1;
}
});
Ext.define('Ext.data.Model', {
alternateClassName: 'Ext.data.Record',
mixins: {
observable:  Ext.util.Observable 
},
compareConvertFields: function(f1, f2) {
var f1SpecialConvert = f1.convert && f1.type && f1.convert !== f1.type.convert,
f2SpecialConvert = f2.convert && f2.type && f2.convert !== f2.type.convert;
if (f1SpecialConvert && !f2SpecialConvert) {
return 1;
}
if (!f1SpecialConvert && f2SpecialConvert) {
return -1;
}
return 0;
},
itemNameFn: function(item) {
return item.name;
},
onClassExtended: function(cls, data, hooks) {
var onBeforeClassCreated = hooks.onBeforeCreated;
hooks.onBeforeCreated = function(cls, data) {
var me = this,
name = Ext.getClassName(cls),
prototype = cls.prototype,
superCls = cls.prototype.superclass,
validations = data.validations || [],
fields = data.fields || [],
field,
associationsConfigs = data.associations || [],
addAssociations = function(items, type) {
var i = 0,
len,
item;
if (items) {
items = Ext.Array.from(items);
for (len = items.length; i < len; ++i) {
item = items[i];
if (!Ext.isObject(item)) {
item = {model: item};
}
item.type = type;
associationsConfigs.push(item);
}
}
},
idgen = data.idgen,
fieldsMixedCollection = new Ext.util.MixedCollection(false, prototype.itemNameFn),
associationsMixedCollection = new Ext.util.MixedCollection(false, prototype.itemNameFn),
superValidations = superCls.validations,
superFields = superCls.fields,
superAssociations = superCls.associations,
associationConfig, i, ln,
dependencies = [],
idProperty = 'idProperty' in data ? data.idProperty : prototype.idProperty,
idField = idProperty ? (idProperty.isField ? idProperty : new Ext.data.Field(idProperty)) : null,
idFieldDefined = false,
onFieldAddReplace = function(arg0, arg1, arg2) {
var newField,
pos;
if (fieldsMixedCollection.events.add.firing) {
pos = arg0;
newField  = arg1;
} else {
newField = arg2;
pos = arg1.originalIndex;
}
newField.originalIndex = pos;
if (idField && ((newField.mapping && (newField.mapping === idField.mapping)) || (newField.name === idField.name))) {
prototype.idField = newField;
idFieldDefined = true;
newField.defaultValue = undefined;
}
},
clsProxy = data.proxy,
fieldConvertSortFn = function() {
fieldsMixedCollection.sortBy(prototype.compareConvertFields);
};
cls.modelName = name;
prototype.modelName = name;
if (superValidations) {
validations = superValidations.concat(validations);
}
data.validations = validations;
if (superFields) {
fields = superFields.items.concat(fields);
}
fieldsMixedCollection.on({
add:     onFieldAddReplace,
replace: onFieldAddReplace
});  
for (i = 0, ln = fields.length; i < ln; ++i) {
field = fields[i];
fieldsMixedCollection.add(field.isField ? field : new Ext.data.Field(field));
}
if (idField && !idFieldDefined) {
prototype.idField = idField;
idField.defaultValue = undefined;
fieldsMixedCollection.add(idField);
}
fieldConvertSortFn();
fieldsMixedCollection.on({
add:     fieldConvertSortFn,
replace: fieldConvertSortFn
});
data.fields = fieldsMixedCollection;
if (idgen) {
data.idgen = Ext.data.IdGenerator.get(idgen);
}
addAssociations(data.belongsTo, 'belongsTo');
delete data.belongsTo;
addAssociations(data.hasMany, 'hasMany');
delete data.hasMany;
addAssociations(data.hasOne, 'hasOne');
delete data.hasOne;
if (superAssociations) {
associationsConfigs = superAssociations.items.concat(associationsConfigs);
}
for (i = 0, ln = associationsConfigs.length; i < ln; ++i) {
dependencies.push('association.' + associationsConfigs[i].type.toLowerCase());
}
if (clsProxy) {
if (!clsProxy.isProxy) {
dependencies.push('proxy.' + (clsProxy.type || clsProxy));
}
}
else if (!cls.prototype.proxy) {
cls.prototype.proxy = cls.prototype.defaultProxyType;
dependencies.push('proxy.' + cls.prototype.defaultProxyType);
}
Ext.require(dependencies, function() {
Ext.ModelManager.registerType(name, cls);
for (i = 0, ln = associationsConfigs.length; i < ln; ++i) {
associationConfig = associationsConfigs[i];
if (associationConfig.isAssociation) {
associationConfig = Ext.applyIf({
ownerModel: name,
associatedModel: associationConfig.model
}, associationConfig.initialConfig);
} else {
Ext.apply(associationConfig, {
ownerModel: name,
associatedModel: associationConfig.model
});
}
if (Ext.ModelManager.getModel(associationConfig.model) === undefined) {
Ext.ModelManager.registerDeferredAssociation(associationConfig);
} else {
associationsMixedCollection.add(Ext.data.association.Association.create(associationConfig));
}
}
data.associations = associationsMixedCollection;
onBeforeClassCreated.call(me, cls, data, hooks);
if (clsProxy && clsProxy.isProxy) {
cls.setProxy(clsProxy);
}
Ext.ModelManager.onModelDefined(cls);
});
};
},
inheritableStatics: {
setProxy: function(proxy) {
if (!proxy.isProxy) {
if (typeof proxy == "string") {
proxy = {
type: proxy
};
}
proxy = Ext.createByAlias("proxy." + proxy.type, proxy);
}
proxy.setModel(this);
this.proxy = this.prototype.proxy = proxy;
return proxy;
},
getProxy: function() {
var proxy = this.proxy;
if (!proxy) {
proxy = this.prototype.proxy;
if (proxy.isProxy) {
proxy = proxy.clone()
}
return this.setProxy(proxy);
}
return proxy;
},
setFields: function(fields, idProperty, clientIdProperty) {
var me = this,
newField,
idField,
idFieldDefined = false,
proto = me.prototype,
prototypeFields = proto.fields,
superFields = proto.superclass.fields,
len,
i;
if (idProperty) {
proto.idProperty = idProperty;
idField = idProperty.isField ? idProperty : new Ext.data.Field(idProperty);
}
if (clientIdProperty) {
proto.clientIdProperty = clientIdProperty;
}
if (prototypeFields) {
prototypeFields.clear();
}
else {
prototypeFields = me.prototype.fields = new Ext.util.MixedCollection(false, function(field) {
return field.name;
});
}
if (superFields) {
fields = superFields.items.concat(fields);
}
for (i = 0, len = fields.length; i < len; i++) {
newField = new Ext.data.Field(fields[i]);
if (idField && ((newField.mapping && (newField.mapping === idField.mapping)) || (newField.name === idField.name))) {
idFieldDefined = true;
newField.defaultValue = undefined;
}
prototypeFields.add(newField);
}
if (idField && !idFieldDefined) {
idField.defaultValue = undefined;
prototypeFields.add(idField);
}
me.fields = prototypeFields;
return prototypeFields;
},
getFields: function() {
return this.prototype.fields.items;
},
load: function(id, config) {
config = Ext.apply({}, config);
config = Ext.applyIf(config, {
action: 'read',
id    : id
});
var operation  = new Ext.data.Operation(config),
scope      = config.scope || this,
callback;
callback = function(operation) {
var record = null,
success = operation.wasSuccessful();
if (success) {
record = operation.getRecords()[0];
if (!record.hasId()) {
record.setId(id);
}
Ext.callback(config.success, scope, [record, operation]);
} else {
Ext.callback(config.failure, scope, [record, operation]);
}
Ext.callback(config.callback, scope, [record, operation, success]);
};
this.getProxy().read(operation, callback, this);
}
},
statics: {
PREFIX : '',
AUTO_ID: 0,
EDIT   : 'edit',
REJECT : 'reject',
COMMIT : 'commit',
id: function(rec) {
rec.phantom = true;
return rec.internalId = ++this.AUTO_ID;
}
},
idgen: {
isGenerator: true,
type: 'default',
generate: function () {
return null;
},
getRecId: function (rec) {
return rec.modelName + '-' + rec.internalId;
}
},
editing : false,
dirty : false,
persistenceProperty: 'data',
evented: false,
isModel: true,
phantom : false,
idProperty: 'id',
clientIdProperty: null,
defaultProxyType: 'ajax',
emptyData: [],
constructor: function(data, id, raw, convertedData) {
var me = this,
passedId = (id || id === 0),
hasId,
fields,
length,
field,
name,
value,
newId,
persistenceProperty,
idProperty = me.idProperty,
idField = me.idField,
i;
me.raw = raw || data; 
me.modified = {};
persistenceProperty = me[me.persistenceProperty] = convertedData || {};
me.data = me[me.persistenceProperty];
me.mixins.observable.constructor.call(me);
if (!convertedData) {
if (data) {
if (!passedId && idProperty) {
id = data[idProperty];
hasId = (id || id === 0);
}
}
else {
data = me.emptyData;
} 
fields = me.fields.items;
length = fields.length;
i = 0;
if (Ext.isArray(data)) {
for (; i < length; i++) {
field = fields[i];
name  = field.name;
value = data[field.originalIndex];
if (value === undefined) {
value = field.defaultValue;
}
if (field.convert) {
value = field.convert(value, me);
}
if (value !== undefined) {
persistenceProperty[name] = value;
}
}
} else {
for (; i < length; i++) {
field = fields[i];
name  = field.name;
value = data[name];
if (value === undefined) {
value = field.defaultValue;
}
if (field.convert) {
value = field.convert(value, me);
}
if (value !== undefined) {
persistenceProperty[name] = value;
}
}
}
}
me.stores = [];
if (passedId) {
hasId = true;
persistenceProperty[idProperty] = idField && idField.convert ? idField.convert(id) : id;
}
else if (!hasId) {
newId = me.idgen.generate();
if (newId != null) {
me.preventInternalUpdate = true;
me.setId(newId);
delete me.preventInternalUpdate;
}
}
me.internalId = hasId ? id : Ext.data.Model.id(me);
if (typeof me.init == 'function') {
me.init();
}
me.id = me.idgen.getRecId(me);
},
get: function(field) {
return this[this.persistenceProperty][field];
},
_singleProp: {},
set: function (fieldName, newValue) {
var me = this,
data = me[me.persistenceProperty],
fields = me.fields,
modified = me.modified,
single = (typeof fieldName == 'string'),
currentValue, field, idChanged, key, modifiedFieldNames, name, oldId,
newId, value, values;
if (single) {
values = me._singleProp;
values[fieldName] = newValue;
} else {
values = fieldName;
}
for (name in values) {
value = values[name];
if (fields && (field = fields.get(name)) && field.convert) {
value = field.convert(value, me);
}
currentValue = data[name];
if (me.isEqual(currentValue, value)) {
continue; 
}
data[name] = value;
(modifiedFieldNames || (modifiedFieldNames = [])).push(name);
if (field && field.persist) {
if (modified.hasOwnProperty(name)) {
if (me.isEqual(modified[name], value)) {
delete modified[name];
me.dirty = false;
for (key in modified) {
if (modified.hasOwnProperty(key)){
me.dirty = true;
break;
}
}
}
} else {
me.dirty = true;
modified[name] = currentValue;
}
}
if (name == me.idProperty) {
idChanged = true;
oldId = currentValue;
newId = value;
}
}
if (single) {
delete values[fieldName];
}
if (idChanged) {
me.changeId(oldId, newId);
}
if (modifiedFieldNames) {
!me.editing && me.afterEdit(modifiedFieldNames);
return modifiedFieldNames
}
return null;
},
copyFrom: function(sourceRecord) {
var me = this,
fields = me.fields.items,
fieldCount = fields.length,
modifiedFieldNames = [],
field, i = 0,
myData,
sourceData,
idProperty = me.idProperty,
name,
value;
if (sourceRecord) {
myData = me[me.persistenceProperty];
sourceData = sourceRecord[sourceRecord.persistenceProperty];
for (; i < fieldCount; i++) {
field = fields[i];
name = field.name;
if (name != idProperty) {
value = sourceData[name];
if (value !== undefined && !me.isEqual(myData[name], value)) {
myData[name] = value;
modifiedFieldNames.push(name);
}
}
}
if (me.phantom && !sourceRecord.phantom) {
me.beginEdit();
me.setId(sourceRecord.getId());
me.endEdit(true);
me.commit(true);
}
}
return modifiedFieldNames;
},
isEqual: function(a, b) {
if (a instanceof Date && b instanceof Date) {
return a.getTime() === b.getTime();
}
return a === b;
},
beginEdit : function(){
var me = this,
key,
data,
o;
if (!me.editing) {
me.editing = true;
me.dirtySave = me.dirty;
o = me[me.persistenceProperty];
data = me.dataSave = {};
for (key in o) {
if (o.hasOwnProperty(key)) {
data[key] = o[key];
}
}
o = me.modified;
data = me.modifiedSave = {}; 
for (key in o) {
if (o.hasOwnProperty(key)) {
data[key] = o[key];
}
}
}
},
cancelEdit : function(){
var me = this;
if (me.editing) {
me.editing = false;
me.modified = me.modifiedSave;
me[me.persistenceProperty] = me.dataSave;
me.dirty = me.dirtySave;
me.modifiedSave = me.dataSave = me.dirtySave = null;
}
},
endEdit : function(silent, modifiedFieldNames){
var me = this,
dataSave,
changed;
silent = silent === true;
if (me.editing) {
me.editing = false;
dataSave = me.dataSave;
me.modifiedSave = me.dataSave = me.dirtySave = null;
if (!silent) {
if (!modifiedFieldNames) {
modifiedFieldNames = me.getModifiedFieldNames(dataSave);
}
changed = me.dirty || modifiedFieldNames.length > 0;
if (changed) {
me.afterEdit(modifiedFieldNames);
}
}
}
},
getModifiedFieldNames: function(saved){
var me = this,
data = me[me.persistenceProperty],
modified = [],
key;
saved = saved || me.dataSave;
for (key in data) {
if (data.hasOwnProperty(key)) {
if (!me.isEqual(data[key], saved[key])) {
modified.push(key);
}
}
}
return modified; 
},
getChanges : function(){
var modified = this.modified,
changes  = {},
field;
for (field in modified) {
if (modified.hasOwnProperty(field)){
changes[field] = this.get(field);
}
}
return changes;
},
isModified : function(fieldName) {
return this.modified.hasOwnProperty(fieldName);
},
setDirty : function() {
var me     = this,
fields = me.fields.items,
fLen   = fields.length,
field, name, f;
me.dirty = true;
for (f = 0; f < fLen; f++) {
field = fields[f];
if (field.persist) {
name  = field.name;
me.modified[name] = me.get(name);
}
}
},
reject : function(silent) {
var me = this,
modified = me.modified,
field;
for (field in modified) {
if (modified.hasOwnProperty(field)) {
if (typeof modified[field] != "function") {
me[me.persistenceProperty][field] = modified[field];
}
}
}
me.dirty = false;
me.editing = false;
me.modified = {};
if (silent !== true) {
me.afterReject();
}
},
commit : function(silent, modifiedFieldNames) {
var me = this;
me.phantom = me.dirty = me.editing = false;
me.modified = {};
if (silent !== true) {
me.afterCommit(modifiedFieldNames);
}
},
copy : function(newId) {
var me = this;
return new me.self(me.raw, newId, null, Ext.apply({}, me[me.persistenceProperty]));
},
setProxy: function(proxy) {
if (!proxy.isProxy) {
if (typeof proxy === "string") {
proxy = {
type: proxy
};
}
proxy = Ext.createByAlias("proxy." + proxy.type, proxy);
}
proxy.setModel(this.self);
this.proxy = proxy;
return proxy;
},
getProxy: function() {
return this.hasOwnProperty('proxy') ? this.proxy : this.self.getProxy();
},
validate: function() {
var errors      = new Ext.data.Errors(),
validations = this.validations,
validators  = Ext.data.validations,
length, validation, field, valid, type, i;
if (validations) {
length = validations.length;
for (i = 0; i < length; i++) {
validation = validations[i];
field = validation.field || validation.name;
type  = validation.type;
valid = validators[type](validation, this.get(field));
if (!valid) {
errors.add({
field  : field,
message: validation.message || validators[type + 'Message']
});
}
}
}
return errors;
},
isValid: function(){
return this.validate().isValid();
},
save: function(options) {
options = Ext.apply({}, options);
var me     = this,
action = me.phantom ? 'create' : 'update',
scope  = options.scope || me,
stores = me.stores,
i = 0,
storeCount,
store,
operation,
callback;
Ext.apply(options, {
records: [me],
action : action
});
operation = new Ext.data.Operation(options);
callback = function(operation) {
var success = operation.wasSuccessful();
if (success) {
for(storeCount = stores.length; i < storeCount; i++) {
store = stores[i];
store.fireEvent('write', store, operation);
store.fireEvent('datachanged', store);
}
Ext.callback(options.success, scope, [me, operation]);
}
else {
Ext.callback(options.failure, scope, [me, operation]);
}
Ext.callback(options.callback, scope, [me, operation, success]);
};
me.getProxy()[action](operation, callback, me);
return me;
},
destroy: function(options) {
options = Ext.apply({
records: [this],
action : 'destroy'
}, options);
var me = this,
isNotPhantom = me.phantom !== true,
scope  = options.scope || me,
stores,
i = 0,
storeCount,
store,
args,
operation,
callback;
operation = new Ext.data.Operation(options);
callback = function(operation) {
args = [me, operation];
stores = Ext.Array.clone(me.stores);
if (operation.wasSuccessful()) {
for (storeCount = stores.length; i < storeCount; i++) {
store = stores[i];
if (store.remove) {
store.remove(me, true);
} else {
store.fireEvent('bulkremove', store, [me], [store.indexOf(me)], false);    
}
if (isNotPhantom) {
store.fireEvent('write', store, operation);
}
}
me.clearListeners();
Ext.callback(options.success, scope, args);
} else {
Ext.callback(options.failure, scope, args);
}
Ext.callback(options.callback, scope, args);
};
if (isNotPhantom) {
me.getProxy().destroy(operation, callback, me);
}
else {
operation.complete = operation.success = true;
operation.resultSet = me.getProxy().reader.nullResultSet;
callback(operation);
}
return me;
},
getId: function() {
return this.get(this.idField.name);
},
getObservableId: function() {
return this.id;
},
setId: function(id) {
this.set(this.idProperty, id);
},
changeId: function(oldId, newId) {
var me = this,
hasOldId, hasId, oldInternalId;
if (!me.preventInternalUpdate) { 
hasOldId = me.hasId(oldId);
hasId = me.hasId(newId);
oldInternalId = me.internalId;
me.phantom  = !hasId;
if (hasId !== hasOldId || (hasId && hasOldId)) {
me.internalId = hasId ? newId : Ext.data.Model.id(me);
}
me.fireEvent('idchanged', me, oldId, newId, oldInternalId);
me.callStore('onIdChanged', oldId, newId, oldInternalId);
}
},
hasId: function(id) {
if (arguments.length === 0) {
id = this.getId();
}
return !!(id || id === 0);
},
join : function(store) {
var me = this;
if (!me.stores.length) {
me.stores[0] = store;
} else {
Ext.Array.include(this.stores, store);
}
this.store = this.stores[0]; 
},
unjoin: function(store) {
Ext.Array.remove(this.stores, store);
this.store = this.stores[0] || null; 
},
afterEdit : function(modifiedFieldNames) {
this.callStore('afterEdit', modifiedFieldNames);
},
afterReject : function() {
this.callStore('afterReject');
},
afterCommit: function(modifiedFieldNames) {
this.callStore('afterCommit', modifiedFieldNames);
},
callStore: function(fn) {
var args = Ext.Array.clone(arguments),
stores = this.stores,
i = 0,
len = stores.length,
store;
args[0] = this;
for (; i < len; ++i) {
store = stores[i];
if (store && Ext.isFunction(store[fn])) {
store[fn].apply(store, args);
}
}
},
getData: function(includeAssociated){
var me     = this,
fields = me.fields.items,
fLen   = fields.length,
data   = {},
name, f;
for (f = 0; f < fLen; f++) {
name = fields[f].name;
data[name] = me.get(name);
}
if (includeAssociated === true) {
Ext.apply(data, me.getAssociatedData());
}
return data;
},
getAssociatedData: function(){
return this.prepareAssociatedData({}, 1);
},
prepareAssociatedData: function(seenKeys, depth) {
var me               = this,
associations     = me.associations.items,
associationCount = associations.length,
associationData  = {},
toRead           = [],
toReadKey        = [],
toReadIndex      = [],
associatedStore, associatedRecords, associatedRecord, o, index, result, seenDepth,
associationId, associatedRecordCount, association, i, j, type, name;
for (i = 0; i < associationCount; i++) {
association = associations[i];
associationId = association.associationId;
seenDepth = seenKeys[associationId];
if (seenDepth && seenDepth !== depth) {
continue;
}
seenKeys[associationId] = depth;
type = association.type;
name = association.name;
if (type == 'hasMany') {
associatedStore = me[association.storeName];
associationData[name] = [];
if (associatedStore && associatedStore.getCount() > 0) {
associatedRecords = associatedStore.data.items;
associatedRecordCount = associatedRecords.length;
for (j = 0; j < associatedRecordCount; j++) {
associatedRecord = associatedRecords[j];
associationData[name][j] = associatedRecord.getData();
toRead.push(associatedRecord);
toReadKey.push(name);
toReadIndex.push(j);
}
}
} else if (type == 'belongsTo' || type == 'hasOne') {
associatedRecord = me[association.instanceName];
if (associatedRecord !== undefined) {
associationData[name] = associatedRecord.getData();
toRead.push(associatedRecord);
toReadKey.push(name);
toReadIndex.push(-1);
}
}
}
for (i = 0, associatedRecordCount = toRead.length; i < associatedRecordCount; ++i) {
associatedRecord = toRead[i];
o = associationData[toReadKey[i]];
index = toReadIndex[i];
result = associatedRecord.prepareAssociatedData(seenKeys, depth + 1);
if (index === -1) {
Ext.apply(o, result);
} else {
Ext.apply(o[index], result);
}
}
return associationData;
}
});
Ext.define('Ext.data.proxy.Client', {
extend:  Ext.data.proxy.Proxy ,
alternateClassName: 'Ext.data.ClientProxy',
isSynchronous: true,
clear: function() {
}
});
Ext.define('Ext.data.proxy.Memory', {
extend:  Ext.data.proxy.Client ,
alias: 'proxy.memory',
alternateClassName: 'Ext.data.MemoryProxy',
constructor: function(config) {
this.callParent([config]);
this.setReader(this.reader);
},
updateOperation: function(operation, callback, scope) {
var i = 0,
recs = operation.getRecords(),
len = recs.length;
for (i; i < len; i++) {
recs[i].commit();
}
operation.setCompleted();
operation.setSuccessful();
Ext.callback(callback, scope || this, [operation]);
},
create: function() {
this.updateOperation.apply(this, arguments);
},
update: function() {
this.updateOperation.apply(this, arguments);
},
destroy: function() {
this.updateOperation.apply(this, arguments);
},
read: function(operation, callback, scope) {
var me = this,
resultSet = operation.resultSet = me.getReader().read(me.data),
records = resultSet.records,
sorters = operation.sorters,
groupers = operation.groupers,
filters = operation.filters;
operation.setCompleted();
if (resultSet.success) {
if (filters && filters.length) {
records = resultSet.records = Ext.Array.filter(records, Ext.util.Filter.createFilterFn(filters));
resultSet.total = records.length;
}
if (groupers && groupers.length) {
sorters = sorters ? sorters.concat(groupers) : sorters;
}
if (sorters && sorters.length) {
resultSet.records = Ext.Array.sort(records, Ext.util.Sortable.createComparator(sorters));
}
if (me.enablePaging && operation.start !== undefined && operation.limit !== undefined) {
if (operation.start >= resultSet.total) {
resultSet.success = false;
resultSet.count = 0;
resultSet.records = [];
}
else {
resultSet.records = Ext.Array.slice(resultSet.records, operation.start, operation.start + operation.limit);
resultSet.count = resultSet.records.length;
}
}
}
if (resultSet.success) {
operation.setSuccessful();
} else {
me.fireEvent('exception', me, null, operation);
}
Ext.callback(callback, scope || me, [operation]);
},
clear: Ext.emptyFn
});
Ext.define('Ext.data.Store', {
extend:  Ext.data.AbstractStore ,
alias: 'store.store',
remoteSort: false,
remoteFilter: false,
remoteGroup : false,
groupField: undefined,
groupDir: "ASC",
trailingBufferZone: 25,
leadingBufferZone: 200,
pageSize: undefined,
totalCount: 0,
snapshot: null,
currentPage: 1,
clearOnPageLoad: true,
loading: false,
sortOnFilter: true,
buffered: false,
purgePageCount: 5,
clearRemovedOnLoad: true,
defaultPageSize: 25,
defaultViewSize: 100,
addRecordsOptions: {
addRecords: true
},
statics: {
recordIdFn: function(record) {
return record.internalId;
},
recordIndexFn: function(record) {
return record.index;
},
grouperIdFn: function(grouper) {
return grouper.id || grouper.property;
},
groupIdFn: function(group) {
return group.key;
}
},
constructor: function(config) {
config = Ext.apply({}, config);
var me = this,
groupers = config.groupers || me.groupers,
groupField = config.groupField || me.groupField,
proxy,
data;
data = config.data || me.data;
if (data) {
me.inlineData = data;
delete config.data;
}
if (!groupers && groupField) {
groupers = [{
property : groupField,
direction: config.groupDir || me.groupDir
}];
if (config.getGroupString || (me.getGroupString !== Ext.data.Store.prototype.getGroupString)) {
groupers[0].getGroupString = function(record) {
return me.getGroupString(record);
}
}
}
delete config.groupers;
me.groupers = new Ext.util.MixedCollection(false, Ext.data.Store.grouperIdFn);
me.groupers.addAll(me.decodeGroupers(groupers));
me.groups = new Ext.util.MixedCollection(false, Ext.data.Store.groupIdFn);
me.callParent([config]);
if (me.buffered) {
me.data = new Ext.data.PageMap({
store: me,
keyFn: Ext.data.Store.recordIdFn,
pageSize: me.pageSize,
maxSize: me.purgePageCount,
listeners: {
clear: me.onPageMapClear,
scope: me
}
});
me.pageRequests = {};
me.remoteSort = me.remoteGroup = me.remoteFilter = true;
me.sortOnLoad = false;
me.filterOnLoad = false;
} else {
me.data = new Ext.util.MixedCollection({
getKey: Ext.data.Store.recordIdFn,
maintainIndices: true
});
}
if (me.remoteGroup) {
me.remoteSort = true;
}
me.sorters.insert(0, me.groupers.getRange());
proxy = me.proxy;
data = me.inlineData;
if (!me.buffered && !me.pageSize) {
me.pageSize = me.defaultPageSize;
}
if (data) {
if (proxy instanceof Ext.data.proxy.Memory) {
proxy.data = data;
me.read();
} else {
me.add.apply(me, [data]);
}
if (me.sorters.items.length && !me.remoteSort) {
me.group(null, null, true);
}
delete me.inlineData;
}
else if (me.autoLoad) {
Ext.defer(me.load, 1, me, [ typeof me.autoLoad === 'object' ? me.autoLoad : undefined ]);
}
},
onBeforeSort: function() {
var groupers = this.groupers;
if (groupers.getCount() > 0) {
this.sort(groupers.items, 'prepend', false);
}
},
decodeGroupers: function(groupers) {
if (!Ext.isArray(groupers)) {
if (groupers === undefined) {
groupers = [];
} else {
groupers = [groupers];
}
}
var length = groupers.length,
Grouper = Ext.util.Grouper,
config, i, result = [];
for (i = 0; i < length; i++) {
config = groupers[i];
if (!(config instanceof Grouper)) {
if (Ext.isString(config)) {
config = {
property: config
};
}
config = Ext.apply({
root     : 'data',
direction: "ASC"
}, config);
if (config.fn) {
config.sorterFn = config.fn;
}
if (typeof config == 'function') {
config = {
sorterFn: config
};
}
result.push(new Grouper(config));
} else {
result.push(config);
}
}
return result;
},
group: function(groupers, direction,  suppressEvent) {
var me = this,
grouper,
newGroupers;
if (groupers) {
me.sorters.removeAll(me.groupers.items);
if (Ext.isArray(groupers)) {
newGroupers = groupers;
} else if (Ext.isObject(groupers)) {
newGroupers = [groupers];
} else if (Ext.isString(groupers)) {
grouper = me.groupers.get(groupers);
if (!grouper) {
grouper = {
property : groupers,
direction: direction || 'ASC'
};
newGroupers = [grouper];
} else if (direction === undefined) {
grouper.toggle();
} else {
grouper.setDirection(direction);
}
}
if (newGroupers && newGroupers.length) {
me.groupers.clear();
me.groupers.addAll(me.decodeGroupers(newGroupers));
}
me.sorters.insert(0, me.groupers.items);
}
if (me.remoteGroup) {
if (me.buffered) {
me.data.clear();
me.loadPage(1, { groupChange: true });
} else {
me.load({
scope: me,
callback: suppressEvent ? null : me.fireGroupChange
});
}
} else {
me.doSort(me.generateComparator());
me.constructGroups();
if (!suppressEvent) {
me.fireGroupChange();
}
}
},
getGroupField: function(){
var first = this.groupers.first(),
group;
if (first) {
group = first.property;
}   
return group; 
},
constructGroups: function(){
var me = this,
data = this.data.items,
len = data.length,
groups = me.groups,
groupValue, i, group, rec;
groups.clear();
if (me.isGrouped()) {
for (i = 0; i < len; ++i) {
rec = data[i];
groupValue = me.getGroupString(rec);
group = groups.get(groupValue);
if (!group) {
group = new Ext.data.Group({
key: groupValue,
store: me
});
groups.add(group);
}
group.add(rec);
}
}
},
clearGrouping: function() {
var me       = this,
groupers = me.groupers.items,
gLen     = groupers.length,
g;
for (g = 0; g < gLen; g++) {
me.sorters.remove(groupers[g]);
}
me.groupers.clear();
if (me.remoteGroup) {
if (me.buffered) {
me.data.clear();
me.loadPage(1, { groupChange: true });
} else {
me.load({
scope: me,
callback: me.fireGroupChange
});
}
} else {
me.groups.clear();
if (me.sorters.length) {
me.sort();
} else {
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
me.fireGroupChange();
}
},
isGrouped: function() {
return this.groupers.getCount() > 0;
},
fireGroupChange: function() {
this.fireEvent('groupchange', this, this.groupers);
},
getGroups: function(requestGroupString) {
var records = this.data.items,
length = records.length,
groups = [],
pointers = {},
record,
groupStr,
group,
i;
for (i = 0; i < length; i++) {
record = records[i];
groupStr = this.getGroupString(record);
group = pointers[groupStr];
if (group === undefined) {
group = {
name: groupStr,
children: []
};
groups.push(group);
pointers[groupStr] = group;
}
group.children.push(record);
}
return requestGroupString ? pointers[requestGroupString] : groups;
},
getGroupsForGrouper: function(records, grouper) {
var length = records.length,
groups = [],
oldValue,
newValue,
record,
group,
i;
for (i = 0; i < length; i++) {
record = records[i];
newValue = grouper.getGroupString(record);
if (newValue !== oldValue) {
group = {
name: newValue,
grouper: grouper,
records: []
};
groups.push(group);
}
group.records.push(record);
oldValue = newValue;
}
return groups;
},
getGroupsForGrouperIndex: function(records, grouperIndex) {
var me = this,
groupers = me.groupers,
grouper = groupers.getAt(grouperIndex),
groups = me.getGroupsForGrouper(records, grouper),
length = groups.length,
i;
if (grouperIndex + 1 < groupers.length) {
for (i = 0; i < length; i++) {
groups[i].children = me.getGroupsForGrouperIndex(groups[i].records, grouperIndex + 1);
}
}
for (i = 0; i < length; i++) {
groups[i].depth = grouperIndex;
}
return groups;
},
getGroupData: function(sort) {
var me = this;
if (sort !== false) {
me.sort();
}
return me.getGroupsForGrouperIndex(me.data.items, 0);
},
getGroupString: function(instance) {
var group = this.groupers.first();
if (group) {
return group.getGroupString(instance);
}
return '';
},
insert: function(index, records) {
var me = this,
sync = false,
i, len, record,
defaults = me.modelDefaults,
out;
if (!Ext.isIterable(records)) {
out = records = [records];
} else {
out = [];
}
len = records.length;
if (len) {
for (i = 0; i < len; i++) {
record = records[i];
if (!record.isModel) {
record = me.createModel(record);
}
out[i] = record;
if (defaults) {
record.set(defaults);
}
record.join(me);
sync = sync || record.phantom === true;
}
me.data.insert(index, out);
if (me.snapshot) {
me.snapshot.addAll(out);
}
if (me.requireSort) {
me.suspendEvents();
me.sort();
me.resumeEvents();
}
if (me.isGrouped()) {
me.updateGroupsOnAdd(out);
}
me.fireEvent('add', me, out, index);
me.fireEvent('datachanged', me);
if (me.autoSync && sync && !me.autoSyncSuspended) {
me.sync();
}
}
return out;
},
updateGroupsOnAdd: function(records) {
var me = this,
groups = me.groups,
len = records.length,
i, groupName, group, rec;
for (i = 0; i < len; ++i) {
rec = records[i];
groupName = me.getGroupString(rec);
group = groups.getByKey(groupName);
if (!group) {
group = groups.add(new Ext.data.Group({
key: groupName,
store: me
}));
}
group.add(rec);
}
},
updateGroupsOnRemove: function(records) {
var me = this,
groups = me.groups,
len = records.length,
i, groupName, group, rec;
for (i = 0; i < len; ++i) {
rec = records[i];
groupName = me.getGroupString(rec);
group = groups.getByKey(groupName);
if (group) {
group.remove(rec);
if (group.records.length === 0) {
groups.remove(group);
}    
}
}
},
updateGroupsOnUpdate: function(record, modifiedFieldNames){
var me = this,
groupField = me.getGroupField(),
groupName = me.getGroupString(record),
groups = me.groups,
len, i, items, group;
if (modifiedFieldNames && Ext.Array.contains(modifiedFieldNames, groupField)) {
if (me.buffered) {
Ext.Error.raise({
msg: 'Cannot move records between groups in a buffered store record'
});
}
items = groups.items;
for (i = 0, len = items.length; i < len; ++i) {
group = items[i];
if (group.contains(record)) {
group.remove(record);
break;
}
}
group = groups.getByKey(groupName);
if (!group) {
group = groups.add(new Ext.data.Group({
key: groupName,
store: me
}));
}
group.add(record);
me.data.remove(record);
me.data.insert(me.data.findInsertionIndex(record, me.generateComparator()), record);
} else {
groups.getByKey(groupName).setDirty();    
}
},
add: function(arg) {
var me = this,
records,
length, isSorted;
if (Ext.isArray(arg)) {
records = arg;
} else {
records = arguments;
}
length = records.length;
isSorted = !me.remoteSort && me.sorters && me.sorters.items.length;
if (isSorted && length === 1) {
return [ me.addSorted(me.createModel(records[0])) ];
}
if (isSorted) {
me.requireSort = true;
}
records = me.insert(me.data.length, records);
delete me.requireSort;
return records;
},
addSorted: function(record) {
var me = this,
index = me.data.findInsertionIndex(record, me.generateComparator());
me.insert(index, record);
return record;
},
createModel: function(record) {
if (!record.isModel) {
record = Ext.ModelManager.create(record, this.model);
}
return record;
},
onUpdate: function(record, type, modifiedFieldNames){
if (this.isGrouped()) {
this.updateGroupsOnUpdate(record, modifiedFieldNames);
}
},
each: function(fn, scope) {
var data = this.data.items,
dLen = data.length,
record, d;
for (d = 0; d < dLen; d++) {
record = data[d];
if (fn.call(scope || record, record, d, dLen) === false) {
break;
}
}
},
remove: function(records,  isMove, silent) {
isMove = isMove === true;
var me = this,
sync = false,
snapshot = me.snapshot,
data = me.data,
i = 0,
length,
info = [],
allRecords = [],
indexes = [],
item,
isNotPhantom,
index,
record,
removeRange,
removeCount,
fireRemoveEvent = !silent && me.hasListeners.remove;
if (records.isModel) {
records = [records];
length = 1;
}
else if (Ext.isIterable(records)) {
length = records.length;
}
else if (typeof records === 'object') {
removeRange = true;
i = records.start;
length = records.end + 1;
removeCount = length - i;
}
if (!removeRange) {
for (i = 0; i < length; ++i) {
record = records[i];
if (typeof record == 'number') {
index = record;
record = data.getAt(index);
}
else {
index = me.indexOf(record);
}
if (record && index > -1) {
info.push({
record: record,
index: index
});
}
if (snapshot) {
snapshot.remove(record);
}
}
info = Ext.Array.sort(info, function(o1, o2) {
var index1 = o1.index,
index2 = o2.index;
return index1 === o2.index2 ? 0 : (index1 < index2 ? -1 : 1);
});
i = 0;
length = info.length;
}
if (!length) {
return;
}
for (; i < length; i++) {
if (removeRange) {
record = data.getAt(i);
index = i;
} else {
item = info[i];
record = item.record;
index = item.index;
}
allRecords.push(record);
indexes.push(index);
isNotPhantom = record.phantom !== true;
if (!isMove && isNotPhantom) {
record.removedFrom = index;
me.removed.push(record);
}
record.unjoin(me);
index -= i;
sync = sync || isNotPhantom;
if (!removeRange) {
data.removeAt(index);
if (fireRemoveEvent) {
me.fireEvent('remove', me, record, index, !!isMove);
}
}
}
if (removeRange) {
data.removeRange(records.start, removeCount);
}
if (!silent) {
me.fireEvent('bulkremove', me, allRecords, indexes, !!isMove);
me.fireEvent('datachanged', me);
}
if (!isMove && me.autoSync && sync && !me.autoSyncSuspended) {
me.sync();
}
},
removeAt: function(index, count) {
var me = this,
storeCount = me.getCount();
if (index <= storeCount) {
if (arguments.length === 1) {
me.remove([ index ]);
} else if (count) {
me.remove({
start: index,
end: Math.min(index + count, storeCount) - 1
});
}
}
},
removeAll: function(silent) {
var me = this,
snapshot = me.snapshot,
data = me.data;
if (snapshot) {
snapshot.removeAll(data.getRange());
}
if (me.buffered) {
if (data) {
if (silent) {
me.suspendEvent('clear');
}
data.clear();
if (silent) {
me.resumeEvent('clear');
}
}            
}
else {
me.remove({
start: 0,
end: me.getCount() - 1
}, false, silent);
if (silent !== true) {
me.fireEvent('clear', me);
}
}
},
load: function(options) {
var me = this;
if (typeof options == 'function') {
options = {
callback: options
};
} else {
options = Ext.apply({}, options);
}
if (me.remoteGroup && !options.groupers && me.groupers.items.length) {
options.groupers = me.groupers.items;
}
options.page = options.page || me.currentPage;
options.start = (options.start !== undefined) ? options.start : (options.page - 1) * me.pageSize;
options.limit = options.limit || me.pageSize;
options.addRecords = options.addRecords || false;
if (me.buffered) {
options.limit = me.viewSize || me.defaultViewSize;
options.loadCallback = options.callback;
delete options.callback;
return me.loadToPrefetch(options);
}
return me.callParent([options]);
},
reload: function(options) {
var me = this,
startIdx,
endIdx,
startPage,
endPage,
i,
waitForReload,
bufferZone,
records;
if (!options) {
options = {};
}
if (me.buffered) {
me.totalCount = 0;
me.data.clear(true);
waitForReload = function() {
if (me.rangeCached(startIdx, endIdx)) {
me.loading = false;
me.data.un('pageAdded', waitForReload);
records = me.data.getRange(startIdx, endIdx);
me.fireEvent('load', me, records, true);
}
};
bufferZone = Math.ceil((me.leadingBufferZone + me.trailingBufferZone) / 2);
if (!me.lastRequestStart) {
startIdx = options.start || 0;
endIdx = startIdx + (options.count || me.pageSize) - 1;
} else {
startIdx = me.lastRequestStart;
endIdx = me.lastRequestEnd;
}
startPage = me.getPageFromRecordIndex(Math.max(startIdx - bufferZone, 0));
endPage = me.getPageFromRecordIndex(endIdx + bufferZone);
if (me.fireEvent('beforeload', me, options) !== false) {
me.loading = true;
me.data.on('pageAdded', waitForReload);
for (i = startPage; i <= endPage; i++) {
me.prefetchPage(i, options);
}
}
} else {
return me.callParent(arguments);
}
},
onProxyLoad: function(operation) {
var me = this,
resultSet = operation.getResultSet(),
records = operation.getRecords(),
successful = operation.wasSuccessful();
if (me.isDestroyed) {
return;
}
if (resultSet) {
me.totalCount = resultSet.total;
}
me.loading = false;
if (successful) {
me.loadRecords(records, operation);
}
if (me.hasListeners.load) {
me.fireEvent('load', me, records, successful);
}
if (me.hasListeners.read) {
me.fireEvent('read', me, records, successful);
}
Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
},
getNewRecords: function() {
return (this.snapshot || this.data).filterBy(this.filterNew).items;
},
getUpdatedRecords: function() {
return (this.snapshot || this.data).filterBy(this.filterUpdated).items;
},
filter: function(filters, value) {
if (Ext.isString(filters)) {
filters = {
property: filters,
value: value
};
}
var me = this,
decoded = me.decodeFilters(filters),
i,
doLocalSort = me.sorters.length && me.sortOnFilter && !me.remoteSort,
length = decoded.length;
for (i = 0; i < length; i++) {
me.filters.replace(decoded[i]);
}
filters = me.filters.items;
if (filters.length) {
if (me.remoteFilter) {
me.totalCount = 0;
if (me.buffered) {
me.data.clear();
me.loadPage(1);
} else {
me.currentPage = 1;
me.load();
}
} else {
me.snapshot = me.snapshot || me.data.clone();
me.data = me.snapshot.filter(filters);
me.constructGroups();
if (doLocalSort) {
me.sort();
} else {
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
}
me.fireEvent('filterchange', me, filters);
}
},
clearFilter: function(suppressEvent) {
var me = this;
me.filters.clear();
if (me.remoteFilter) {
if (suppressEvent) {
return;
}
me.totalCount = 0;
if (me.buffered) {
me.data.clear();
me.loadPage(1);
} else {
me.currentPage = 1;
me.load();
}
} else if (me.isFiltered()) {
me.data = me.snapshot;
me.snapshot = null;
me.constructGroups();
if (suppressEvent !== true) {
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
}
me.fireEvent('filterchange', me, me.filters.items);
},
removeFilter: function(toRemove, applyFilters) {
var me = this;
if (!me.remoteFilter && me.isFiltered()) {
if (toRemove instanceof Ext.util.Filter) {
me.filters.remove(toRemove);
} else {
me.filters.removeAtKey(toRemove);
}
if (applyFilters !== false) {
if (me.filters.length) {
me.filter();
}
else {
me.clearFilter();
}
} else {
me.fireEvent('filterchange', me, me.filters.items);
}
}
},
addFilter: function(filters, applyFilters) {
var me = this,
decoded,
i,
length;
decoded = me.decodeFilters(filters);
length = decoded.length;
for (i = 0; i < length; i++) {
me.filters.replace(decoded[i]);
}
if (applyFilters !== false && me.filters.length) {
me.filter();
} else {
me.fireEvent('filterchange', me, me.filters.items);
}
},
isFiltered: function() {
var snapshot = this.snapshot;
return !!(snapshot && snapshot !== this.data);
},
filterBy: function(fn, scope) {
var me = this;
me.snapshot = me.snapshot || me.data.clone();
me.data = me.queryBy(fn, scope || me);
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
},
queryBy: function(fn, scope) {
var me = this;
return (me.snapshot || me.data).filterBy(fn, scope || me);
},
query: function(property, value, anyMatch, caseSensitive, exactMatch) {
var me = this,
queryFn = me.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch),
results = me.queryBy(queryFn);
if(!results) {
results = new Ext.util.MixedCollection();
}
return results;
},
loadData: function(data, append) {
var length = data.length,
newData = [],
i;
console.warn('Inefficient method `store.loadData()`! Open code it manually.');
for (i = 0; i < length; i++) {
newData.push(this.createModel(data[i]));
}
this.loadRecords(newData, append ? this.addRecordsOptions : undefined);
},
loadRawData : function(data, append) {
var me      = this,
result  = me.proxy.reader.read(data),
records = result.records;
if (result.success) {
me.totalCount = result.total;
me.loadRecords(records, append ? me.addRecordsOptions : undefined);
}
},
loadRecords: function(records, options) {
var me     = this,
i,
length,
start,
addRecords,
data;
if (options) {
start = options.start;
addRecords = options.addRecords;
}
if (!addRecords) {
me.snapshot && (me.snapshot = null);
me.clearData(true);
} else if ((data = me.snapshot)) {
data.insert(data.length, records);
}
data = me.data;
data.insert(data.length, records);
length = records.length;
i = 0;
if (start !== undefined) {
for (; i < length; i++) {
records[i].index = start + i;
records[i].join(me);
}
} else {
for (; i < length; i++) {
records[i].join(me);
}
}
me.suspendEvents();
if (me.filterOnLoad && !me.remoteFilter) {
me.filter();
}
if (me.sortOnLoad && !me.remoteSort) {
me.sort(undefined, undefined, undefined, true);
}
me.resumeEvents();
if (me.isGrouped()) {
me.constructGroups();
}
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
},
loadPage: function(page, options) {
var me = this;
me.currentPage = page;
options = Ext.apply({
page: page,
start: (page - 1) * me.pageSize,
limit: me.pageSize,
addRecords: !me.clearOnPageLoad
}, options);
if (me.buffered) {
options.limit = me.viewSize || me.defaultViewSize;
options.loadCallback = options.callback;
delete options.callback;
return me.loadToPrefetch(options);
}
me.read(options);
},
nextPage: function(options) {
this.loadPage(this.currentPage + 1, options);
},
previousPage: function(options) {
this.loadPage(this.currentPage - 1, options);
},
clearData: function(isLoad) {
var me = this,
records,
i;
if (!me.buffered && me.data) {
records = me.data.items;
i = records.length;
while (i--) {
records[i].unjoin(me);
}
}
if (me.data) {
me.data.clear();
}
if (isLoad !== true || me.clearRemovedOnLoad) {
me.removed.length = 0;
}
},
loadToPrefetch: function(options) {
var me = this,
i,
records,
dataSetSize,
prefetchOptions = options,
startIdx = options.start,
endIdx = options.start + options.limit - 1,
loadEndIdx = Math.min(endIdx, options.start + (me.viewSize || options.limit) - 1),
startPage = me.getPageFromRecordIndex(Math.max(startIdx - me.trailingBufferZone, 0)),
endPage = me.getPageFromRecordIndex(endIdx + me.leadingBufferZone),
waitForRequestedRange = function() {
if (me.rangeCached(startIdx, loadEndIdx)) {
me.loading = false;
records = me.data.getRange(startIdx, loadEndIdx);
me.data.un('pageAdded', waitForRequestedRange);
if (me.hasListeners.guaranteedrange) {
me.guaranteeRange(startIdx, loadEndIdx, options.callback, options.scope);
}
if (options.loadCallback) {
options.loadCallback.call(options.scope || me, records, operation, true);
}
if (options.callback) {
options.callback.call(options.scope||me, records, startIdx, endIdx, options);
}
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
me.fireEvent('load', me, records, true);
if (options.groupChange) {
me.fireGroupChange();
}
}
}, operation;
if (me.fireEvent('beforeload', me, options) !== false) {
me.totalCount = 0;
me.loading = true;
if (options.callback) {
prefetchOptions = Ext.apply({}, options);
delete prefetchOptions.callback;
}
me.on('prefetch', function(store, records, successful, op) {
if (successful) {
operation = op;
if ((dataSetSize = me.getTotalCount())) {
me.data.on('pageAdded', waitForRequestedRange);
loadEndIdx = Math.min(loadEndIdx, dataSetSize - 1);
endPage = me.getPageFromRecordIndex(Math.min(loadEndIdx + me.leadingBufferZone, dataSetSize - 1));
for (i = startPage + 1; i <= endPage; ++i) {
me.prefetchPage(i, prefetchOptions);
}
} else {
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
me.fireEvent('load', me, records, true);
}
}
else {
me.fireEvent('load', me, records, false);
}
}, null, {single: true});
me.prefetchPage(startPage, prefetchOptions);
}
},
prefetch: function(options) {
var me = this,
pageSize = me.pageSize,
proxy,
operation;
if (pageSize) {
if (me.lastPageSize && pageSize != me.lastPageSize) {
Ext.Error.raise("pageSize cannot be dynamically altered");
}
if (!me.data.pageSize) {
me.data.pageSize = pageSize;
}
}
else {
me.pageSize = me.data.pageSize = pageSize = options.limit;
}
me.lastPageSize = pageSize;
if (!options.page) {
options.page = me.getPageFromRecordIndex(options.start);
options.start = (options.page - 1) * pageSize;
options.limit = Math.ceil(options.limit / pageSize) * pageSize;
}
if (!me.pageRequests[options.page]) {
options = Ext.apply({
action : 'read',
filters: me.filters.items,
sorters: me.sorters.items,
groupers: me.groupers.items,
pageMapGeneration: me.data.pageMapGeneration
}, options);
operation = new Ext.data.Operation(options);
if (me.fireEvent('beforeprefetch', me, operation) !== false) {
proxy = me.proxy;
me.pageRequests[options.page] = proxy.read(operation, me.onProxyPrefetch, me);
if (proxy.isSynchronous) {
delete me.pageRequests[options.page];
}
}
}
return me;
},
onPageMapClear: function() {
var me = this,
loadingFlag = me.wasLoading,
reqs = me.pageRequests,
req,
page;
if (me.data.events.pageadded) {
me.data.events.pageadded.clearListeners();
}
me.loading = true;
me.totalCount = 0;
for (page in reqs) {
if (reqs.hasOwnProperty(page)) {
req = reqs[page];
delete reqs[page];
delete req.callback;
}
}
me.fireEvent('clear', me);
me.loading = loadingFlag;
},
prefetchPage: function(page, options) {
var me = this,
pageSize = me.pageSize || me.defaultPageSize,
start = (page - 1) * me.pageSize,
total = me.totalCount;
if (total !== undefined && me.getCount() === total) {
return;
}
me.prefetch(Ext.applyIf({
page     : page,
start    : start,
limit    : pageSize
}, options));
},
onProxyPrefetch: function(operation) {
var me = this,
resultSet = operation.getResultSet(),
records = operation.getRecords(),
successful = operation.wasSuccessful(),
page = operation.page;
if (operation.pageMapGeneration === me.data.pageMapGeneration) {
if (resultSet) {
me.totalCount = resultSet.total;
me.fireEvent('totalcountchange', me.totalCount);
}
if (page !== undefined) {
delete me.pageRequests[page];
}
me.loading = false;
me.fireEvent('prefetch', me, records, successful, operation);
if (successful) {
me.cachePage(records, operation.page);
}
Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
}
},
cachePage: function(records, page) {
var me = this,
len = records.length, i;
if (!Ext.isDefined(me.totalCount)) {
me.totalCount = records.length;
me.fireEvent('totalcountchange', me.totalCount);
}
for (i = 0; i < len; i++) {
records[i].join(me);
}
me.data.addPage(page, records);
},
rangeCached: function(start, end) {
return this.data && this.data.hasRange(start, end);
},
pageCached: function(page) {
return this.data && this.data.hasPage(page);
},
pagePending: function(page) {
return !!this.pageRequests[page];
},
rangeSatisfied: function(start, end) {
return this.rangeCached(start, end);
},
getPageFromRecordIndex: function(index) {
return Math.floor(index / this.pageSize) + 1;
},
onGuaranteedRange: function(options) {
var me = this,
totalCount = me.getTotalCount(),
start = options.prefetchStart,
end = (options.prefetchEnd > totalCount - 1) ? totalCount - 1 : options.prefetchEnd,
range;
end = Math.max(0, end);
range = me.data.getRange(start, end);
if (options.fireEvent !== false) {
me.fireEvent('guaranteedrange', range, start, end, options);
}
if (options.callback) {
options.callback.call(options.scope || me, range, start, end, options);
}
},
guaranteeRange: function(start, end, callback, scope, options) {
options = Ext.apply({
callback: callback,
scope: scope
}, options);
this.getRange(start, end, options)
},
prefetchRange: function(start, end) {
var me = this,
startPage, endPage, page;
if (!me.rangeCached(start, end)) {
startPage = me.getPageFromRecordIndex(start);
endPage = me.getPageFromRecordIndex(end);
me.data.maxSize = me.purgePageCount ? (endPage - startPage + 1) + me.purgePageCount : 0;
for (page = startPage; page <= endPage; page++) {
if (!me.pageCached(page)) {
me.prefetchPage(page);
}
}
}
},
primeCache: function(start, end, direction) {
var me = this;
if (direction === -1) {
start = Math.max(start - me.leadingBufferZone, 0);
end   = Math.min(end   + me.trailingBufferZone, me.totalCount - 1);
}
else if (direction === 1) {
start = Math.max(Math.min(start - me.trailingBufferZone, me.totalCount - me.pageSize), 0);
end   = Math.min(end + me.leadingBufferZone, me.totalCount - 1);
}
else {
start = Math.min(Math.max(Math.floor(start - ((me.leadingBufferZone + me.trailingBufferZone) / 2)), 0), me.totalCount - me.pageSize);
end =   Math.min(Math.max(Math.ceil (end   + ((me.leadingBufferZone + me.trailingBufferZone) / 2)), 0), me.totalCount - 1);
}
me.prefetchRange(start, end);
},
sort: function(sorters) {
var me = this;
if (sorters && me.buffered && me.remoteSort) {
me.data.clear();
}
return me.callParent(arguments);
},
doSort: function(sorterFn) {
var me = this,
range,
ln,
i;
if (me.remoteSort) {
if (me.buffered) {
me.data.clear();
me.loadPage(1);
} else {
me.load();
}
} else {
me.data.sortBy(sorterFn);
if (!me.buffered) {
range = me.getRange();
ln = range.length;
for (i = 0; i < ln; i++) {
range[i].index = i;
}
}
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
},
find: function(property, value, start, anyMatch, caseSensitive, exactMatch) {
var fn = this.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch);
return fn ? this.data.findIndexBy(fn, null, start) : -1;
},
findRecord: function() {
var me = this,
index = me.find.apply(me, arguments);
return index !== -1 ? me.getAt(index) : null;
},
createFilterFn: function(property, value, anyMatch, caseSensitive, exactMatch) {
if (Ext.isEmpty(value)) {
return false;
}
value = Ext.util.AbstractMixedCollection.prototype.createValueMatcher(value, anyMatch, caseSensitive, exactMatch);
return function(r) {
return value.test(r.data[property]);
};
},
findExact: function(property, value, start) {
return this.data.findIndexBy(function(rec) {
return rec.isEqual(rec.get(property), value);
},
this, start);
},
findBy: function(fn, scope, start) {
return this.data.findIndexBy(fn, scope, start);
},
collect: function(dataIndex, allowNull, bypassFilter) {
var me = this,
data = (bypassFilter === true && me.snapshot) ? me.snapshot : me.data;
return data.collect(dataIndex, 'data', allowNull);
},
getCount: function() {
return this.data.getCount();
},
getTotalCount: function() {
return this.totalCount || 0;
},
getAt: function(index) {
return this.data.getAt(index);
},
getRange: function(start, end, options) {
var me = this,
requiredStart,
requiredEnd,
maxIndex = me.totalCount - 1,
lastRequestStart = me.lastRequestStart,
pageAddHandler,
result;
options = Ext.apply({
prefetchStart: start,
prefetchEnd: end
}, options);
if (me.buffered) {
end = (end >= me.totalCount) ? maxIndex : end;
requiredStart = start === 0 ? 0 : start - 1;
requiredEnd = end === maxIndex ? end : end + 1;
me.lastRequestStart = start;
me.lastRequestEnd = end;
if (me.rangeCached(requiredStart, requiredEnd)) {
me.onGuaranteedRange(options);
result = me.data.getRange(start, end);
}
else {
me.fireEvent('cachemiss', me, start, end);
pageAddHandler = function(page, records) {
if (me.rangeCached(requiredStart, requiredEnd)) {
me.fireEvent('cachefilled', me, start, end);
me.data.un('pageAdded', pageAddHandler);
me.onGuaranteedRange(options);
}
};
me.data.on('pageAdded', pageAddHandler);
me.prefetchRange(start, end);
}
me.primeCache(start, end, start < lastRequestStart ? -1 : 1);
} else {
result = me.data.getRange(start, end);
if (options.callback) {
options.callback.call(options.scope || me, result, start, end, options)
}
}
return result;
},
getById: function(id) {
var result = (this.snapshot || this.data).findBy(function(record) {
return record.getId() === id;
});
return result;
},
getByInternalId: function(internalId) {
var result;
if (this.buffered) {
result = (this.snapshot || this.data).findBy(function(record) {
return record.internalId === internalId;
});
} else {
result = this.data.get(internalId);
}
return result;
},
indexOf: function(record) {
return this.data.indexOf(record);
},
indexOfTotal: function(record) {
var index = record.index;
if (index || index === 0) {
return index;
}
return this.indexOf(record);
},
indexOfId: function(id) {
return this.indexOf(this.getById(id));
},
first: function(grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(function(records) {
return records.length ? records[0] : undefined;
}, me, true);
} else {
return me.data.first();
}
},
last: function(grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(function(records) {
var len = records.length;
return len ? records[len - 1] : undefined;
}, me, true);
} else {
return me.data.last();
}
},
sum: function(field, grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(me.getSum, me, true, [field]);
} else {
return me.getSum(me.data.items, field);
}
},
getSum: function(records, field) {
var total = 0,
i = 0,
len = records.length;
for (; i < len; ++i) {
total += records[i].get(field);
}
return total;
},
count: function(grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(function(records) {
return records.length;
}, me, true);
} else {
return me.getCount();
}
},
min: function(field, grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(me.getMin, me, true, [field]);
} else {
return me.getMin(me.data.items, field);
}
},
getMin: function(records, field) {
var i = 1,
len = records.length,
value, min;
if (len > 0) {
min = records[0].get(field);
}
for (; i < len; ++i) {
value = records[i].get(field);
if (value < min) {
min = value;
}
}
return min;
},
max: function(field, grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(me.getMax, me, true, [field]);
} else {
return me.getMax(me.data.items, field);
}
},
getMax: function(records, field) {
var i = 1,
len = records.length,
value,
max;
if (len > 0) {
max = records[0].get(field);
}
for (; i < len; ++i) {
value = records[i].get(field);
if (value > max) {
max = value;
}
}
return max;
},
average: function(field, grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(me.getAverage, me, true, [field]);
} else {
return me.getAverage(me.data.items, field);
}
},
getAverage: function(records, field) {
var i = 0,
len = records.length,
sum = 0;
if (records.length > 0) {
for (; i < len; ++i) {
sum += records[i].get(field);
}
return sum / len;
}
return 0;
},
aggregate: function(fn, scope, grouped, args) {
args = args || [];
if (grouped && this.isGrouped()) {
var groups = this.getGroups(),
len = groups.length,
out = {},
group, i;
for (i = 0; i < len; ++i) {
group = groups[i];
out[group.name] = this.getAggregate(fn, scope || this, group.children, args);
}
return out;
} else {
return this.getAggregate(fn, scope, this.data.items, args);
}
},
getAggregate: function(fn, scope, records, args){
args = args || [];
return fn.apply(scope || this, [records].concat(args));
},
onIdChanged: function(rec, oldId, newId, oldInternalId){
var snapshot = this.snapshot;
if (snapshot) {
snapshot.updateKey(oldInternalId, newId);
}
this.data.updateKey(oldInternalId, newId);
this.callParent(arguments);
},
commitChanges : function(){
var me = this,
recs = me.getModifiedRecords(),
len = recs.length,
i = 0;
for (; i < len; i++){
recs[i].commit();
}
me.removed.length = 0;
},
filterNewOnly: function(item){
return item.phantom === true;
},
getRejectRecords: function() {
return Ext.Array.push(this.data.filterBy(this.filterNewOnly).items, this.getUpdatedRecords());
},
rejectChanges : function() {
var me = this,
recs = me.getRejectRecords(),
len = recs.length,
i = 0,
rec;
for (; i < len; i++) {
rec = recs[i];
rec.reject();
if (rec.phantom) {
me.remove(rec);
}
}
recs = me.removed;
len = recs.length;
for (i = len-1; i >= 0; i--) {
rec = recs[i];
me.insert(rec.removedFrom || 0, rec);
rec.reject();
}
me.removed.length = 0;
}
}, function() {
Ext.regStore('ext-empty-store', {fields: [], proxy: 'memory'});
});
Ext.define('Ext.data.reader.Array', {
extend:  Ext.data.reader.Json ,
alternateClassName: 'Ext.data.ArrayReader',
alias : 'reader.array',
totalProperty: undefined,
successProperty: undefined,
createFieldAccessExpression: function(field, fieldVarName, dataName) {
var index  = (field.mapping == null) ? field.originalIndex : field.mapping,
result;
if (typeof index === 'function') {
result = fieldVarName + '.mapping(' + dataName + ', this)';
} else {
if (isNaN(index)) {
index = '"' + index + '"';
}
result = dataName + "[" + index + "]";
}
return result;
}
});
Ext.define('Ext.data.ArrayStore', {
extend:  Ext.data.Store ,
alias: 'store.array',
constructor: function(config) {
config = Ext.apply({
proxy: {
type: 'memory',
reader: 'array'
}
}, config);
this.callParent([config]);
},
loadData: function(data, append) {
if (this.expandData === true) {
var r = [],
i = 0,
ln = data.length;
for (; i < ln; i++) {
r[r.length] = [data[i]];
}
data = r;
}
this.callParent([data, append]);
}
}, function() {
Ext.data.SimpleStore = Ext.data.ArrayStore;
});
Ext.define('Ext.data.Batch', {
mixins: {
observable:  Ext.util.Observable 
},
autoStart: false,
pauseOnException: false,
current: -1,
total: 0,
isRunning: false,
isComplete: false,
hasException: false,
constructor: function(config) {
var me = this;
me.mixins.observable.constructor.call(me, config);
me.operations = [];
me.exceptions = [];
},
add: function(operation) {
this.total++;
operation.setBatch(this);
this.operations.push(operation);
return this;
},
start: function( index) {
var me = this;
if (me.isRunning) {
return me;
}
me.exceptions.length = 0;
me.hasException = false;
me.isRunning = true;
return me.runOperation(Ext.isDefined(index) ? index : me.current + 1);
},
retry: function() {
return this.start(this.current);
},
runNextOperation: function() {
return this.runOperation(this.current + 1);
},
pause: function() {
this.isRunning = false;
return this;
},
runOperation: function(index) {
var me = this,
operations = me.operations,
operation = operations[index],
onProxyReturn;
if (operation === undefined) {
me.isRunning = false;
me.isComplete = true;
me.fireEvent('complete', me, operations[operations.length - 1]);
} else {
me.current = index;
onProxyReturn = function(operation) {
var hasException = operation.hasException();
if (hasException) {
me.hasException = true;
me.exceptions.push(operation);
me.fireEvent('exception', me, operation);
}
if (hasException && me.pauseOnException) {
me.pause();
} else {
operation.setCompleted();
me.fireEvent('operationcomplete', me, operation);
me.runNextOperation();
}
};
operation.setStarted();
me.proxy[operation.action](operation, onProxyReturn, me);
}
return me;
}
});
Ext.define('Ext.data.Request', {
action: undefined,
params: undefined,
method: 'GET',
url: undefined,
constructor: function(config) {
Ext.apply(this, config);
}
});
Ext.define('Ext.data.SequentialIdGenerator', {
extend:  Ext.data.IdGenerator ,
alias: 'idgen.sequential',
constructor: function() {
var me = this;
me.callParent(arguments);
me.parts = [ me.prefix, ''];
},
prefix: '',
seed: 1,
generate: function () {
var me = this,
parts = me.parts;
parts[1] = me.seed++;
return parts.join('');
}
});
Ext.define('Ext.data.UuidGenerator', (function () {
var twoPow14 = Math.pow(2, 14),
twoPow16 = Math.pow(2, 16),
twoPow28 = Math.pow(2, 28),
twoPow32 = Math.pow(2, 32);
function toHex (value, length) {
var ret = value.toString(16);
if (ret.length > length) {
ret = ret.substring(ret.length - length); 
} else if (ret.length < length) {
ret = Ext.String.leftPad(ret, length, '0');
}
return ret;
}
function rand (lo, hi) {
var v = Math.random() * (hi - lo + 1);
return Math.floor(v) + lo;
}
function split (bignum) {
if (typeof(bignum) == 'number') {
var hi = Math.floor(bignum / twoPow32);
return {
lo: Math.floor(bignum - hi * twoPow32),
hi: hi
};
}
return bignum;
}
return {
extend:  Ext.data.IdGenerator ,
alias: 'idgen.uuid',
id: 'uuid', 
version: 4,
constructor: function() {
var me = this;
me.callParent(arguments);
me.parts = [];
me.init();
},
generate: function () {
var me = this,
parts = me.parts,
ts = me.timestamp;
parts[0] = toHex(ts.lo, 8);
parts[1] = toHex(ts.hi & 0xFFFF, 4);
parts[2] = toHex(((ts.hi >>> 16) & 0xFFF) | (me.version << 12), 4);
parts[3] = toHex(0x80 | ((me.clockSeq >>> 8) & 0x3F), 2) +
toHex(me.clockSeq & 0xFF, 2);
parts[4] = toHex(me.salt.hi, 4) + toHex(me.salt.lo, 8);
if (me.version == 4) {
me.init(); 
} else {
++ts.lo;
if (ts.lo >= twoPow32) { 
ts.lo = 0;
++ts.hi;
}
}
return parts.join('-').toLowerCase();
},
getRecId: function (rec) {
return rec.getId();
},
init: function () {
var me = this,
salt, time;
if (me.version == 4) {
me.clockSeq = rand(0, twoPow14-1);
salt = me.salt || (me.salt = {});
time = me.timestamp || (me.timestamp = {});
salt.lo = rand(0, twoPow32-1);
salt.hi = rand(0, twoPow16-1);
time.lo = rand(0, twoPow32-1);
time.hi = rand(0, twoPow28-1);
} else {
me.salt = split(me.salt);
me.timestamp = split(me.timestamp);
me.salt.hi |= 0x100;
}
},
reconfigure: function (config) {
Ext.apply(this, config);
this.init();
}
};
}()));
Ext.define('Ext.data.association.BelongsTo', {
extend:  Ext.data.association.Association ,
alternateClassName: 'Ext.data.BelongsToAssociation',
alias: 'association.belongsto',
constructor: function(config) {
this.callParent(arguments);
var me             = this,
ownerProto     = me.ownerModel.prototype,
associatedName = me.associatedName,
getterName     = me.getterName || 'get' + associatedName,
setterName     = me.setterName || 'set' + associatedName;
Ext.applyIf(me, {
name        : associatedName,
foreignKey  : associatedName.toLowerCase() + "_id",
instanceName: associatedName + 'BelongsToInstance',
associationKey: associatedName.toLowerCase()
});
ownerProto[getterName] = me.createGetter();
ownerProto[setterName] = me.createSetter();
},
createSetter: function() {
var me = this,
foreignKey = me.foreignKey,
instanceName = me.instanceName;
return function(value, options, scope) {
var setByRecord = value && value.isModel,
valueToSet = setByRecord ? value.getId() : value;
if (setByRecord) {
this[instanceName] = value;
}
else if (this[instanceName] instanceof Ext.data.Model && !this.isEqual(this.get(foreignKey), valueToSet)) {
delete this[instanceName];
}
this.set(foreignKey, valueToSet);
if (Ext.isFunction(options)) {
options = {
callback: options,
scope: scope || this
};
}
if (Ext.isObject(options)) {
return this.save(options);
}
};
},
createGetter: function() {
var me              = this,
associatedName  = me.associatedName,
associatedModel = me.associatedModel,
foreignKey      = me.foreignKey,
primaryKey      = me.primaryKey,
instanceName    = me.instanceName;
return function(options, scope) {
options = options || {};
var model = this,
foreignKeyId = model.get(foreignKey),
success,
instance,
args;
if (options.reload === true || model[instanceName] === undefined) {
instance = Ext.ModelManager.create({}, associatedName);
instance.set(primaryKey, foreignKeyId);
if (typeof options == 'function') {
options = {
callback: options,
scope: scope || model
};
}
success = options.success;
options.success = function(rec){
model[instanceName] = rec;
if (success) {
success.apply(this, arguments);
}
};
associatedModel.load(foreignKeyId, options);
model[instanceName] = instance;
return instance;
} else {
instance = model[instanceName];
args = [instance];
scope = scope || options.scope || model;
Ext.callback(options, scope, args);
Ext.callback(options.success, scope, args);
Ext.callback(options.failure, scope, args);
Ext.callback(options.callback, scope, args);
return instance;
}
};
},
read: function(record, reader, associationData){
record[this.instanceName] = reader.read([associationData]).records[0];
}
});
Ext.define('Ext.util.Inflector', {
singleton: true,
plurals: [
[(/(quiz)$/i),                "$1zes"  ],
[(/^(ox)$/i),                 "$1en"   ],
[(/([m|l])ouse$/i),           "$1ice"  ],
[(/(matr|vert|ind)ix|ex$/i),  "$1ices" ],
[(/(x|ch|ss|sh)$/i),          "$1es"   ],
[(/([^aeiouy]|qu)y$/i),       "$1ies"  ],
[(/(hive)$/i),                "$1s"    ],
[(/(?:([^f])fe|([lr])f)$/i),  "$1$2ves"],
[(/sis$/i),                   "ses"    ],
[(/([ti])um$/i),              "$1a"    ],
[(/(buffal|tomat|potat)o$/i), "$1oes"  ],
[(/(bu)s$/i),                 "$1ses"  ],
[(/(alias|status|sex)$/i),    "$1es"   ],
[(/(octop|vir)us$/i),         "$1i"    ],
[(/(ax|test)is$/i),           "$1es"   ],
[(/^person$/),                "people" ],
[(/^man$/),                   "men"    ],
[(/^(child)$/),               "$1ren"  ],
[(/s$/i),                     "s"      ],
[(/$/),                       "s"      ]
],
singulars: [
[(/(quiz)zes$/i),                                                    "$1"     ],
[(/(matr)ices$/i),                                                   "$1ix"   ],
[(/(vert|ind)ices$/i),                                               "$1ex"   ],
[(/^(ox)en/i),                                                       "$1"     ],
[(/(alias|status)es$/i),                                             "$1"     ],
[(/(octop|vir)i$/i),                                                 "$1us"   ],
[(/(cris|ax|test)es$/i),                                             "$1is"   ],
[(/(shoe)s$/i),                                                      "$1"     ],
[(/(o)es$/i),                                                        "$1"     ],
[(/(bus)es$/i),                                                      "$1"     ],
[(/([m|l])ice$/i),                                                   "$1ouse" ],
[(/(x|ch|ss|sh)es$/i),                                               "$1"     ],
[(/(m)ovies$/i),                                                     "$1ovie" ],
[(/(s)eries$/i),                                                     "$1eries"],
[(/([^aeiouy]|qu)ies$/i),                                            "$1y"    ],
[(/([lr])ves$/i),                                                    "$1f"    ],
[(/(tive)s$/i),                                                      "$1"     ],
[(/(hive)s$/i),                                                      "$1"     ],
[(/([^f])ves$/i),                                                    "$1fe"   ],
[(/(^analy)ses$/i),                                                  "$1sis"  ],
[(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i), "$1$2sis"],
[(/([ti])a$/i),                                                      "$1um"   ],
[(/(n)ews$/i),                                                       "$1ews"  ],
[(/people$/i),                                                       "person" ],
[(/s$/i),                                                            ""       ]
],
uncountable: [
"sheep",
"fish",
"series",
"species",
"money",
"rice",
"information",
"equipment",
"grass",
"mud",
"offspring",
"deer",
"means"
],
singular: function(matcher, replacer) {
this.singulars.unshift([matcher, replacer]);
},
plural: function(matcher, replacer) {
this.plurals.unshift([matcher, replacer]);
},
clearSingulars: function() {
this.singulars = [];
},
clearPlurals: function() {
this.plurals = [];
},
isTransnumeral: function(word) {
return Ext.Array.indexOf(this.uncountable, word) != -1;
},
pluralize: function(word) {
if (this.isTransnumeral(word)) {
return word;
}
var plurals = this.plurals,
length  = plurals.length,
tuple, regex, i;
for (i = 0; i < length; i++) {
tuple = plurals[i];
regex = tuple[0];
if (regex == word || (regex.test && regex.test(word))) {
return word.replace(regex, tuple[1]);
}
}
return word;
},
singularize: function(word) {
if (this.isTransnumeral(word)) {
return word;
}
var singulars = this.singulars,
length    = singulars.length,
tuple, regex, i;
for (i = 0; i < length; i++) {
tuple = singulars[i];
regex = tuple[0];
if (regex == word || (regex.test && regex.test(word))) {
return word.replace(regex, tuple[1]);
}
}
return word;
},
classify: function(word) {
return Ext.String.capitalize(this.singularize(word));
},
ordinalize: function(number) {
var parsed = parseInt(number, 10),
mod10  = parsed % 10,
mod100 = parsed % 100;
if (11 <= mod100 && mod100 <= 13) {
return number + "th";
} else {
switch(mod10) {
case 1 : return number + "st";
case 2 : return number + "nd";
case 3 : return number + "rd";
default: return number + "th";
}
}
}
}, function() {
var irregulars = {
alumnus: 'alumni',
cactus : 'cacti',
focus  : 'foci',
nucleus: 'nuclei',
radius: 'radii',
stimulus: 'stimuli',
ellipsis: 'ellipses',
paralysis: 'paralyses',
oasis: 'oases',
appendix: 'appendices',
index: 'indexes',
beau: 'beaux',
bureau: 'bureaux',
tableau: 'tableaux',
woman: 'women',
child: 'children',
man: 'men',
corpus:	'corpora',
criterion: 'criteria',
curriculum:	'curricula',
genus: 'genera',
memorandum:	'memoranda',
phenomenon:	'phenomena',
foot: 'feet',
goose: 'geese',
tooth: 'teeth',
antenna: 'antennae',
formula: 'formulae',
nebula: 'nebulae',
vertebra: 'vertebrae',
vita: 'vitae'
},
singular;
for (singular in irregulars) {
this.plural(singular, irregulars[singular]);
this.singular(irregulars[singular], singular);
}
});
Ext.define('Ext.data.association.HasMany', {
extend:  Ext.data.association.Association ,
alternateClassName: 'Ext.data.HasManyAssociation',
alias: 'association.hasmany',
constructor: function(config) {
var me = this,
ownerProto,
name;
me.callParent(arguments);
me.name = me.name || Ext.util.Inflector.pluralize(me.associatedName.toLowerCase());
ownerProto = me.ownerModel.prototype;
name = me.name;
Ext.applyIf(me, {
storeName : name + "Store",
foreignKey: me.ownerName.toLowerCase() + "_id"
});
ownerProto[name] = me.createStore();
},
createStore: function() {
var that            = this,
associatedModel = that.associatedModel,
storeName       = that.storeName,
foreignKey      = that.foreignKey,
primaryKey      = that.primaryKey,
filterProperty  = that.filterProperty,
autoLoad        = that.autoLoad,
storeConfig     = that.storeConfig || {};
return function() {
var me = this,
config, filter,
modelDefaults = {},
id;
if (me[storeName] === undefined) {
id = me.get(primaryKey);
if (filterProperty) {
filter = {
property  : filterProperty,
value     : me.get(filterProperty),
exactMatch: true
};
} else if (me.hasId(id)) {
filter = {
property  : foreignKey,
value     : id,
exactMatch: true
};
}
modelDefaults[foreignKey] = me.get(primaryKey);
config = Ext.apply({}, storeConfig, {
model        : associatedModel,
filters      : filter ? [filter] : undefined,
remoteFilter : false,
modelDefaults: modelDefaults,
disableMetaChangeEvent: true
});
me[storeName] = Ext.data.AbstractStore.create(config);
if (autoLoad) {
me[storeName].load();
}
}
return me[storeName];
};
},
read: function(record, reader, associationData){
var store = record[this.name](),
inverse,
items, iLen, i;
store.add(reader.read(associationData).records);
inverse = this.associatedModel.prototype.associations.findBy(function(assoc){
return assoc.type === 'belongsTo' && assoc.associatedName === record.$className;
});
if (inverse) {
items = store.data.items;
iLen  = items.length;
for (i = 0; i < iLen; i++) {
items[i][inverse.instanceName] = record;
}
}
}
});
Ext.define('Ext.data.association.HasOne', {
extend:  Ext.data.association.Association ,
alternateClassName: 'Ext.data.HasOneAssociation',
alias: 'association.hasone',
constructor: function(config) {
this.callParent(arguments);
var me             = this,
ownerProto     = me.ownerModel.prototype,
associatedName = me.associatedName,
getterName     = me.getterName || 'get' + associatedName,
setterName     = me.setterName || 'set' + associatedName;
Ext.applyIf(me, {
name        : associatedName,
foreignKey  : associatedName.toLowerCase() + "_id",
instanceName: associatedName + 'HasOneInstance',
associationKey: associatedName.toLowerCase()
});
ownerProto[getterName] = me.createGetter();
ownerProto[setterName] = me.createSetter();
},
createSetter: function() {
var me              = this,
foreignKey      = me.foreignKey,
instanceName = me.instanceName;
return function(value, options, scope) {
var setByRecord = value && value.isModel,
valueToSet = setByRecord ? value.getId() : value;
if (setByRecord) {
this[instanceName] = value;
}
else if (this[instanceName] instanceof Ext.data.Model && !this.isEqual(this.get(foreignKey), valueToSet)) {
delete this[instanceName];
}
this.set(foreignKey, valueToSet);
if (Ext.isFunction(options)) {
options = {
callback: options,
scope: scope || this
};
}
if (Ext.isObject(options)) {
return this.save(options);
}
};
},
createGetter: function() {
var me              = this,
ownerModel      = me.ownerModel,
associatedName  = me.associatedName,
associatedModel = me.associatedModel,
foreignKey      = me.foreignKey,
primaryKey      = me.primaryKey,
instanceName    = me.instanceName;
return function(options, scope) {
options = options || {};
var model = this,
foreignKeyId = model.get(foreignKey),
success,
instance,
args;
if (options.reload === true || model[instanceName] === undefined) {
instance = Ext.ModelManager.create({}, associatedName);
instance.set(primaryKey, foreignKeyId);
if (typeof options == 'function') {
options = {
callback: options,
scope: scope || model
};
}
success = options.success;
options.success = function(rec){
model[instanceName] = rec;
if (success) {
success.apply(this, arguments);
}
};
associatedModel.load(foreignKeyId, options);
model[instanceName] = instance;
return instance;
} else {
instance = model[instanceName];
args = [instance];
scope = scope || options.scope || model;
Ext.callback(options, scope, args);
Ext.callback(options.success, scope, args);
Ext.callback(options.failure, scope, args);
Ext.callback(options.callback, scope, args);
return instance;
}
};
},
read: function(record, reader, associationData){
var inverse = this.associatedModel.prototype.associations.findBy(function(assoc){
return assoc.type === 'belongsTo' && assoc.associatedName === record.$className;
}), newRecord = reader.read([associationData]).records[0];
record[this.instanceName] = newRecord;
if (inverse) {
newRecord[inverse.instanceName] = record;
}
}
});
Ext.define('Ext.dd.DDTarget', {
extend:  Ext.dd.DragDrop ,
constructor: function(id, sGroup, config) {
if (id) {
this.initTarget(id, sGroup, config);
}
},
getDragEl: Ext.emptyFn,
isValidHandleChild: Ext.emptyFn,
startDrag: Ext.emptyFn,
endDrag: Ext.emptyFn,
onDrag: Ext.emptyFn,
onDragDrop: Ext.emptyFn,
onDragEnter: Ext.emptyFn,
onDragOut: Ext.emptyFn,
onDragOver: Ext.emptyFn,
onInvalidDrop: Ext.emptyFn,
onMouseDown: Ext.emptyFn,
onMouseUp: Ext.emptyFn,
setXConstraint: Ext.emptyFn,
setYConstraint: Ext.emptyFn,
resetConstraints: Ext.emptyFn,
clearConstraints: Ext.emptyFn,
clearTicks: Ext.emptyFn,
setInitPosition: Ext.emptyFn,
setDragElId: Ext.emptyFn,
setHandleElId: Ext.emptyFn,
setOuterHandleElId: Ext.emptyFn,
addInvalidHandleClass: Ext.emptyFn,
addInvalidHandleId: Ext.emptyFn,
addInvalidHandleType: Ext.emptyFn,
removeInvalidHandleClass: Ext.emptyFn,
removeInvalidHandleId: Ext.emptyFn,
removeInvalidHandleType: Ext.emptyFn,
toString: function() {
return ("DDTarget " + this.id);
}
});
Ext.define('Ext.dd.DragTracker', {
mixins: {
observable:  Ext.util.Observable 
},
active: false,
trackOver: false,
tolerance: 5,
autoStart: false,
constructor : function(config){
var me = this;
Ext.apply(me, config);
me.addEvents(
'mouseover',
'mouseout',
'mousedown',
'mouseup',
'mousemove',
'beforedragstart',
'dragstart',
'dragend',
'drag'
);
me.dragRegion = new Ext.util.Region(0,0,0,0);
if (me.el) {
me.initEl(me.el);
}
me.mixins.observable.constructor.call(me);
if (me.disabled) {
me.disable();
}
},
initEl: function(el) {
var me = this;
me.el = Ext.get(el);
me.handle = Ext.get(me.delegate);
me.delegate = me.handle ? undefined : me.delegate;
if (!me.handle) {
me.handle = me.el;
}
me.handleListeners = {
scope: me,
delegate: me.delegate,
mousedown: me.onMouseDown
};
if (me.trackOver || me.overCls) {
Ext.apply(me.handleListeners, {
mouseover: me.onMouseOver,
mouseout: me.onMouseOut
});
}
me.mon(me.handle, me.handleListeners);
},
disable: function() {
this.disabled = true;
},
enable: function() {
this.disabled = false;
},
destroy : function() {
var me = this;
if (me.active) {
me.endDrag({});
}
me.clearListeners();
me.mun(me.handle, me.handleListeners);
me.el = me.handle = null;
},
onMouseOver: function(e, target) {
var me = this;
if (!me.disabled) {
if (Ext.EventManager.contains(e) || me.delegate) {
me.mouseIsOut = false;
if (me.overCls) {
me.el.addCls(me.overCls);
}
me.fireEvent('mouseover', me, e, me.delegate ? e.getTarget(me.delegate, target) : me.handle);
}
}
},
onMouseOut: function(e) {
var me = this;
if (me.mouseIsDown) {
me.mouseIsOut = true;
} else {
if (me.overCls) {
me.el.removeCls(me.overCls);
}
me.fireEvent('mouseout', me, e);
}
},
onMouseDown: function(e, target){
var me = this,
el;
if (me.disabled ||e.dragTracked) {
return;
}
me.dragTarget = me.delegate ? target : me.handle.dom;
me.startXY = me.lastXY = e.getXY();
me.startRegion = Ext.fly(me.dragTarget).getRegion();
if (me.fireEvent('mousedown', me, e) === false ||
me.fireEvent('beforedragstart', me, e) === false ||
me.onBeforeStart(e) === false) {
return;
}
me.mouseIsDown = true;
e.dragTracked = true;
el = me.el.dom;
if (Ext.isIE && el.setCapture) {
el.setCapture();
}
if (me.preventDefault !== false) {
e.preventDefault();
}
Ext.getDoc().on({
scope: me,
mouseup: me.onMouseUp,
mousemove: me.onMouseMove,
selectstart: me.stopSelect
});
if (me.autoStart) {
me.timer =  Ext.defer(me.triggerStart, me.autoStart === true ? 1000 : me.autoStart, me, [e]);
}
},
onMouseMove: function(e, target){
var me = this,
xy = e.getXY(),
s = me.startXY;
e.preventDefault();
me.lastXY = xy;
if (!me.active) {
if (Math.max(Math.abs(s[0]-xy[0]), Math.abs(s[1]-xy[1])) > me.tolerance) {
me.triggerStart(e);
} else {
return;
}
}
if (me.fireEvent('mousemove', me, e) === false) {
me.onMouseUp(e);
} else {
me.onDrag(e);
me.fireEvent('drag', me, e);
}
},
onMouseUp: function(e) {
var me = this;
me.mouseIsDown = false;
if (me.mouseIsOut) {
me.mouseIsOut = false;
me.onMouseOut(e);
}
e.preventDefault();
if (Ext.isIE && document.releaseCapture) {
document.releaseCapture();
}
me.fireEvent('mouseup', me, e);
me.endDrag(e);
},
endDrag: function(e) {
var me = this,
wasActive = me.active;
Ext.getDoc().un({
mousemove: me.onMouseMove,
mouseup: me.onMouseUp,
selectstart: me.stopSelect,
scope: me
});
me.clearStart();
me.active = false;
if (wasActive) {
me.onEnd(e);
me.fireEvent('dragend', me, e);
}
me._constrainRegion = Ext.EventObject.dragTracked = null
},
triggerStart: function(e) {
var me = this;
me.clearStart();
me.active = true;
me.onStart(e);
me.fireEvent('dragstart', me, e);
},
clearStart : function() {
var timer = this.timer;
if (timer) {
clearTimeout(timer);
this.timer = null;
}
},
stopSelect : function(e) {
e.stopEvent();
return false;
},
onBeforeStart : function(e) {
},
onStart : function(xy) {
},
onDrag : function(e) {
},
onEnd : function(e) {
},
getDragTarget : function(){
return this.dragTarget;
},
getDragCt : function(){
return this.el;
},
getConstrainRegion: function() {
var me = this;
if (me.constrainTo) {
if (me.constrainTo instanceof Ext.util.Region) {
return me.constrainTo;
}
if (!me._constrainRegion) {
me._constrainRegion = Ext.fly(me.constrainTo).getViewRegion();
}
} else {
if (!me._constrainRegion) {
me._constrainRegion = me.getDragCt().getViewRegion();
}
}
return me._constrainRegion;
},
getXY : function(constrain){
return constrain ? this.constrainModes[constrain](this, this.lastXY) : this.lastXY;
},
getOffset : function(constrain){
var xy = this.getXY(constrain),
s = this.startXY;
return [xy[0]-s[0], xy[1]-s[1]];
},
constrainModes: {
point: function(me, xy) {
var dr = me.dragRegion,
constrainTo = me.getConstrainRegion();
if (!constrainTo) {
return xy;
}
dr.x = dr.left = dr[0] = dr.right = xy[0];
dr.y = dr.top = dr[1] = dr.bottom = xy[1];
dr.constrainTo(constrainTo);
return [dr.left, dr.top];
},
dragTarget: function(me, xy) {
var s = me.startXY,
dr = me.startRegion.copy(),
constrainTo = me.getConstrainRegion(),
adjust;
if (!constrainTo) {
return xy;
}
dr.translateBy(xy[0]-s[0], xy[1]-s[1]);
if (dr.right > constrainTo.right) {
xy[0] += adjust = (constrainTo.right - dr.right);    
dr.left += adjust;
}
if (dr.left < constrainTo.left) {
xy[0] += (constrainTo.left - dr.left);      
}
if (dr.bottom > constrainTo.bottom) {
xy[1] += adjust = (constrainTo.bottom - dr.bottom);  
dr.top += adjust;
}
if (dr.top < constrainTo.top) {
xy[1] += (constrainTo.top - dr.top);        
}
return xy;
}
}
});
Ext.define('Ext.dd.DragZone', {
extend:  Ext.dd.DragSource ,
constructor : function(el, config){
var me = this,
scroll = me.containerScroll;
me.callParent([el, config]);
if (scroll) {
el = me.scrollEl || el;
el = Ext.get(el);
if (Ext.isObject(scroll)) {
el.ddScrollConfig = scroll;
}
Ext.dd.ScrollManager.register(el);
}
},
getDragData : function(e){
return Ext.dd.Registry.getHandleFromEvent(e);
},
onInitDrag : function(x, y){
this.proxy.update(this.dragData.ddel.cloneNode(true));
this.onStartDrag(x, y);
return true;
},
getRepairXY : function(e){
return Ext.fly(this.dragData.ddel).getXY();
},
destroy : function(){
this.callParent();
if (this.containerScroll) {
Ext.dd.ScrollManager.unregister(this.scrollEl || this.el);
}
}
});
Ext.define('Ext.dd.ScrollManager', {
singleton: true,
constructor: function() {
var ddm = Ext.dd.DragDropManager;
ddm.fireEvents = Ext.Function.createSequence(ddm.fireEvents, this.onFire, this);
ddm.stopDrag = Ext.Function.createSequence(ddm.stopDrag, this.onStop, this);
this.doScroll = Ext.Function.bind(this.doScroll, this);
this.ddmInstance = ddm;
this.els = {};
this.dragEl = null;
this.proc = {};
},
onStop: function(e){
var sm = Ext.dd.ScrollManager;
sm.dragEl = null;
sm.clearProc();
},
triggerRefresh: function() {
if (this.ddmInstance.dragCurrent) {
this.ddmInstance.refreshCache(this.ddmInstance.dragCurrent.groups);
}
},
doScroll: function() {
if (this.ddmInstance.dragCurrent) {
var proc   = this.proc,
procEl = proc.el,
ddScrollConfig = proc.el.ddScrollConfig,
inc =     ddScrollConfig && ddScrollConfig.increment    ? ddScrollConfig.increment : this.increment,
animate = ddScrollConfig && 'animate' in ddScrollConfig ? ddScrollConfig.animate   : this.animate;
if (!animate) {
if (procEl.scroll(proc.dir, inc)) {
this.triggerRefresh();
}
} else {
procEl.scroll(proc.dir, inc, true, this.animDuration, this.triggerRefresh);
}
}
},
clearProc: function() {
var proc = this.proc;
if (proc.id) {
clearInterval(proc.id);
}
proc.id = 0;
proc.el = null;
proc.dir = "";
},
startProc: function(el, dir) {
this.clearProc();
this.proc.el = el;
this.proc.dir = dir;
var group = el.ddScrollConfig ? el.ddScrollConfig.ddGroup : undefined,
freq  = (el.ddScrollConfig && el.ddScrollConfig.frequency)
? el.ddScrollConfig.frequency
: this.frequency;
if (group === undefined || this.ddmInstance.dragCurrent.ddGroup == group) {
this.proc.id = setInterval(this.doScroll, freq);
}
},
onFire: function(e, isDrop) {
if (isDrop || !this.ddmInstance.dragCurrent) {
return;
}
if (!this.dragEl || this.dragEl != this.ddmInstance.dragCurrent) {
this.dragEl = this.ddmInstance.dragCurrent;
this.refreshCache();
}
var pt = e.getPoint(),
proc = this.proc,
els = this.els,
id, el, r, c;
for (id in els) {
el = els[id];
r = el._region;
c = el.ddScrollConfig ? el.ddScrollConfig : this;
if (r && r.contains(pt) && el.isScrollable()) {
if (r.bottom - pt.y <= c.vthresh) {
if(proc.el != el){
this.startProc(el, "down");
}
return;
}else if (r.right - pt.x <= c.hthresh) {
if (proc.el != el) {
this.startProc(el, "right");
}
return;
} else if(pt.y - r.top <= c.vthresh) {
if (proc.el != el) {
this.startProc(el, "up");
}
return;
} else if(pt.x - r.left <= c.hthresh) {
if (proc.el != el) {
this.startProc(el, "left");
}
return;
}
}
}
this.clearProc();
},
register : function(el){
if (Ext.isArray(el)) {
for(var i = 0, len = el.length; i < len; i++) {
this.register(el[i]);
}
} else {
el = Ext.get(el);
this.els[el.id] = el;
}
},
unregister : function(el){
if(Ext.isArray(el)){
for (var i = 0, len = el.length; i < len; i++) {
this.unregister(el[i]);
}
}else{
el = Ext.get(el);
delete this.els[el.id];
}
},
vthresh : 25,
hthresh : 25,
increment : 100,
frequency : 500,
animate: true,
animDuration: 0.4,
ddGroup: undefined,
refreshCache : function(){
var els = this.els,
id;
for (id in els) {
if(typeof els[id] == 'object'){ 
els[id]._region = els[id].getRegion();
}
}
}
});
Ext.define('Ext.dd.DropTarget', {
extend:  Ext.dd.DDTarget ,
constructor : function(el, config){
this.el = Ext.get(el);
Ext.apply(this, config);
if(this.containerScroll){
Ext.dd.ScrollManager.register(this.el);
}
this.callParent([this.el.dom, this.ddGroup || this.group,
{isTarget: true}]);
},
dropAllowed : Ext.baseCSSPrefix + 'dd-drop-ok',
dropNotAllowed : Ext.baseCSSPrefix + 'dd-drop-nodrop',
isTarget : true,
isNotifyTarget : true,
notifyEnter : function(dd, e, data){
if(this.overClass){
this.el.addCls(this.overClass);
}
return this.dropAllowed;
},
notifyOver : function(dd, e, data){
return this.dropAllowed;
},
notifyOut : function(dd, e, data){
if(this.overClass){
this.el.removeCls(this.overClass);
}
},
notifyDrop : function(dd, e, data){
return false;
},
destroy : function(){
this.callParent();
if(this.containerScroll){
Ext.dd.ScrollManager.unregister(this.el);
}
}
});
Ext.define('Ext.dd.Registry', {
singleton: true,
constructor: function() {
this.elements = {}; 
this.handles = {}; 
this.autoIdSeed = 0;
},
getId: function(el, autogen){
if(typeof el == "string"){
return el;
}
var id = el.id;
if(!id && autogen !== false){
id = "extdd-" + (++this.autoIdSeed);
el.id = id;
}
return id;
},
register : function(el, data){
data = data || {};
if (typeof el == "string") {
el = document.getElementById(el);
}
data.ddel = el;
this.elements[this.getId(el)] = data;
if (data.isHandle !== false) {
this.handles[data.ddel.id] = data;
}
if (data.handles) {
var hs = data.handles,
i, len;
for (i = 0, len = hs.length; i < len; i++) {
this.handles[this.getId(hs[i])] = data;
}
}
},
unregister : function(el){
var id = this.getId(el, false),
data = this.elements[id],
hs, i, len;
if(data){
delete this.elements[id];
if(data.handles){
hs = data.handles;
for (i = 0, len = hs.length; i < len; i++) {
delete this.handles[this.getId(hs[i], false)];
}
}
}
},
getHandle : function(id){
if(typeof id != "string"){ 
id = id.id;
}
return this.handles[id];
},
getHandleFromEvent : function(e){
var t = e.getTarget();
return t ? this.handles[t.id] : null;
},
getTarget : function(id){
if(typeof id != "string"){ 
id = id.id;
}
return this.elements[id];
},
getTargetFromEvent : function(e){
var t = e.getTarget();
return t ? this.elements[t.id] || this.handles[t.id] : null;
}
});
Ext.define('Ext.dd.DropZone', {
extend:  Ext.dd.DropTarget ,
getTargetFromEvent : function(e){
return Ext.dd.Registry.getTargetFromEvent(e);
},
onNodeEnter : function(n, dd, e, data){
},
onNodeOver : function(n, dd, e, data){
return this.dropAllowed;
},
onNodeOut : function(n, dd, e, data){
},
onNodeDrop : function(n, dd, e, data){
return false;
},
onContainerOver : function(dd, e, data){
return this.dropNotAllowed;
},
onContainerDrop : function(dd, e, data){
return false;
},
notifyEnter : function(dd, e, data){
return this.dropNotAllowed;
},
notifyOver : function(dd, e, data){
var n = this.getTargetFromEvent(e);
if(!n) { 
if(this.lastOverNode){
this.onNodeOut(this.lastOverNode, dd, e, data);
this.lastOverNode = null;
}
return this.onContainerOver(dd, e, data);
}
if(this.lastOverNode != n){
if(this.lastOverNode){
this.onNodeOut(this.lastOverNode, dd, e, data);
}
this.onNodeEnter(n, dd, e, data);
this.lastOverNode = n;
}
return this.onNodeOver(n, dd, e, data);
},
notifyOut : function(dd, e, data){
if(this.lastOverNode){
this.onNodeOut(this.lastOverNode, dd, e, data);
this.lastOverNode = null;
}
},
notifyDrop : function(dd, e, data){
var me = this,
n = me.getTargetFromEvent(e),
result = n ?
me.onNodeDrop(n, dd, e, data) :
me.onContainerDrop(dd, e, data);
if (me.lastOverNode) {
me.onNodeOut(me.lastOverNode, dd, e, data);
me.lastOverNode = null;
}
return result;
},
triggerCacheRefresh : function() {
Ext.dd.DDM.refreshCache(this.groups);
}
});
Ext.define('Ext.dom.Layer', {
extend:  Ext.Element ,
alternateClassName: 'Ext.Layer',
statics: {
shims: []
},
isLayer: true,
localXYNames: {
get: 'getLocalXY',
set: 'setLocalXY'
},
constructor: function(config, existingEl) {
config = config || {};
var me = this,
dh = Ext.DomHelper,
cp = config.parentEl,
pel = cp ? Ext.getDom(cp) : document.body,
hm = config.hideMode,
cls = Ext.baseCSSPrefix + (config.fixed && !(Ext.isIE6 || Ext.isIEQuirks) ? 'fixed-layer' : 'layer');
me.el = me;
if (existingEl) {
me.dom = Ext.getDom(existingEl);
}
if (!me.dom) {
me.dom = dh.append(pel, config.dh || {
tag: 'div',
cls: cls 
});
} else {
me.addCls(cls);
if (!me.dom.parentNode) {
pel.appendChild(me.dom);
}
}
if (config.preventSync) {
me.preventSync = true;
}
if (config.id) {
me.id = me.dom.id = config.id;
} else {
me.id = Ext.id(me.dom);
}
Ext.Element.addToCache(me);
if (config.cls) {
me.addCls(config.cls);
}
me.constrain = config.constrain !== false;
if (hm) {
me.setVisibilityMode(Ext.Element[hm.toUpperCase()]);
if (me.visibilityMode == Ext.Element.ASCLASS) {
me.visibilityCls = config.visibilityCls;
}
} else if (config.useDisplay) {
me.setVisibilityMode(Ext.Element.DISPLAY);
} else {
me.setVisibilityMode(Ext.Element.VISIBILITY);
}
if (config.shadow) {
me.shadowOffset = config.shadowOffset || 4;
me.shadow = new Ext.Shadow({
offset: me.shadowOffset,
mode: config.shadow,
fixed: config.fixed
});
me.disableShadow();
} else {
me.shadowOffset = 0;
}
me.useShim = config.shim !== false && Ext.useShims;
if (config.hidden === true) {
me.hide();
} else if (config.hidden === false) {
me.show();
}
},
getZIndex: function() {
return parseInt((this.getShim() || this).getStyle('z-index'), 10);
},
getShim: function() {
var me = this,
shim, pn;
if (!me.useShim) {
return null;
}
if (!me.shim) {
shim = me.self.shims.shift();
if (!shim) {
shim = me.createShim();
shim.enableDisplayMode('block');
shim.hide();
}
pn = me.dom.parentNode;
if (shim.dom.parentNode != pn) {
pn.insertBefore(shim.dom, me.dom);
}
me.shim = shim;
}
return me.shim;
},
hideShim: function() {
var me = this;
if (me.shim) {
me.shim.setDisplayed(false);
me.self.shims.push(me.shim);
delete me.shim;
}
},
disableShadow: function() {
var me = this;
if (me.shadow && !me.shadowDisabled) {
me.shadowDisabled = true;
me.shadow.hide();
me.lastShadowOffset = me.shadowOffset;
me.shadowOffset = 0;
}
},
enableShadow: function(show) {
var me = this;
if (me.shadow && me.shadowDisabled) {
me.shadowDisabled = false;
me.shadowOffset = me.lastShadowOffset;
delete me.lastShadowOffset;
if (show) {
me.sync(true);
}
}
},
sync: function(doShow) {
var me = this,
shadow = me.shadow,
shadowPos, shimStyle, shadowSize,
shim, xy, x, y, w, h, shimIndex;
if (me.preventSync) {
return;
}
if (!me.updating && me.isVisible() && (shadow || me.useShim)) {
shim = me.getShim();
xy = me[me.localXYNames.get]();
x = xy[0];
y = xy[1];
w = me.dom.offsetWidth;
h = me.dom.offsetHeight;
if (shadow && !me.shadowDisabled) {
if (doShow && !shadow.isVisible()) {
shadow.show(me);
} else {
shadow.realign(x, y, w, h);
}
if (shim) {
shimIndex = shim.getStyle('z-index');
if (shimIndex > me.zindex) {
me.shim.setStyle('z-index', me.zindex - 2);
}
shim.show();
if (shadow.isVisible()) {
shadowPos = shadow.el.getXY();
shimStyle = shim.dom.style;
shadowSize = shadow.el.getSize();
if (Ext.supports.CSS3BoxShadow) {
shadowSize.height += 6;
shadowSize.width += 4;
shadowPos[0] -= 2;
shadowPos[1] -= 4;
}
shimStyle.left = (shadowPos[0]) + 'px';
shimStyle.top = (shadowPos[1]) + 'px';
shimStyle.width = (shadowSize.width) + 'px';
shimStyle.height = (shadowSize.height) + 'px';
} else {
shim.setSize(w, h);
shim[me.localXYNames.set](x, y);
}
}
} else if (shim) {
shimIndex = shim.getStyle('z-index');
if (shimIndex > me.zindex) {
me.shim.setStyle('z-index', me.zindex - 2);
}
shim.show();
shim.setSize(w, h);
shim[me.localXYNames.set](x, y);
}
}
return me;
},
remove: function() {
this.hideUnders();
this.callParent();
},
beginUpdate: function() {
this.updating = true;
},
endUpdate: function() {
this.updating = false;
this.sync(true);
},
hideUnders: function() {
if (this.shadow) {
this.shadow.hide();
}
this.hideShim();
},
constrainXY: function() {
if (this.constrain) {
var vw = Ext.Element.getViewWidth(),
vh = Ext.Element.getViewHeight(),
s = Ext.getDoc().getScroll(),
xy = this.getXY(),
x = xy[0],
y = xy[1],
so = this.shadowOffset,
w = this.dom.offsetWidth + so,
h = this.dom.offsetHeight + so,
moved = false; 
if ((x + w) > vw + s.left) {
x = vw - w - so;
moved = true;
}
if ((y + h) > vh + s.top) {
y = vh - h - so;
moved = true;
}
if (x < s.left) {
x = s.left;
moved = true;
}
if (y < s.top) {
y = s.top;
moved = true;
}
if (moved) {
Ext.Layer.superclass.setXY.call(this, [x, y]);
this.sync();
}
}
return this;
},
getConstrainOffset: function() {
return this.shadowOffset;
},
setVisible: function(visible, animate, duration, callback, easing) {
var me = this,
cb;
cb = function() {
if (visible) {
me.sync(true);
}
if (callback) {
callback();
}
};
if (!visible) {
me.hideUnders(true);
}
me.callParent([visible, animate, duration, callback, easing]);
if (!animate) {
cb();
}
return me;
},
beforeFx: function() {
this.beforeAction();
return this.callParent(arguments);
},
afterFx: function() {
this.callParent(arguments);
this.sync(this.isVisible());
},
beforeAction: function() {
if (!this.updating && this.shadow) {
this.shadow.hide();
}
},
setLeft: function(left) {
this.callParent(arguments);
return this.sync();
},
setTop: function(top) {
this.callParent(arguments);
return this.sync();
},
setLeftTop: function(left, top) {
this.callParent(arguments);
return this.sync();
},
setLocalX: function() {
this.callParent(arguments);
return this.sync();
},
setLocalXY: function() {
this.callParent(arguments);
return this.sync();
},
setLocalY: function() {
this.callParent(arguments);
return this.sync();
},
setXY: function(xy, animate, duration, callback, easing) {
var me = this;
callback = me.createCB(callback);
me.fixDisplay();
me.beforeAction();
me.callParent([xy, animate, duration, callback, easing]);
if (!animate) {
callback();
}
return me;
},
createCB: function(callback) {
var me = this,
showShadow = me.shadow && me.shadow.isVisible();
return function() {
me.constrainXY();
me.sync(showShadow);
if (callback) {
callback();
}
};
},
setX: function(x, animate, duration, callback, easing) {
this.setXY([x, this.getY()], animate, duration, callback, easing);
return this;
},
setY: function(y, animate, duration, callback, easing) {
this.setXY([this.getX(), y], animate, duration, callback, easing);
return this;
},
setSize: function(w, h, animate, duration, callback, easing) {
var me = this;
callback = me.createCB(callback);
me.beforeAction();
me.callParent([w, h, animate, duration, callback, easing]);
if (!animate) {
callback();
}
return me;
},
setWidth: function(w, animate, duration, callback, easing) {
var me = this;
callback = me.createCB(callback);
me.beforeAction();
me.callParent([w, animate, duration, callback, easing]);
if (!animate) {
callback();
}
return me;
},
setHeight: function(h, animate, duration, callback, easing) {
var me = this;
callback = me.createCB(callback);
me.beforeAction();
me.callParent([h, animate, duration, callback, easing]);
if (!animate) {
callback();
}
return me;
},
setBounds: function(x, y, width, height, animate, duration, callback, easing) {
var me = this;
callback = me.createCB(callback);
me.beforeAction();
if (!animate) {
Ext.Layer.superclass.setXY.call(me, [x, y]);
Ext.Layer.superclass.setSize.call(me, width, height);
callback();
} else {
me.callParent([x, y, width, height, animate, duration, callback, easing]);
}
return me;
},
setZIndex: function(zindex) {
var me = this;
me.zindex = zindex;
if (me.getShim()) {
me.shim.setStyle('z-index', zindex++);
}
if (me.shadow) {
me.shadow.setZIndex(zindex++);
}
return me.setStyle('z-index', zindex);
},
onOpacitySet: function(opacity){
var shadow = this.shadow;
if (shadow) {
shadow.setOpacity(opacity);
}
}
});
Ext.define('Ext.util.ComponentDragger', {
extend:  Ext.dd.DragTracker ,
autoStart: 500,
constructor: function(comp, config) {
this.comp = comp;
this.initialConstrainTo = config.constrainTo;
this.callParent([ config ]);
},
onStart: function(e) {
var me = this,
comp = me.comp;
me.startPosition = comp.getXY();
if (comp.ghost && !comp.liveDrag) {
me.proxy = comp.ghost();
me.dragTarget = me.proxy.header.el;
}
if (me.constrain || me.constrainDelegate) {
me.constrainTo = me.calculateConstrainRegion();
}
if (comp.beginDrag) {
comp.beginDrag();
}
},
calculateConstrainRegion: function() {
var me = this,
comp = me.comp,
constrainTo = me.initialConstrainTo,
constraintInsets = comp.constraintInsets,
constrainEl,
delegateRegion,
elRegion,
dragEl = me.proxy ? me.proxy.el : comp.el,
shadowSize = (!me.constrainDelegate && dragEl.shadow && comp.constrainShadow && !dragEl.shadowDisabled) ? dragEl.shadow.getShadowSize() : 0;
if (!(constrainTo instanceof Ext.util.Region)) {
constrainEl = Ext.fly(constrainTo);
constrainTo =  constrainEl.getViewRegion();
constrainTo.right = constrainTo.left + constrainEl.dom.clientWidth;
} else {
constrainTo = constrainTo.copy();
}
if (constraintInsets) {
constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.length);
}
if (shadowSize) {
constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
}
if (!me.constrainDelegate) {
delegateRegion = Ext.fly(me.dragTarget).getRegion();
elRegion = dragEl.getRegion();
constrainTo.adjust(
delegateRegion.top - elRegion.top,
delegateRegion.right - elRegion.right,
delegateRegion.bottom - elRegion.bottom,
delegateRegion.left - elRegion.left
);
}
return constrainTo;
},
onDrag: function(e) {
var me = this,
comp = (me.proxy && !me.comp.liveDrag) ? me.proxy : me.comp,
offset = me.getOffset(me.constrain || me.constrainDelegate ? 'dragTarget' : null);
comp.setPagePosition(me.startPosition[0] + offset[0], me.startPosition[1] + offset[1]);
},
onEnd: function(e) {
var comp = this.comp;
if (comp.isDestroyed || comp.destroying) {
return;
}
if (this.proxy && !comp.liveDrag) {
comp.unghost();
}
if (comp.endDrag) {
comp.endDrag();
}
}
});
Ext.define("Ext.form.Labelable", {
isLabelable: true,
autoEl: {
tag: 'table',
cellpadding: 0,
role: 'presentation'
},
childEls: [
'labelCell',
'labelEl',
'bodyEl',
'sideErrorCell',
'errorEl',
'inputRow'
],
labelableRenderTpl: [
'<tr role="presentation" id="{id}-inputRow" <tpl if="inFormLayout">id="{id}"</tpl> class="{inputRowCls}">',
'<tpl if="labelOnLeft">',
'<td role="presentation" id="{id}-labelCell" style="{labelCellStyle}" {labelCellAttrs}>',
'{beforeLabelTpl}',
'<label id="{id}-labelEl" {labelAttrTpl}',
'<tpl if="inputId && !(boxLabel && !fieldLabel)"> for="{inputId}"</tpl>',
' class="{labelCls}"',
'<tpl if="labelStyle"> style="{labelStyle}"</tpl>',
' unselectable="on"',
'>',
'{beforeLabelTextTpl}',
'<tpl if="fieldLabel">{fieldLabel}',
'<tpl if="labelSeparator">',
'<span role="separator">{labelSeparator}</span>',
'</tpl>',
'</tpl>',
'{afterLabelTextTpl}',
'</label>',
'{afterLabelTpl}',
'</td>',
'</tpl>',
'<td role="presentation" class="{baseBodyCls} {fieldBodyCls} {extraFieldBodyCls}" id="{id}-bodyEl" colspan="{bodyColspan}" role="presentation">',
'{beforeBodyEl}',
'<tpl if="labelAlign==\'top\'">',
'{beforeLabelTpl}',
'<div role="presentation" id="{id}-labelCell" style="{labelCellStyle}">',
'<label id="{id}-labelEl" {labelAttrTpl}<tpl if="inputId"> for="{inputId}"</tpl> class="{labelCls}"',
'<tpl if="labelStyle"> style="{labelStyle}"</tpl>',
' unselectable="on"',
'>',
'{beforeLabelTextTpl}',
'<tpl if="fieldLabel">{fieldLabel}',
'<tpl if="labelSeparator">',
'<span role="separator">{labelSeparator}</span>',
'</tpl>',
'</tpl>',
'{afterLabelTextTpl}',
'</label>',
'</div>',
'{afterLabelTpl}',
'</tpl>',
'{beforeSubTpl}',
'{[values.$comp.getSubTplMarkup(values)]}',
'{afterSubTpl}',
'<tpl if="msgTarget===\'side\'">',
'{afterBodyEl}',
'</td>',
'<td role="presentation" id="{id}-sideErrorCell" vAlign="{[values.labelAlign===\'top\' && !values.hideLabel ? \'bottom\' : \'middle\']}" style="{[values.autoFitErrors ? \'display:none\' : \'\']}" width="{errorIconWidth}">',
'<div role="alert" aria-live="polite" id="{id}-errorEl" class="{errorMsgCls}" style="display:none"></div>',
'</td>',
'<tpl elseif="msgTarget==\'under\'">',
'<div role="alert" aria-live="polite" id="{id}-errorEl" class="{errorMsgClass}" colspan="2" style="display:none"></div>',
'{afterBodyEl}',
'</td>',
'<tpl else>',
'</td>',
'<td class="x-form-item-label">',
'{afterBodyEl}',
'</td>',
'</tpl>',
'</tr>',
{
disableFormats: true
}
],
activeErrorsTpl: undefined,
htmlActiveErrorsTpl: [
'<tpl if="errors && errors.length">',
'<ul class="{listCls}">',
'<tpl if="Ext.enableAria">',
'<tpl if="fieldLabel"><div>{fieldLabel}</div></tpl>',
'</tpl>',
'<tpl for="errors"><li>{.}</li></tpl>',
'</ul>',
'</tpl>'
],
plaintextActiveErrorsTpl: [
'<tpl if="errors && errors.length">',
'<tpl if="Ext.enableAria">',
'<tpl if="fieldLabel">{fieldLabel}\n</tpl>',
'</tpl>',
'<tpl for="errors"><tpl if="xindex &gt; 1">\n</tpl>{.}</tpl>',
'</tpl>'
],
isFieldLabelable: true,
formItemCls: Ext.baseCSSPrefix + 'form-item',
labelCls: Ext.baseCSSPrefix + 'form-item-label',
errorMsgCls: Ext.baseCSSPrefix + 'form-error-msg',
baseBodyCls: Ext.baseCSSPrefix + 'form-item-body',
inputRowCls: Ext.baseCSSPrefix + 'form-item-input-row',
fieldBodyCls: '',
clearCls: Ext.baseCSSPrefix + 'clear',
invalidCls : Ext.baseCSSPrefix + 'form-invalid',
fieldLabel: undefined,
labelAlign : 'left',
labelWidth: 100,
labelPad : 5,
labelSeparator : ':',
hideLabel: false,
hideEmptyLabel: true,
preventMark: false,
autoFitErrors: true,
msgTarget: 'qtip',
noWrap: true,
labelableInsertions: [
'beforeBodyEl',
'afterBodyEl',
'beforeLabelTpl',
'afterLabelTpl',
'beforeSubTpl',
'afterSubTpl',
'beforeLabelTextTpl',
'afterLabelTextTpl',
'labelAttrTpl'
],
labelableRenderProps: ['allowBlank', 'id', 'labelAlign', 'fieldBodyCls', 'extraFieldBodyCls', 
'baseBodyCls', 'clearCls', 'labelSeparator', 'msgTarget', 'inputRowCls'],
initLabelable: function() {
var me = this,
padding = me.padding;
if (padding) {
me.padding = undefined;
me.extraMargins = Ext.Element.parseBox(padding);
}
if (!me.activeErrorsTpl) {
if (me.msgTarget == 'title') {
me.activeErrorsTpl = me.plaintextActiveErrorsTpl;
} else {
me.activeErrorsTpl = me.htmlActiveErrorsTpl;
}
}
me.addCls(Ext.plainTableCls);
me.addCls(me.formItemCls);
me.lastActiveError = '';
me.addEvents(
'errorchange'
);
me.enableBubble('errorchange');
},
trimLabelSeparator: function() {
var me = this,
separator = me.labelSeparator,
label = me.fieldLabel || '',
lastChar = label.substr(label.length - 1);
return lastChar === separator ? label.slice(0, -1) : label;
},
getFieldLabel: function() {
return this.trimLabelSeparator();
},
setFieldLabel: function(label){
label = label || '';
var me = this,
separator = me.labelSeparator,
labelEl = me.labelEl;
me.fieldLabel = label;
if (me.rendered) {
if (Ext.isEmpty(label) && me.hideEmptyLabel) {
labelEl.parent().setDisplayed('none');
} else {
if (separator) {
label = me.trimLabelSeparator() + separator;
}
labelEl.update(label);
labelEl.parent().setDisplayed('');
}
me.updateLayout();
}
},
getInsertionRenderData: function (data, names) {
var i = names.length,
name, value;
while (i--) {
name = names[i];
value = this[name];
if (value) {
if (typeof value != 'string') {
if (!value.isTemplate) {
value = Ext.XTemplate.getTpl(this, name);
}
value = value.apply(data);
}
}
data[name] = value || '';
}
return data;
},
getLabelableRenderData: function() {
var me = this,
data,
tempEl,
topLabel = me.labelAlign === 'top';
if (!Ext.form.Labelable.errorIconWidth) {
tempEl = Ext.getBody().createChild({style: 'position:absolute', cls: Ext.baseCSSPrefix + 'form-invalid-icon'});
Ext.form.Labelable.errorIconWidth = tempEl.getWidth() + tempEl.getMargin('l');
tempEl.remove();
}
data = Ext.copyTo({
inFormLayout   : me.ownerLayout && me.ownerLayout.type === 'form',
inputId        : me.getInputId(),
labelOnLeft    : !topLabel,
hideLabel      : !me.hasVisibleLabel(),
fieldLabel     : me.getFieldLabel(),
labelCellStyle : me.getLabelCellStyle(),
labelCellAttrs : me.getLabelCellAttrs(),
labelCls       : me.getLabelCls(),
labelStyle     : me.getLabelStyle(),
bodyColspan    : me.getBodyColspan(),
externalError  : !me.autoFitErrors,
errorMsgCls    : me.getErrorMsgCls(),
errorIconWidth : Ext.form.Labelable.errorIconWidth,
boxLabel       : me.boxLabel
},
me, me.labelableRenderProps, true);
me.getInsertionRenderData(data, me.labelableInsertions);
return data;
},
xhooks: {
beforeRender: function() {
var me = this;
me.setFieldDefaults(me.getHierarchyState().fieldDefaults);
if (me.ownerLayout) {
me.addCls(Ext.baseCSSPrefix + me.ownerLayout.type + '-form-item');
}
},
onRender: function() {
var me = this,
margins,
side,
style = {};
if (me.extraMargins) {
margins = me.el.getMargin();
for (side in margins) {
if (margins.hasOwnProperty(side)) {
style['margin-' + side] = (margins[side] + me.extraMargins[side]) + 'px';
}
}
me.el.setStyle(style);
}
}
},
hasVisibleLabel: function(){
if (this.hideLabel) {
return false;
}
return !(this.hideEmptyLabel && !this.getFieldLabel());
},
getLabelWidth: function(){
var me = this;
if (!me.hasVisibleLabel()) {
return 0;
}
return me.labelWidth + me.labelPad;
},
getBodyColspan: function() {
var me = this,
result;
if (me.msgTarget === 'side' && (!me.autoFitErrors || me.hasActiveError())) {
result = 1;
} else {
result = 2;
}
if (me.labelAlign !== 'top' && !me.hasVisibleLabel()) {
result++;
}
return result;
},
getLabelCls: function() {
var labelCls = this.labelCls + ' ' + Ext.dom.Element.unselectableCls,
labelClsExtra = this.labelClsExtra;
return labelClsExtra ? labelCls + ' ' + labelClsExtra : labelCls;
},
getLabelCellStyle: function() {
var me = this,
hideLabelCell = me.hideLabel || (!me.getFieldLabel() && me.hideEmptyLabel);
return hideLabelCell ? 'display:none;' : '';
},
getErrorMsgCls: function() {
var me = this,
hideLabelCell = (me.hideLabel || (!me.fieldLabel && me.hideEmptyLabel));
return me.errorMsgCls + (!hideLabelCell && me.labelAlign === 'top' ? ' ' + Ext.baseCSSPrefix + 'lbl-top-err-icon' : '');
},
getLabelCellAttrs: function() {
var me = this,
labelAlign = me.labelAlign,
result = '';
if (labelAlign !== 'top') {
result = 'valign="top" halign="' + labelAlign + '" width="' + (me.labelWidth + me.labelPad) + '"';
}
return result + ' class="' + Ext.baseCSSPrefix + 'field-label-cell"';
},
getLabelStyle: function(){
var me = this,
labelPad = me.labelPad,
labelStyle = '';
if (me.labelAlign !== 'top') {
if (me.labelWidth) {
labelStyle = 'width:' + me.labelWidth + 'px;';
}
if (labelPad) {
labelStyle += 'margin-right:' + labelPad + 'px;';
}
}
return labelStyle + (me.labelStyle || '');
},
getSubTplMarkup: function() {
return '';
},
getInputId: function() {
return '';
},
getActiveError : function() {
return this.activeError || '';
},
hasActiveError: function() {
return !!this.getActiveError();
},
setActiveError: function(msg) {
this.setActiveErrors(msg);
},
getActiveErrors: function() {
return this.activeErrors || [];
},
setActiveErrors: function(errors) {
var me = this,
tpl;
errors = Ext.Array.from(errors);
tpl = me.getTpl('activeErrorsTpl');
me.activeErrors = errors;
me.activeError = tpl.apply({
fieldLabel: me.fieldLabel,
errors: errors,
listCls: Ext.plainListCls 
});
me.renderActiveError();
},
unsetActiveError: function() {
delete this.activeError;
delete this.activeErrors;
this.renderActiveError();
},
renderActiveError: function() {
var me = this,
activeError = me.getActiveError(),
hasError = !!activeError;
if (activeError !== me.lastActiveError) {
me.fireEvent('errorchange', me, activeError);
me.lastActiveError = activeError;
}
if (me.rendered && !me.isDestroyed && !me.preventMark) {
me.el[hasError ? 'addCls' : 'removeCls'](me.invalidCls);
if (me.errorEl) {
me.errorEl.dom.innerHTML = activeError;
}
}
},
setFieldDefaults: function(defaults) {
var key;
for (key in defaults) {
if (!this.hasOwnProperty(key)) {
this[key] = defaults[key];
}
}
}
});
Ext.define('Ext.form.field.Field', {
isFormField : true,
disabled : false,
submitValue: true,
validateOnChange: true,
suspendCheckChange: 0,
initField: function() {
this.addEvents(
'change',
'validitychange',
'dirtychange'
);
this.initValue();
},
initValue: function() {
var me = this;
me.value = me.transformOriginalValue(me.value);
me.originalValue = me.lastValue = me.value;
me.suspendCheckChange++;
me.setValue(me.value);
me.suspendCheckChange--;
},
transformOriginalValue: Ext.identityFn,
getName: function() {
return this.name;
},
getValue: function() {
return this.value;
},
setValue: function(value) {
var me = this;
me.value = value;
me.checkChange();
return me;
},
isEqual: function(value1, value2) {
return String(value1) === String(value2);
},
isEqualAsString: function(value1, value2){
return String(Ext.value(value1, '')) === String(Ext.value(value2, ''));
},
getSubmitData: function() {
var me = this,
data = null;
if (!me.disabled && me.submitValue) {
data = {};
data[me.getName()] = '' + me.getValue();
}
return data;
},
getModelData: function(includeEmptyText,  isSubmitting) {
var me = this,
data = null;
if (!me.disabled && (me.submitValue || !isSubmitting)) {
data = {};
data[me.getName()] = me.getValue();
}
return data;
},
reset : function(){
var me = this;
me.beforeReset();
me.setValue(me.originalValue);
me.clearInvalid();
delete me.wasValid;
},
beforeReset: Ext.emptyFn,
resetOriginalValue: function() {
this.originalValue = this.getValue();
this.checkDirty();
},
checkChange: function() {
var me = this,
newVal, oldVal;
if (!me.suspendCheckChange) {
newVal = me.getValue();
oldVal = me.lastValue;
if (!me.isDestroyed && me.didValueChange(newVal, oldVal)) {
me.lastValue = newVal;
me.fireEvent('change', me, newVal, oldVal);
me.onChange(newVal, oldVal);
}
}
},
didValueChange: function(newVal, oldVal){
return !this.isEqual(newVal, oldVal);
},
onChange: function(newVal, oldVal) {
if (this.validateOnChange) {
this.validate();
}
this.checkDirty();
},
isDirty : function() {
var me = this;
return !me.disabled && !me.isEqual(me.getValue(), me.originalValue);
},
checkDirty: function() {
var me = this,
isDirty = me.isDirty();
if (isDirty !== me.wasDirty) {
me.fireEvent('dirtychange', me, isDirty);
me.onDirtyChange(isDirty);
me.wasDirty = isDirty;
}
},
onDirtyChange: Ext.emptyFn,
getErrors: function(value) {
return [];
},
isValid : function() {
var me = this;
return me.disabled || Ext.isEmpty(me.getErrors());
},
validate : function() {
var me = this,
isValid = me.isValid();
if (isValid !== me.wasValid) {
me.wasValid = isValid;
me.fireEvent('validitychange', me, isValid);
}
return isValid;
},
batchChanges: function(fn) {
try {
this.suspendCheckChange++;
fn();
} catch(e){
throw e;
} finally {
this.suspendCheckChange--;
}
this.checkChange();
},
isFileUpload: function() {
return false;
},
extractFileInput: function() {
return null;
},
markInvalid: Ext.emptyFn,
clearInvalid: Ext.emptyFn
});
Ext.define('Ext.layout.component.field.Field', {
extend:  Ext.layout.component.Auto ,
alias: 'layout.field',
type: 'field',
naturalSizingProp: 'size',
beginLayout: function(ownerContext) {
var me = this,
owner = me.owner;
me.callParent(arguments);
ownerContext.labelStrategy = me.getLabelStrategy();
ownerContext.errorStrategy = me.getErrorStrategy();
ownerContext.labelContext = ownerContext.getEl('labelEl');
ownerContext.bodyCellContext = ownerContext.getEl('bodyEl');
ownerContext.inputContext = ownerContext.getEl('inputEl');
ownerContext.errorContext = ownerContext.getEl('errorEl');
if (Ext.isIE7m && Ext.isStrict && ownerContext.inputContext) {
me.ieInputWidthAdjustment = ownerContext.inputContext.getPaddingInfo().width + ownerContext.inputContext.getBorderInfo().width;
}
ownerContext.labelStrategy.prepare(ownerContext, owner);
ownerContext.errorStrategy.prepare(ownerContext, owner);
},
beginLayoutCycle: function(ownerContext){
var me = this,
owner = me.owner,
widthModel = ownerContext.widthModel,
ownerNaturalSize = owner[me.naturalSizingProp],
width;
me.callParent(arguments);
if (widthModel.shrinkWrap) {
me.beginLayoutShrinkWrap(ownerContext);
} else if (widthModel.natural) {
if (typeof ownerNaturalSize == 'number' && !owner.inputWidth) {
me.beginLayoutFixed(ownerContext, (width = ownerNaturalSize * 6.5 + 20), 'px');
}
else {
me.beginLayoutShrinkWrap(ownerContext);
}
ownerContext.setWidth(width, false);
} else {
me.beginLayoutFixed(ownerContext, '100', '%');
}    
},
beginLayoutFixed: function (ownerContext, width, suffix) {
var owner = ownerContext.target,
inputEl = owner.inputEl,
inputWidth = owner.inputWidth;
owner.el.setStyle('table-layout', 'fixed');
owner.bodyEl.setStyle('width', width + suffix);
if (inputEl) {
if (inputWidth) {
inputEl.setStyle('width', inputWidth + 'px');
} else {
inputEl.setStyle('width', owner.stretchInputElFixed ? '100%' : '');
}
}
ownerContext.isFixed = true;
},
beginLayoutShrinkWrap: function (ownerContext) {
var owner = ownerContext.target,
inputEl = owner.inputEl,
inputWidth = owner.inputWidth;
if (inputEl && inputEl.dom) {
inputEl.dom.removeAttribute('size');
if (inputWidth) {
inputEl.setStyle('width', inputWidth + 'px');
} else {
inputEl.setStyle('width', '');
}
}
owner.el.setStyle('table-layout', 'auto');
owner.bodyEl.setStyle('width', '');
},
finishedLayout: function(ownerContext){
var owner = this.owner;
this.callParent(arguments);        
ownerContext.labelStrategy.finishedLayout(ownerContext, owner);
ownerContext.errorStrategy.finishedLayout(ownerContext, owner);
},
calculateOwnerHeightFromContentHeight: function(ownerContext, contentHeight) {
return contentHeight;
},
measureContentHeight: function (ownerContext) {
return ownerContext.el.getHeight();
},
measureContentWidth: function (ownerContext) {
return ownerContext.el.getWidth();
},
measureLabelErrorHeight: function (ownerContext) {
return ownerContext.labelStrategy.getHeight(ownerContext) +
ownerContext.errorStrategy.getHeight(ownerContext);
},
onFocus: function() {
this.getErrorStrategy().onFocus(this.owner);    
},
getLabelStrategy: function() {
var me = this,
strategies = me.labelStrategies,
labelAlign = me.owner.labelAlign;
return strategies[labelAlign] || strategies.base;
},
getErrorStrategy: function() {
var me = this,
owner = me.owner,
strategies = me.errorStrategies,
msgTarget = owner.msgTarget;
return !owner.preventMark && Ext.isString(msgTarget) ?
(strategies[msgTarget] || strategies.elementId) :
strategies.none;
},
labelStrategies: (function() {
var base = {
prepare: function(ownerContext, owner) {
var cls = owner.labelCls + '-' + owner.labelAlign,
labelEl = owner.labelEl;
if (labelEl) {
labelEl.addCls(cls);
}
},
getHeight: function () {
return 0;
},
finishedLayout: Ext.emptyFn
};
return {
base: base,
top: Ext.applyIf({        
getHeight: function (ownerContext) {
var labelContext = ownerContext.labelContext,
props = labelContext.props,
height = props.height;
if (height === undefined) {
props.height = height = labelContext.el.getHeight() + labelContext.getMarginInfo().height;
}
return height;
}
}, base),
left: base,
right: base
};
}()),
errorStrategies: (function() {
function showTip(owner) {
var tip = Ext.layout.component.field.Field.tip,
target;
if (tip && tip.isVisible()) {
target = tip.activeTarget;
if (target && target.el === owner.getActionEl().dom) {
tip.toFront(true);
}
}
}
var applyIf = Ext.applyIf,
emptyFn = Ext.emptyFn,
iconCls = Ext.baseCSSPrefix + 'form-invalid-icon',
iconWidth,
base = {
prepare: function(ownerContext, owner) {
var el = owner.errorEl;
if (el) {
el.setDisplayed(false);
}
},
getHeight: function () {
return 0;
},
onFocus: emptyFn,
finishedLayout: emptyFn
};
return {
none: base,
side: applyIf({
prepare: function(ownerContext, owner) {
var errorEl = owner.errorEl,
sideErrorCell = owner.sideErrorCell,
displayError = owner.hasActiveError(),
tempEl;
if (!iconWidth) {
iconWidth = (tempEl = Ext.getBody().createChild({style: 'position:absolute', cls: iconCls})).getWidth();
tempEl.remove();
}
errorEl.addCls(iconCls);
errorEl.set({'data-errorqtip': owner.getActiveError() || ''});
if (owner.autoFitErrors) {
errorEl.setDisplayed(displayError);
}
else {
errorEl.setVisible(displayError);
}
if (sideErrorCell && owner.autoFitErrors) {
sideErrorCell.setDisplayed(displayError);
}
owner.bodyEl.dom.colSpan = owner.getBodyColspan();
Ext.layout.component.field.Field.initTip();
},
onFocus: showTip
}, base),
under: applyIf({
prepare: function(ownerContext, owner) {
var errorEl = owner.errorEl,
cls = Ext.baseCSSPrefix + 'form-invalid-under';
errorEl.addCls(cls);
errorEl.setDisplayed(owner.hasActiveError());
},
getHeight: function (ownerContext) {
var height = 0,
errorContext, props;
if (ownerContext.target.hasActiveError()) {
errorContext = ownerContext.errorContext;
props = errorContext.props;
height = props.height;
if (height === undefined) {
props.height = height = errorContext.el.getHeight();
}
}
return height;
}
}, base),
qtip: applyIf({
prepare: function(ownerContext, owner) {
Ext.layout.component.field.Field.initTip();
owner.getActionEl().dom.setAttribute('data-errorqtip', owner.getActiveError() || '');
},
onFocus: showTip
}, base),
title: applyIf({
prepare: function(ownerContext, owner) {
owner.getActionEl().dom.setAttribute('title', owner.getActiveError() || '');
}
}, base),
elementId: applyIf({
prepare: function(ownerContext, owner) {
var targetEl = Ext.fly(owner.msgTarget);
if (targetEl) {
targetEl.dom.innerHTML = owner.getActiveError() || '';
targetEl.setDisplayed(owner.hasActiveError());
}
}
}, base)
};
}()),
statics: {
initTip: function() {
var tip = this.tip;
if (!tip) {
tip = this.tip = Ext.create('Ext.tip.QuickTip', {
ui: 'form-invalid'
});
tip.tagConfig = Ext.apply({}, {attribute: 'errorqtip'}, tip.tagConfig);
}
},
destroyTip: function() {
var tip = this.tip;
if (tip) {
tip.destroy();
delete this.tip;
}
}
}
});
Ext.define('Ext.form.field.Base', {
extend:  Ext.Component ,
mixins: {
labelable:  Ext.form.Labelable ,
field:  Ext.form.field.Field 
},
alias: 'widget.field',
alternateClassName: ['Ext.form.Field', 'Ext.form.BaseField'],
fieldSubTpl: [ 
'<input id="{id}" type="{type}" role="{role}" {inputAttrTpl}',
' size="1"', 
'<tpl if="name"> name="{name}"</tpl>',
'<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>',
'<tpl if="placeholder"> placeholder="{placeholder}"</tpl>',
'{%if (values.maxLength !== undefined){%} maxlength="{maxLength}"{%}%}',
'<tpl if="readOnly"> readonly="readonly"</tpl>',
'<tpl if="disabled"> disabled="disabled"</tpl>',
'<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>',
'<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>',
' class="{fieldCls} {typeCls} {editableCls} {inputCls}" autocomplete="off"/>',
{
disableFormats: true
}
],
subTplInsertions: [
'inputAttrTpl'
],
inputType: 'text',
invalidText : 'The value in this field is invalid',
fieldCls : Ext.baseCSSPrefix + 'form-field',
focusCls : 'form-focus',
dirtyCls : Ext.baseCSSPrefix + 'form-dirty',
checkChangeEvents: Ext.isIE && (!document.documentMode || document.documentMode < 9) ?
['change', 'propertychange', 'keyup'] :
['change', 'input', 'textInput', 'keyup', 'dragdrop'],
checkChangeBuffer: 50,
componentLayout: 'field',
readOnly : false,
readOnlyCls: Ext.baseCSSPrefix + 'form-readonly',
validateOnBlur: true,
hasFocus : false,
baseCls: Ext.baseCSSPrefix + 'field',
maskOnDisable: false,
stretchInputElFixed: true,
initComponent : function() {
var me = this;
me.callParent();
me.subTplData = me.subTplData || {};
me.addEvents(
'specialkey',
'writeablechange'
);
me.initLabelable();
me.initField();
if (!me.name) {
me.name = me.getInputId();
}
if (me.readOnly) {
me.addCls(me.readOnlyCls);
}
me.addCls(Ext.baseCSSPrefix + 'form-type-' + me.inputType);
},
getInputId: function() {
return this.inputId || (this.inputId = this.id + '-inputEl');
},
getSubTplData: function() {
var me = this,
type = me.inputType,
inputId = me.getInputId(),
data;
data = Ext.apply({
id         : inputId,
cmpId      : me.id,
name       : me.name || inputId,
disabled   : me.disabled,
readOnly   : me.readOnly,
value      : me.getRawValue(),
type       : type,
fieldCls   : me.fieldCls,
fieldStyle : me.getFieldStyle(),
tabIdx     : me.tabIndex,
inputCls   : me.inputCls,
typeCls    : Ext.baseCSSPrefix + 'form-' + (type === 'password' ? 'text' : type),
role       : me.ariaRole
}, me.subTplData);
me.getInsertionRenderData(data, me.subTplInsertions);
return data;
},
applyRenderSelectors: function() {
var me = this;
me.callParent();
me.addChildEls('inputEl');
me.inputEl = me.el.getById(me.getInputId());
},
getSubTplMarkup: function() {
return this.getTpl('fieldSubTpl').apply(this.getSubTplData());
},
initRenderTpl: function() {
var me = this;
if (!me.hasOwnProperty('renderTpl')) {
me.renderTpl = me.getTpl('labelableRenderTpl');
}
return me.callParent();
},
initRenderData: function() {
return Ext.applyIf(this.callParent(), this.getLabelableRenderData());
},
setFieldStyle: function(style) {
var me = this,
inputEl = me.inputEl;
if (inputEl) {
inputEl.applyStyles(style);
}
me.fieldStyle = style;
},
getFieldStyle: function() {
var style = this.fieldStyle;
return Ext.isObject(style) ? Ext.DomHelper.generateStyles(style, null, true) : style || '';
},
onRender : function() {
this.callParent(arguments);
this.renderActiveError();
},
getFocusEl: function() {
return this.inputEl;
},
isFileUpload: function() {
return this.inputType === 'file';
},
getSubmitData: function() {
var me = this,
data = null,
val;
if (!me.disabled && me.submitValue) {
val = me.getSubmitValue();
if (val !== null) {
data = {};
data[me.getName()] = val;
}
}
return data;
},
getSubmitValue: function() {
return this.processRawValue(this.getRawValue());
},
getRawValue: function() {
var me = this,
v = (me.inputEl ? me.inputEl.getValue() : Ext.value(me.rawValue, ''));
me.rawValue = v;
return v;
},
setRawValue: function(value) {
var me = this;
value = Ext.value(me.transformRawValue(value), '');
me.rawValue = value;
if (me.inputEl) {
me.inputEl.dom.value = value;
}
return value;
},
transformRawValue: Ext.identityFn,
valueToRaw: function(value) {
return '' + Ext.value(value, '');
},
rawToValue: Ext.identityFn,
processRawValue: Ext.identityFn,
getValue: function() {
var me = this,
val = me.rawToValue(me.processRawValue(me.getRawValue()));
me.value = val;
return val;
},
setValue: function(value) {
var me = this;
me.setRawValue(me.valueToRaw(value));
return me.mixins.field.setValue.call(me, value);
},
onBoxReady: function() {
var me = this;
me.callParent();
if (me.setReadOnlyOnBoxReady) {
me.setReadOnly(me.readOnly);
}
},
onDisable: function() {
var me = this,
inputEl = me.inputEl;
me.callParent();
if (inputEl) {
inputEl.dom.disabled = true;
if (me.hasActiveError()) {
me.clearInvalid();
me.needsValidateOnEnable = true;
}
}
},
onEnable: function() {
var me = this,
inputEl = me.inputEl;
me.callParent();
if (inputEl) {
inputEl.dom.disabled = false;
if (me.needsValidateOnEnable) {
delete me.needsValidateOnEnable;
me.forceValidation = true;
me.isValid();
delete me.forceValidation;
}
}
},
setReadOnly: function(readOnly) {
var me = this,
inputEl = me.inputEl;
readOnly = !!readOnly;
me[readOnly ? 'addCls' : 'removeCls'](me.readOnlyCls);
me.readOnly = readOnly;
if (inputEl) {
inputEl.dom.readOnly = readOnly;
} else if (me.rendering) {
me.setReadOnlyOnBoxReady = true;
}
me.fireEvent('writeablechange', me, readOnly);
},
fireKey: function(e){
if(e.isSpecialKey()){
this.fireEvent('specialkey', this, new Ext.EventObjectImpl(e));
}
},
initEvents : function(){
var me = this,
inputEl = me.inputEl,
onChangeTask,
onChangeEvent,
events = me.checkChangeEvents,
e,
eLen   = events.length,
event;
if (inputEl) {
me.mon(inputEl, Ext.EventManager.getKeyEvent(), me.fireKey,  me);
onChangeTask = new Ext.util.DelayedTask(me.checkChange, me);
me.onChangeEvent = onChangeEvent = function() {
onChangeTask.delay(me.checkChangeBuffer);
};
for (e = 0; e < eLen; e++) {
event = events[e];
if (event === 'propertychange') {
me.usesPropertychange = true;
}
me.mon(inputEl, event, onChangeEvent);
}
}
me.callParent();
},
doComponentLayout: function() {
var me = this,
inputEl = me.inputEl,
usesPropertychange = me.usesPropertychange,
ename = 'propertychange',
onChangeEvent = me.onChangeEvent;
if (usesPropertychange) {
me.mun(inputEl, ename, onChangeEvent);
}
me.callParent(arguments);
if (usesPropertychange) {
me.mon(inputEl, ename, onChangeEvent);
}
},
onDirtyChange: function(isDirty) {
this[isDirty ? 'addCls' : 'removeCls'](this.dirtyCls);
},
isValid : function() {
var me = this,
disabled = me.disabled,
validate = me.forceValidation || !disabled;
return validate ? me.validateValue(me.processRawValue(me.getRawValue())) : disabled;
},
validateValue: function(value) {
var me = this,
errors = me.getErrors(value),
isValid = Ext.isEmpty(errors);
if (!me.preventMark) {
if (isValid) {
me.clearInvalid();
} else {
me.markInvalid(errors);
}
}
return isValid;
},
markInvalid : function(errors) {
var me = this,
oldMsg = me.getActiveError(),
active;
me.setActiveErrors(Ext.Array.from(errors));
active = me.getActiveError();
if (oldMsg !== active) {
me.setError(active);
}
},
clearInvalid : function() {
var me = this,
hadError = me.hasActiveError();
delete me.needsValidateOnEnable;
me.unsetActiveError();
if (hadError) {
me.setError('');
}
},
setError: function(active){
var me = this,
msgTarget = me.msgTarget,
prop;
if (me.rendered) {
if (msgTarget == 'title' || msgTarget == 'qtip') {
if (me.rendered) {
prop = msgTarget == 'qtip' ? 'data-errorqtip' : 'title';
}
me.getActionEl().dom.setAttribute(prop, active || '');
} else {
me.updateLayout();
}
}
},
renderActiveError: function() {
var me = this,
hasError = me.hasActiveError();
if (me.inputEl) {
me.inputEl[hasError ? 'addCls' : 'removeCls'](me.invalidCls + '-field');
}
me.mixins.labelable.renderActiveError.call(me);
},
getActionEl: function() {
return this.inputEl || this.el;
}
});
Ext.define('Ext.form.field.VTypes', (function(){
var alpha = /^[a-zA-Z_]+$/,
alphanum = /^[a-zA-Z0-9_]+$/,
email = /^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+/=?^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/,
url = /(((^https?)|(^ftp)):\/\/((([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*)|(localhost|LOCALHOST))\/?)/i;
return {
singleton: true,
alternateClassName: 'Ext.form.VTypes',
'email' : function(v){
return email.test(v);
},
'emailText' : 'This field should be an e-mail address in the format "user@example.com"',
'emailMask' : /[\w.\-@'"!#$%&'*+/=?^_`{|}~]/i,
'url' : function(v){
return url.test(v);
},
'urlText' : 'This field should be a URL in the format "http:/'+'/www.example.com"',
'alpha' : function(v){
return alpha.test(v);
},
'alphaText' : 'This field should only contain letters and _',
'alphaMask' : /[a-z_]/i,
'alphanum' : function(v){
return alphanum.test(v);
},
'alphanumText' : 'This field should only contain letters, numbers and _',
'alphanumMask' : /[a-z0-9_]/i
};
}()));
Ext.define('Ext.layout.component.field.Text', {
extend:  Ext.layout.component.field.Field ,
alias: 'layout.textfield',
type: 'textfield',
setWidthInDom: true,
canGrowWidth: true,
beginLayoutCycle: function(ownerContext) {
this.callParent(arguments);
if (ownerContext.heightModel.shrinkWrap) {
ownerContext.inputContext.el.setStyle('height', '');
}
},
measureContentWidth: function (ownerContext) {
var me = this,
owner = me.owner,
width = me.callParent(arguments),
inputContext = ownerContext.inputContext,
inputEl, value, calcWidth, max, min;
if (owner.grow && me.canGrowWidth && !ownerContext.state.growHandled) {
inputEl = owner.inputEl;
value = Ext.util.Format.htmlEncode(inputEl.dom.value || (owner.hasFocus ? '' : owner.emptyText) || '');
value += owner.growAppend;
calcWidth = inputEl.getTextWidth(value) + inputContext.getFrameInfo().width;
max = owner.growMax;
min = Math.min(max, width);
max = Math.max(owner.growMin, max, min);
calcWidth = Ext.Number.constrain(calcWidth, owner.growMin, max);
inputContext.setWidth(calcWidth);
ownerContext.state.growHandled = true;
inputContext.domBlock(me, 'width');
width = NaN;
}
return width;
},
publishInnerHeight: function(ownerContext, height) {
ownerContext.inputContext.setHeight(height - this.measureLabelErrorHeight(ownerContext));
},
beginLayoutFixed: function(ownerContext, width, suffix) {
var me = this,
ieInputWidthAdjustment = me.ieInputWidthAdjustment;
if (ieInputWidthAdjustment) {
me.adjustIEInputPadding(ownerContext);
if(suffix === 'px') {
width -= ieInputWidthAdjustment;
}
}
me.callParent(arguments);
},
adjustIEInputPadding: function(ownerContext) {
this.owner.bodyEl.setStyle('padding-right', this.ieInputWidthAdjustment + 'px');
}
});
Ext.define('Ext.form.field.Text', {
extend: Ext.form.field.Base ,
alias: 'widget.textfield',
alternateClassName: ['Ext.form.TextField', 'Ext.form.Text'],
size: 20,
growMin : 30,
growMax : 800,
growAppend: 'W',
allowBlank : true,
validateBlank: false,
allowOnlyWhitespace: true,
minLength : 0,
maxLength : Number.MAX_VALUE,
minLengthText : 'The minimum length for this field is {0}',
maxLengthText : 'The maximum length for this field is {0}',
blankText : 'This field is required',
regexText : '',
emptyCls : Ext.baseCSSPrefix + 'form-empty-field',
requiredCls : Ext.baseCSSPrefix + 'form-required-field',
componentLayout: 'textfield',
valueContainsPlaceholder : false,
ariaRole: 'textbox',
initComponent: function () {
var me = this;
if (me.allowOnlyWhitespace === false) {
me.allowBlank = false;
}
me.callParent();
me.addEvents(
'autosize',
'keydown',
'keyup',
'keypress'
);
me.addStateEvents('change');
me.setGrowSizePolicy();
},
setGrowSizePolicy: function(){
if (this.grow) {
this.shrinkWrap |= 1; 
}    
},
initEvents : function(){
var me = this,
el = me.inputEl;
me.callParent();
if(me.selectOnFocus || me.emptyText){
me.mon(el, 'mousedown', me.onMouseDown, me);
}
if(me.maskRe || (me.vtype && me.disableKeyFilter !== true && (me.maskRe = Ext.form.field.VTypes[me.vtype+'Mask']))){
me.mon(el, 'keypress', me.filterKeys, me);
}
if (me.enableKeyEvents) {
me.mon(el, {
scope: me,
keyup: me.onKeyUp,
keydown: me.onKeyDown,
keypress: me.onKeyPress
});
}
},
isEqual: function(value1, value2) {
return this.isEqualAsString(value1, value2);
},
onChange: function(newVal, oldVal) {
this.callParent(arguments);
this.autoSize();
},
getSubTplData: function() {
var me = this,
value = me.getRawValue(),
isEmpty = me.emptyText && value.length < 1,
maxLength = me.maxLength,
placeholder;
if (me.enforceMaxLength) {
if (maxLength === Number.MAX_VALUE) {
maxLength = undefined;
}
} else {
maxLength = undefined;
}
if (isEmpty) {
if (Ext.supports.Placeholder) {
placeholder = me.emptyText;
} else {
value = me.emptyText;
me.valueContainsPlaceholder = true;
}
}
return Ext.apply(me.callParent(), {
maxLength   : maxLength,
readOnly    : me.readOnly,
placeholder : placeholder,
value       : value,
fieldCls    : me.fieldCls + ((isEmpty && (placeholder || value)) ? ' ' + me.emptyCls : '') + (me.allowBlank ? '' :  ' ' + me.requiredCls)
});
},
afterRender: function(){
this.autoSize();
this.callParent();
},
onMouseDown: function(e){
var me = this;
if(!me.hasFocus){
me.mon(me.inputEl, 'mouseup', Ext.emptyFn, me, { single: true, preventDefault: true });
}
},
processRawValue: function(value) {
var me = this,
stripRe = me.stripCharsRe,
newValue;
if (stripRe) {
newValue = value.replace(stripRe, '');
if (newValue !== value) {
me.setRawValue(newValue);
value = newValue;
}
}
return value;
},
onDisable: function(){
this.callParent();
if (Ext.isIE) {
this.inputEl.dom.unselectable = 'on';
}
},
onEnable: function(){
this.callParent();
if (Ext.isIE) {
this.inputEl.dom.unselectable = '';
}
},
onKeyDown: function(e) {
this.fireEvent('keydown', this, e);
},
onKeyUp: function(e) {
this.fireEvent('keyup', this, e);
},
onKeyPress: function(e) {
this.fireEvent('keypress', this, e);
},
reset : function(){
this.callParent();
this.applyEmptyText();
},
applyEmptyText : function(){
var me = this,
emptyText = me.emptyText,
isEmpty;
if (me.rendered && emptyText) {
isEmpty = me.getRawValue().length < 1 && !me.hasFocus;
if (Ext.supports.Placeholder) {
me.inputEl.dom.placeholder = emptyText;
} else if (isEmpty) {
me.setRawValue(emptyText);
me.valueContainsPlaceholder = true;
}
if (isEmpty) {
me.inputEl.addCls(me.emptyCls);
}
me.autoSize();
}
},
afterFirstLayout: function() {
this.callParent();
if (Ext.isIE && this.disabled) {
var el = this.inputEl;
if (el) {
el.dom.unselectable = 'on';
}
}
},
beforeFocus : function(){
var me = this,
inputEl = me.inputEl,
emptyText = me.emptyText,
isEmpty;
me.callParent(arguments);
if ((emptyText && !Ext.supports.Placeholder) && (inputEl.dom.value === me.emptyText && me.valueContainsPlaceholder)) {
me.setRawValue('');
isEmpty = true;
inputEl.removeCls(me.emptyCls);
me.valueContainsPlaceholder = false;
} else if (Ext.supports.Placeholder) {
inputEl.removeCls(me.emptyCls);
}
if (me.selectOnFocus || isEmpty) {
if (Ext.isWebKit) {
if (!me.inputFocusTask) {
me.inputFocusTask = new Ext.util.DelayedTask(me.focusInput, me);
}
me.inputFocusTask.delay(1);
} else {
me.focusInput();
}
}
},
focusInput: function(){
var input = this.inputEl;
if (input) {
input = input.dom;
if (input) {
input.select();
}
}    
},
onFocus: function() {
var me = this;
me.callParent(arguments);
if (me.emptyText) {
me.autoSize();
}
},
postBlur : function(){
var task = this.inputFocusTask;
this.callParent(arguments);
this.applyEmptyText();
if (task) {
task.cancel();
}
},
filterKeys : function(e){
if (e.ctrlKey && !e.altKey) {
return;
}
var key = e.getKey(),
charCode = String.fromCharCode(e.getCharCode());
if((Ext.isGecko || Ext.isOpera) && (e.isNavKeyPress() || key === e.BACKSPACE || (key === e.DELETE && e.button === -1))){
return;
}
if((!Ext.isGecko && !Ext.isOpera) && e.isSpecialKey() && !charCode){
return;
}
if(!this.maskRe.test(charCode)){
e.stopEvent();
}
},
getState: function() {
return this.addPropertyToState(this.callParent(), 'value');
},
applyState: function(state) {
this.callParent(arguments);
if(state.hasOwnProperty('value')) {
this.setValue(state.value);
}
},
getRawValue: function() {
var me = this,
v = me.callParent();
if (v === me.emptyText && me.valueContainsPlaceholder) {
v = '';
}
return v;
},
setValue: function(value) {
var me = this,
inputEl = me.inputEl;
if (inputEl && me.emptyText && !Ext.isEmpty(value)) {
inputEl.removeCls(me.emptyCls);
me.valueContainsPlaceholder = false;
}
me.callParent(arguments);
me.applyEmptyText();
return me;
},
getErrors: function(value) {
var me = this,
errors = me.callParent(arguments),
validator = me.validator,
vtype = me.vtype,
vtypes = Ext.form.field.VTypes,
regex = me.regex,
format = Ext.String.format,
msg, trimmed, isBlank;
value = value || me.processRawValue(me.getRawValue());
if (Ext.isFunction(validator)) {
msg = validator.call(me, value);
if (msg !== true) {
errors.push(msg);
}
}
trimmed = me.allowOnlyWhitespace ? value : Ext.String.trim(value);
if (trimmed.length < 1 || (value === me.emptyText && me.valueContainsPlaceholder)) {
if (!me.allowBlank) {
errors.push(me.blankText);
}
if (!me.validateBlank) {
return errors;
}
isBlank = true;
}
if (!isBlank && value.length < me.minLength) {
errors.push(format(me.minLengthText, me.minLength));
}
if (value.length > me.maxLength) {
errors.push(format(me.maxLengthText, me.maxLength));
}
if (vtype) {
if (!vtypes[vtype](value, me)) {
errors.push(me.vtypeText || vtypes[vtype +'Text']);
}
}
if (regex && !regex.test(value)) {
errors.push(me.regexText || me.invalidText);
}
return errors;
},
selectText : function(start, end){
var me = this,
v = me.getRawValue(),
doFocus = true,
el = me.inputEl.dom,
undef,
range;
if (v.length > 0) {
start = start === undef ? 0 : start;
end = end === undef ? v.length : end;
if (el.setSelectionRange) {
el.setSelectionRange(start, end);
}
else if(el.createTextRange) {
range = el.createTextRange();
range.moveStart('character', start);
range.moveEnd('character', end - v.length);
range.select();
}
doFocus = Ext.isGecko || Ext.isOpera;
}
if (doFocus) {
me.focus();
}
},
autoSize: function() {
var me = this;
if (me.grow && me.rendered) {
me.autoSizing = true;
me.updateLayout();
}
},
afterComponentLayout: function() {
var me = this,
width;
me.callParent(arguments);
if (me.autoSizing) {
width = me.inputEl.getWidth();
if (width !== me.lastInputWidth) {
me.fireEvent('autosize', me, width);
me.lastInputWidth = width;
delete me.autoSizing;
}
}
},
onDestroy: function(){
var me = this;
me.callParent();
if (me.inputFocusTask) {
me.inputFocusTask.cancel();
me.inputFocusTask = null;
}
}
});
Ext.define('Ext.form.field.Display', {
extend: Ext.form.field.Base ,
alias: 'widget.displayfield',
alternateClassName: ['Ext.form.DisplayField', 'Ext.form.Display'],
ariaRole: 'textbox',
fieldSubTpl: [
'<div id="{id}" role="{role}" {inputAttrTpl}',
'<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', 
' class="{fieldCls}">{value}</div>',
{
compiled: true,
disableFormats: true
}
],
readOnly: true,
fieldCls: Ext.baseCSSPrefix + 'form-display-field',
fieldBodyCls: Ext.baseCSSPrefix + 'form-display-field-body',
htmlEncode: false,
noWrap: false,
validateOnChange: false,
initEvents: Ext.emptyFn,
submitValue: false,
valueToRaw: function(value) {
if (!value && value !== 0) {
return '';
} else {
return value;
}
},
isDirty: function(){
return false;
},
isValid: function() {
return true;
},
validate: function() {
return true;
},
getRawValue: function() {
return this.rawValue;
},
setRawValue: function(value) {
var me = this;
value = Ext.value(value, '');
me.rawValue = value;
if (me.rendered) {
me.inputEl.dom.innerHTML = me.getDisplayValue();
me.updateLayout();
}
return value;
},
getDisplayValue: function() {
var me = this,
value = this.getRawValue(),
display;
if (me.renderer) {
display = me.renderer.call(me.scope || me, value, me);
} else {
display = me.htmlEncode ? Ext.util.Format.htmlEncode(value) : value;
}
return display;
},
getSubTplData: function() {
var ret = this.callParent(arguments);
ret.value = this.getDisplayValue();
return ret;
}
});
Ext.define('Ext.form.FieldAncestor', {
xhooks: {
initHierarchyState: function(hierarchyState) {
if (this.fieldDefaults) {
if (hierarchyState.fieldDefaults) {
hierarchyState.fieldDefaults = Ext.apply(Ext.Object.chain(hierarchyState.fieldDefaults), this.fieldDefaults);
} else {
hierarchyState.fieldDefaults = this.fieldDefaults;
}
}
}
},
initFieldAncestor: function() {
var me = this;
me.addEvents(
'fieldvaliditychange',
'fielderrorchange'
);
me.monitor = new Ext.container.Monitor({
scope: me,
selector: '[isFormField]:not([excludeForm])',
addHandler: me.onChildFieldAdd,
removeHandler: me.onChildFieldRemove
});
me.initFieldDefaults();
},
initMonitor: function() {
this.monitor.bind(this);    
},
onChildFieldAdd: function(field) {
var me = this;
me.mon(field, 'errorchange', me.handleFieldErrorChange, me);
me.mon(field, 'validitychange', me.handleFieldValidityChange, me);
},
onChildFieldRemove: function(field) {
var me = this;
me.mun(field, 'errorchange', me.handleFieldErrorChange, me);
me.mun(field, 'validitychange', me.handleFieldValidityChange, me);
},
initFieldDefaults: function() {
if (!this.fieldDefaults) {
this.fieldDefaults = {};
}
},
handleFieldValidityChange: function(field, isValid) {
var me = this;
if (field !== me) {
me.fireEvent('fieldvaliditychange', me, field, isValid);
me.onFieldValidityChange(field, isValid);
}
},
handleFieldErrorChange: function(labelable, activeError) {
var me = this;
if (labelable !== me) {
me.fireEvent('fielderrorchange', me, labelable, activeError);
me.onFieldErrorChange(labelable, activeError);
}
},
onFieldValidityChange: Ext.emptyFn,
onFieldErrorChange: Ext.emptyFn,
beforeDestroy: function(){
this.monitor.unbind();
this.callParent();
}
});
Ext.define('Ext.layout.component.field.FieldContainer', {
extend:  Ext.layout.component.field.Field ,
alias: 'layout.fieldcontainer',
type: 'fieldcontainer',
waitForOuterHeightInDom: true,
waitForOuterWidthInDom: true,
beginLayout: function(ownerContext) {
var owner = this.owner;
this.callParent(arguments);
ownerContext.hasRawContent = true;
owner.bodyEl.setStyle('height', '');
owner.containerEl.setStyle('height', '');
ownerContext.containerElContext = ownerContext.getEl('containerEl');
},
measureContentHeight: function (ownerContext) {
return ownerContext.hasDomProp('containerLayoutDone') ? this.callParent(arguments) : NaN;
},
measureContentWidth: function (ownerContext) {
return ownerContext.hasDomProp('containerLayoutDone') ? this.callParent(arguments) : NaN;
},
publishInnerWidth: function (ownerContext, width) {
var bodyContext = ownerContext.bodyCellContext,
innerWidth = bodyContext.el.getWidth();
bodyContext.setWidth(innerWidth, false);
ownerContext.containerElContext.setWidth(innerWidth, false);
},
publishInnerHeight: function (ownerContext, height) {
var bodyContext = ownerContext.bodyCellContext,
containerElContext = ownerContext.containerElContext;
height -= this.measureLabelErrorHeight(ownerContext);
bodyContext.setHeight(height);
containerElContext.setHeight(height);
}
});
Ext.define('Ext.layout.component.field.Trigger', {
alias: 'layout.triggerfield',
extend:  Ext.layout.component.field.Field ,
type: 'triggerfield',
setWidthInDom: true,
borderWidths: {},
beginLayout: function(ownerContext) {
var me = this,
owner = me.owner,
flags;
ownerContext.triggerWrap = ownerContext.getEl('triggerWrap');
me.callParent(arguments);
flags = owner.getTriggerStateFlags();
if (flags != owner.lastTriggerStateFlags) {
owner.lastTriggerStateFlags = flags;
me.updateEditState();
}
},
beginLayoutCycle: function(ownerContext){
this.callParent(arguments);
if (ownerContext.widthModel.shrinkWrap && !this.owner.inputWidth) {
ownerContext.inputContext.el.setStyle('width', '');
}    
},
beginLayoutFixed: function (ownerContext, width, suffix) {
var me = this,
owner = ownerContext.target,
ieInputWidthAdjustment = me.ieInputWidthAdjustment || 0,
inputWidth = '100%',
triggerWrap = owner.triggerWrap;
me.callParent(arguments);
owner.inputCell.setStyle('width', '100%');
if(ieInputWidthAdjustment) {
me.adjustIEInputPadding(ownerContext);
if(suffix === 'px') {
if (owner.inputWidth) {
inputWidth = owner.inputWidth - me.getExtraWidth(ownerContext);
} else {
inputWidth = width - ieInputWidthAdjustment - me.getExtraWidth(ownerContext);
}
inputWidth += 'px';
}
}
owner.inputEl.setStyle('width', inputWidth);
inputWidth = owner.inputWidth;
if (inputWidth) {
triggerWrap.setStyle('width', inputWidth + (ieInputWidthAdjustment) + 'px');
} else {
triggerWrap.setStyle('width', width + suffix);
}
triggerWrap.setStyle('table-layout', 'fixed');
},
adjustIEInputPadding: function(ownerContext) {
this.owner.inputCell.setStyle('padding-right', this.ieInputWidthAdjustment + 'px');
},
getExtraWidth: function(ownerContext) {
var me = this,
owner = me.owner,
borderWidths = me.borderWidths,
ui = owner.ui + owner.triggerEl.getCount();
if (!(ui in borderWidths)) {
borderWidths[ui] = ownerContext.triggerWrap.getBorderInfo().width
}
return borderWidths[ui] + owner.getTriggerWidth();
},
beginLayoutShrinkWrap: function (ownerContext) {
var owner = ownerContext.target,
emptyString = '',
inputWidth = owner.inputWidth,
triggerWrap = owner.triggerWrap;
this.callParent(arguments);
if (inputWidth) {
triggerWrap.setStyle('width', inputWidth + 'px');
inputWidth = (inputWidth - this.getExtraWidth(ownerContext)) + 'px';
owner.inputEl.setStyle('width', inputWidth);
owner.inputCell.setStyle('width', inputWidth);
} else {
owner.inputCell.setStyle('width', emptyString);
owner.inputEl.setStyle('width', emptyString);
triggerWrap.setStyle('width', emptyString);
triggerWrap.setStyle('table-layout', 'auto');
}
},
getTextWidth: function () {
var me = this,
owner = me.owner,
inputEl = owner.inputEl,
value;
value = (inputEl.dom.value || (owner.hasFocus ? '' : owner.emptyText) || '') + owner.growAppend;
return inputEl.getTextWidth(value);
},
publishOwnerWidth: function(ownerContext, width) {
var owner = this.owner;
this.callParent(arguments);
if (!owner.grow && !owner.inputWidth) {
width -= this.getExtraWidth(ownerContext);
if (owner.labelAlign != 'top') {
width -= owner.getLabelWidth();
}
ownerContext.inputContext.setWidth(width);
}    
},
publishInnerHeight: function(ownerContext, height) {
ownerContext.inputContext.setHeight(height - this.measureLabelErrorHeight(ownerContext));
},
measureContentWidth: function (ownerContext) {
var me = this,
owner = me.owner,
width = me.callParent(arguments),
inputContext = ownerContext.inputContext,
calcWidth, max, min;
if (owner.grow && !ownerContext.state.growHandled) {
calcWidth = me.getTextWidth() + ownerContext.inputContext.getFrameInfo().width;
max = owner.growMax;
min = Math.min(max, width);
max = Math.max(owner.growMin, max, min);
calcWidth = Ext.Number.constrain(calcWidth, owner.growMin, max);
inputContext.setWidth(calcWidth);
ownerContext.state.growHandled = true;
inputContext.domBlock(me, 'width');
width = NaN;
} else if (!owner.inputWidth) {
width -= me.getExtraWidth(ownerContext);
}
return width;
},
updateEditState: function() {
var me = this,
owner = me.owner,
inputEl = owner.inputEl,
noeditCls = Ext.baseCSSPrefix + 'trigger-noedit',
displayed,
readOnly;
if (me.owner.readOnly) {
inputEl.addCls(noeditCls);
readOnly = true;
displayed = false;
} else {
if (me.owner.editable) {
inputEl.removeCls(noeditCls);
readOnly = false;
} else {
inputEl.addCls(noeditCls);
readOnly = true;
}
displayed = !me.owner.hideTrigger;
}
owner.triggerCell.setDisplayed(displayed);
inputEl.dom.readOnly = readOnly;
}
});
Ext.define('Ext.form.field.Trigger', {
extend: Ext.form.field.Text ,
alias: ['widget.triggerfield', 'widget.trigger'],
alternateClassName: ['Ext.form.TriggerField', 'Ext.form.TwinTriggerField', 'Ext.form.Trigger'],
childEls: [
{ name: 'triggerCell', select: '.' + Ext.baseCSSPrefix + 'trigger-cell' },
{ name: 'triggerEl', select: '.' + Ext.baseCSSPrefix + 'form-trigger' },
'triggerWrap',
'inputCell'
],
triggerBaseCls: Ext.baseCSSPrefix + 'form-trigger',
triggerWrapCls: Ext.baseCSSPrefix + 'form-trigger-wrap',
triggerNoEditCls: Ext.baseCSSPrefix + 'trigger-noedit',
hideTrigger: false,
editable: true,
readOnly: false,
repeatTriggerClick: false,
autoSize: Ext.emptyFn,
monitorTab: true,
mimicing: false,
triggerIndexRe: /trigger-index-(\d+)/,
extraTriggerCls: '',
componentLayout: 'triggerfield',
initComponent: function() {
this.wrapFocusCls = this.triggerWrapCls + '-focus';
this.callParent(arguments);
},
getSubTplMarkup: function(values) {
var me = this,
childElCls = values.childElCls, 
field = me.callParent(arguments);
return [
'<table id="', me.id, '-triggerWrap" class="', Ext.baseCSSPrefix,
'form-trigger-wrap', childElCls,
'" cellpadding="0" cellspacing="0" role="presentation">',
'<tbody role="presentation">',
'<tr role="presentation">',
'<td id="', me.id, '-inputCell" class="', Ext.baseCSSPrefix,
'form-trigger-input-cell', childElCls, '" role="presentation">',
field,
'</td>',
me.getTriggerMarkup(),
'</tr>',
'</tbody>',
'</table>'
].join('');
},
getSubTplData: function(){
var me = this,
data = me.callParent(),
readOnly = me.readOnly === true,
editable = me.editable !== false;
return Ext.apply(data, {
editableCls: (readOnly || !editable) ? ' ' + me.triggerNoEditCls : '',
readOnly: !editable || readOnly
});  
},
getLabelableRenderData: function() {
var me = this,
triggerWrapCls = me.triggerWrapCls,
result = me.callParent(arguments);
return Ext.applyIf(result, {
triggerWrapCls: triggerWrapCls,
triggerMarkup: me.getTriggerMarkup()
});
},
getTriggerMarkup: function() {
var me = this,
i = 0,
hideTrigger = (me.readOnly || me.hideTrigger),
triggerCls,
triggerBaseCls = me.triggerBaseCls,
triggerConfigs = [],
unselectableCls = Ext.dom.Element.unselectableCls,
style = 'width:' + me.triggerWidth + 'px;' + (hideTrigger ? 'display:none;' : ''),
cls = me.extraTriggerCls + ' ' + Ext.baseCSSPrefix + 'trigger-cell ' + unselectableCls;
if (!me.trigger1Cls) {
me.trigger1Cls = me.triggerCls;
}
for (i = 0; (triggerCls = me['trigger' + (i + 1) + 'Cls']) || i < 1; i++) {
triggerConfigs.push({
tag: 'td',
role: 'presentation',
valign: 'top',
cls: cls,
style: style,
cn: {
cls: [Ext.baseCSSPrefix + 'trigger-index-' + i, triggerBaseCls, triggerCls].join(' '),
role: 'presentation'
}
});
}
triggerConfigs[0].cn.cls += ' ' + triggerBaseCls + '-first';
return Ext.DomHelper.markup(triggerConfigs);
},
disableCheck: function() {
return !this.disabled;    
},
beforeRender: function() {
var me = this,
triggerBaseCls = me.triggerBaseCls,
tempEl;
if (!me.triggerWidth) {
tempEl = Ext.getBody().createChild({
role: 'presentation',
style: 'position: absolute;', 
cls: Ext.baseCSSPrefix + 'form-trigger'
});
Ext.form.field.Trigger.prototype.triggerWidth = tempEl.getWidth();
tempEl.remove();
}
me.callParent();
if (triggerBaseCls != Ext.baseCSSPrefix + 'form-trigger') {
me.addChildEls({ name: 'triggerEl', select: '.' + triggerBaseCls });
}
me.lastTriggerStateFlags = me.getTriggerStateFlags();
},
onRender: function() {
var me = this;
me.callParent(arguments);
me.doc = Ext.getDoc();
me.initTrigger();
},
getTriggerWidth: function() {
var me = this,
totalTriggerWidth = 0;
if (me.triggerWrap && !me.hideTrigger && !me.readOnly) {
totalTriggerWidth = me.triggerEl.getCount() * me.triggerWidth;
}
return totalTriggerWidth;
},
setHideTrigger: function(hideTrigger) {
if (hideTrigger != this.hideTrigger) {
this.hideTrigger = hideTrigger;
this.updateLayout();
}
},
setEditable: function(editable) {
if (editable != this.editable) {
this.editable = editable;
this.updateLayout();
}
},
setReadOnly: function(readOnly) {
var me = this,
old = me.readOnly;
me.callParent(arguments);
if (readOnly != old) {
me.updateLayout();
}
},
initTrigger: function() {
var me = this,
triggerWrap = me.triggerWrap,
triggerEl = me.triggerEl,
disableCheck = me.disableCheck,
els, len, el, i, idx, cls;
if (me.repeatTriggerClick) {
me.triggerRepeater = new Ext.util.ClickRepeater(triggerWrap, {
preventDefault: true,
handler: me.onTriggerWrapClick,
listeners: {
mouseup: me.onTriggerWrapMouseup,
scope: me
},
scope: me
});
} else {
me.mon(triggerWrap, {
click: me.onTriggerWrapClick,
mouseup: me.onTriggerWrapMouseup,
scope: me
});
}
triggerEl.setVisibilityMode(Ext.Element.DISPLAY);
triggerEl.addClsOnOver(me.triggerBaseCls + '-over', disableCheck, me);
els  = triggerEl.elements;
len = els.length;
for (i = 0; i < len; i++) {
el = els[i];
idx = i + 1;
cls = me['trigger' + (idx) + 'Cls'];
if (cls) {
el.addClsOnOver(cls + '-over', disableCheck, me);
el.addClsOnClick(cls + '-click', disableCheck, me);
}
}
triggerEl.addClsOnClick(me.triggerBaseCls + '-click', disableCheck, me);
},
onDestroy: function() {
var me = this;
Ext.destroyMembers(me, 'triggerRepeater', 'triggerWrap', 'triggerEl');
delete me.doc;
me.callParent();
},
onFocus: function() {
var me = this;
me.callParent(arguments);
if (!me.mimicing) {
me.bodyEl.addCls(me.wrapFocusCls);
me.mimicing = true;
me.mon(me.doc, 'mousedown', me.mimicBlur, me, {
delay: 10
});
if (me.monitorTab) {
me.on('specialkey', me.checkTab, me);
}
}
},
checkTab: function(me, e) {
if (!this.ignoreMonitorTab && e.getKey() == e.TAB) {
this.triggerBlur();
}
},
getTriggerStateFlags: function () {
var me = this,
state = 0;
if (me.readOnly) {
state += 1;
}
if (me.editable) {
state += 2;
}
if (me.hideTrigger) {
state += 4;
}
return state;
},
onBlur: function() {
var me = this,
blurTask = me.blurTask;
if (me.blurring) {
me.triggerBlur();
}
},
mimicBlur: function(e) {
if (!this.isDestroyed && !this.bodyEl.contains(e.target) && this.validateBlur(e)) {
this.triggerBlur(e);
}
},
triggerBlur: function(e) {
var me = this;
me.mimicing = false;
me.mun(me.doc, 'mousedown', me.mimicBlur, me);
if (me.monitorTab && me.inputEl) {
me.un('specialkey', me.checkTab, me);
}
Ext.form.field.Trigger.superclass.onBlur.call(me, e);
if (me.bodyEl) {
me.bodyEl.removeCls(me.wrapFocusCls);
}
},
validateBlur: function(e) {
return true;
},
onTriggerWrapClick: function() {
var me = this,
targetEl, match,
triggerClickMethod,
event;
event = arguments[me.triggerRepeater ? 1 : 0];
if (event && !me.readOnly && !me.disabled) {
targetEl = event.getTarget('.' + me.triggerBaseCls, null);
match = targetEl && targetEl.className.match(me.triggerIndexRe);
if (match) {
triggerClickMethod = me['onTrigger' + (parseInt(match[1], 10) + 1) + 'Click'] || me.onTriggerClick;
if (triggerClickMethod) {
triggerClickMethod.call(me, event);
}
}
}
},
onTriggerWrapMouseup: Ext.emptyFn,
onTriggerClick: Ext.emptyFn
});
Ext.define('Ext.form.field.Picker', {
extend:  Ext.form.field.Trigger ,
alias: 'widget.pickerfield',
alternateClassName: 'Ext.form.Picker',
matchFieldWidth: true,
pickerAlign: 'tl-bl?',
openCls: Ext.baseCSSPrefix + 'pickerfield-open',
editable: true,
initComponent: function() {
this.callParent();
this.addEvents(
'expand',
'collapse',
'select'
);
},
initEvents: function() {
var me = this;
me.callParent();
me.keyNav = new Ext.util.KeyNav(me.inputEl, {
down: me.onDownArrow,
esc: {
handler: me.onEsc,
scope: me,
defaultEventAction: false
},
scope: me,
forceKeyDown: true
});
if (!me.editable) {
me.mon(me.inputEl, 'click', me.onTriggerClick, me);
}
if (Ext.isGecko) {
me.inputEl.dom.setAttribute('autocomplete', 'off');
}
},
onEsc: function(e) {
if (Ext.isIE) {
e.preventDefault();
}
if (this.isExpanded) {
this.collapse();
e.stopEvent();
}
},
onDownArrow: function(e) {
if (!this.isExpanded) {
this.onTriggerClick();
}
},
expand: function() {
var me = this,
bodyEl, picker, collapseIf;
if (me.rendered && !me.isExpanded && !me.isDestroyed) {
me.expanding = true;
bodyEl = me.bodyEl;
picker = me.getPicker();
collapseIf = me.collapseIf;
picker.show();
me.isExpanded = true;
me.alignPicker();
bodyEl.addCls(me.openCls);
me.mon(Ext.getDoc(), {
mousewheel: collapseIf,
mousedown: collapseIf,
scope: me
});
Ext.EventManager.onWindowResize(me.alignPicker, me);
me.fireEvent('expand', me);
me.onExpand();
delete me.expanding;
}
},
onExpand: Ext.emptyFn,
alignPicker: function() {
var me = this,
picker = me.getPicker();
if (me.isExpanded) {
if (me.matchFieldWidth) {
picker.setWidth(me.bodyEl.getWidth());
}
if (picker.isFloating()) {
me.doAlign();
}
}
},
doAlign: function(){
var me = this,
picker = me.picker,
aboveSfx = '-above',
isAbove;
me.picker.alignTo(me.triggerWrap, me.pickerAlign, me.pickerOffset);
isAbove = picker.el.getY() < me.inputEl.getY();
me.bodyEl[isAbove ? 'addCls' : 'removeCls'](me.openCls + aboveSfx);
picker[isAbove ? 'addCls' : 'removeCls'](picker.baseCls + aboveSfx);
},
collapse: function() {
if (this.isExpanded && !this.isDestroyed) {
var me = this,
openCls = me.openCls,
picker = me.picker,
doc = Ext.getDoc(),
collapseIf = me.collapseIf,
aboveSfx = '-above';
picker.hide();
me.isExpanded = false;
me.bodyEl.removeCls([openCls, openCls + aboveSfx]);
picker.el.removeCls(picker.baseCls + aboveSfx);
doc.un('mousewheel', collapseIf, me);
doc.un('mousedown', collapseIf, me);
Ext.EventManager.removeResizeListener(me.alignPicker, me);
me.fireEvent('collapse', me);
me.onCollapse();
}
},
onCollapse: Ext.emptyFn,
collapseIf: function(e) {
var me = this;
if (!me.isDestroyed && !e.within(me.bodyEl, false, true) && !e.within(me.picker.el, false, true) && !me.isEventWithinPickerLoadMask(e)) {
me.collapse();
}
},
getPicker: function() {
var me = this;
return me.picker || (me.picker = me.createPicker());
},
createPicker: Ext.emptyFn,
onTriggerClick: function() {
var me = this;
if (!me.readOnly && !me.disabled) {
if (me.isExpanded) {
me.collapse();
} else {
me.expand();
}
me.inputEl.focus();
}
},
triggerBlur: function() {
var picker = this.picker;
this.callParent(arguments);
if (picker && picker.isVisible()) {
picker.hide();
}
},
mimicBlur: function(e) {
var me = this,
picker = me.picker;
if (!picker || !e.within(picker.el, false, true) && !me.isEventWithinPickerLoadMask(e)) {
me.callParent(arguments);
}
},
onDestroy : function(){
var me = this,
picker = me.picker;
Ext.EventManager.removeResizeListener(me.alignPicker, me);
Ext.destroy(me.keyNav);
if (picker) {
delete picker.pickerField;
picker.destroy();
}
me.callParent();
},
isEventWithinPickerLoadMask: function(e) {
var loadMask = this.picker.loadMask;
return loadMask ? e.within(loadMask.maskEl, false, true) || e.within(loadMask.el, false, true) : false;
}
});
Ext.define('Ext.selection.Model', {
extend:  Ext.util.Observable ,
alternateClassName: 'Ext.AbstractSelectionModel',
mixins: {
bindable:  Ext.util.Bindable     
},
allowDeselect: undefined,
toggleOnClick: true,
selected: null,
pruneRemoved: true,
suspendChange: 0,
constructor: function(cfg) {
var me = this;
cfg = cfg || {};
Ext.apply(me, cfg);
me.addEvents(
'selectionchange',
'focuschange'
);
me.modes = {
SINGLE: true,
SIMPLE: true,
MULTI: true
};
me.setSelectionMode(cfg.mode || me.mode);
me.selected = new Ext.util.MixedCollection(null, me.getSelectionId);
me.callParent(arguments);
},
bindStore: function(store, initial){
var me = this;
me.mixins.bindable.bindStore.apply(me, arguments);
if(me.store && !initial) {
me.refresh();
}
},
getStoreListeners: function() {
var me = this;
return {
add: me.onStoreAdd,
clear: me.onStoreClear,
bulkremove: me.onStoreRemove,
update: me.onStoreUpdate,
load: me.onStoreLoad,
idchanged: me.onModelIdChanged,
refresh: me.onStoreRefresh
};
},
suspendChanges: function(){
++this.suspendChange;
},
resumeChanges: function(){
if (this.suspendChange) {
--this.suspendChange;
}
},
selectAll: function(suppressEvent) {
var me = this,
selections = me.store.getRange(),
i = 0,
len = selections.length,
start = me.getSelection().length;
me.suspendChanges();
for (; i < len; i++) {
me.doSelect(selections[i], true, suppressEvent);
}
me.resumeChanges();
if (!suppressEvent) {
me.maybeFireSelectionChange(me.getSelection().length !== start);
}
},
deselectAll: function(suppressEvent) {
var me = this,
selections = me.getSelection(),
selIndexes = {},
store = me.store,
start = selections.length,
i, l, rec;
for (i = 0, l = selections.length; i < l; i++) {
rec = selections[i];
selIndexes[rec.internalId] = store.indexOf(rec);
}
selections = Ext.Array.sort(selections, function(r1, r2){
var idx1 = selIndexes[r1.internalId],
idx2 = selIndexes[r2.internalId];
return idx1 < idx2 ? -1 : 1;
});
me.suspendChanges();
me.doDeselect(selections, suppressEvent);
me.resumeChanges();
if (!suppressEvent) {
me.maybeFireSelectionChange(me.getSelection().length !== start);
}
},
selectWithEvent: function(record, e) {
var me = this,
isSelected = me.isSelected(record),
shift = e.shiftKey,
ctrl = e.ctrlKey,
start = me.selectionStart,
selected = me.getSelection(),
len = selected.length,
allowDeselect = me.allowDeselect,
toDeselect, i, item;
switch (me.selectionMode) {
case 'MULTI':
if (shift && start) {
me.selectRange(start, record, ctrl);
} else if (ctrl && isSelected) {
me.doDeselect(record, false);
} else if (ctrl) {
me.doSelect(record, true, false);
} else if (isSelected && !shift && !ctrl && len > 1) {
toDeselect = [];
for (i = 0; i < len; ++i) {
item = selected[i];
if (item !== record) {
toDeselect.push(item);    
}
}
me.doDeselect(toDeselect);
} else if (!isSelected) {
me.doSelect(record, false);
}
break;
case 'SIMPLE':
if (isSelected) {
me.doDeselect(record);
} else {
me.doSelect(record, true);
}
break;
case 'SINGLE':
if (allowDeselect && !ctrl) {
allowDeselect = me.toggleOnClick;
}
if (allowDeselect && isSelected) {
me.doDeselect(record);
} else {
me.doSelect(record, false);
}
break;
}
if (!shift) {
if (me.isSelected(record)) {
me.selectionStart = record;
} else {
me.selectionStart = null;
}
}
},
afterKeyNavigate: function(e, record) {
var me = this,
recIdx,
fromIdx,
isSelected = me.isSelected(record),
from = (me.selectionStart && me.isSelected(me.lastFocused)) ? me.selectionStart : (me.selectionStart = me.lastFocused),
key = e.getCharCode(),
isSpace = key === e.SPACE,
direction = key === e.UP || key === e.PAGE_UP ? 'up' : (key === e.DOWN || key === e.DOWN ? 'down' : null);
switch (me.selectionMode) {
case 'MULTI':
if (isSpace) {
if (e.shiftKey) {
me.selectRange(from, record, e.ctrlKey);
} else {
if (isSelected) {
me.doDeselect(record, e.ctrlKey);
me.setLastFocused(null);
me.setLastFocused(record);
}
else {
me.doSelect(record, e.ctrlKey);
}
}
}
else if (e.shiftKey && from) {
fromIdx = me.store.indexOf(from);
recIdx = me.store.indexOf(record);
if (direction === 'up' && fromIdx <= recIdx) {
me.deselectRange(me.lastFocused, recIdx + 1);
}
else if (direction === 'down' && fromIdx >= recIdx) {
me.deselectRange(me.lastFocused, recIdx - 1);
}
else if (from !== record) {
me.selectRange(from, record, e.ctrlKey);
}
me.lastSelected = record;
me.setLastFocused(record);
}
else if (e.ctrlKey && isSelected) {
me.setLastFocused(record);
}
else if (e.ctrlKey) {
me.setLastFocused(record);
}
else {
me.doSelect(record, false);
}
break;
case 'SIMPLE':
if (isSelected) {
me.doDeselect(record);
} else {
me.doSelect(record, true);
}
break;
case 'SINGLE':
if (isSpace) {
if (isSelected) {
me.doDeselect(record);
me.setLastFocused(record);
} else {
me.doSelect(record);
}
}
else if (e.ctrlKey) {
me.setLastFocused(record);
}
else if (me.allowDeselect && isSelected) {
me.doDeselect(record);
}
else {
me.doSelect(record, false);
}
break;
}
if (!e.shiftKey) {
if (me.isSelected(record)) {
me.selectionStart = record;
}
}
},
selectRange : function(startRow, endRow, keepExisting) {
var me = this,
store = me.store,
selected = me.selected.items,
result, i, len, toSelect, toDeselect, idx, rec;
if (me.isLocked()){
return;
}
result = me.normalizeRowRange(startRow, endRow);
startRow = result[0];
endRow = result[1];
toSelect = [];
for (i = startRow; i <= endRow; i++){
if (!me.isSelected(store.getAt(i))) {
toSelect.push(store.getAt(i));
}
}
if (!keepExisting) {
toDeselect = [];
me.suspendChanges();
for (i = 0, len = selected.length; i < len; ++i) {
rec = selected[i];
idx = store.indexOf(rec);
if (idx < startRow || idx > endRow) {
toDeselect.push(rec)
}
}
for (i = 0, len = toDeselect.length; i < len; ++i) {
me.doDeselect(toDeselect[i]);
}
me.resumeChanges();
}
me.doMultiSelect(toSelect, true);
},
deselectRange : function(startRow, endRow) {
var me = this,
store = me.store,
result, i, toDeselect, record;
if (me.isLocked()){
return;
}
result = me.normalizeRowRange(startRow, endRow);
startRow = result[0];
endRow = result[1];
toDeselect = [];
for (i = startRow; i <= endRow; i++) {
record = store.getAt(i);
if (me.isSelected(record)) {
toDeselect.push(record);
}
}
me.doDeselect(toDeselect);
},
normalizeRowRange: function(startRow, endRow) {
var store = this.store,
tmp;
if (!Ext.isNumber(startRow)) {
startRow = store.indexOf(startRow);
}
startRow = Math.max(0, startRow);
if (!Ext.isNumber(endRow)) {
endRow = store.indexOf(endRow);
}
endRow = Math.min(endRow, store.getCount() - 1);
if (startRow > endRow){
tmp = endRow;
endRow = startRow;
startRow = tmp;
}    
return [startRow, endRow];
},
onModelIdChanged: function(store, model, oldId, newId, oldInternalId) {
this.selected.updateKey(oldInternalId, newId);
},
select: function(records, keepExisting, suppressEvent) {
if (Ext.isDefined(records)) {
this.doSelect(records, keepExisting, suppressEvent);
}
},
deselect: function(records, suppressEvent) {
this.doDeselect(records, suppressEvent);
},
doSelect: function(records, keepExisting, suppressEvent) {
var me = this,
record;
if (me.locked || !me.store) {
return;
}
if (typeof records === "number") {
record = me.store.getAt(records);
if (!record) {
return;
}
records = [record];
}
if (me.selectionMode == "SINGLE" && records) {
record = records.length ? records[0] : records;
me.doSingleSelect(record, suppressEvent);
} else {
me.doMultiSelect(records, keepExisting, suppressEvent);
}
},
doMultiSelect: function(records, keepExisting, suppressEvent) {
var me = this,
selected = me.selected,
change = false,
result, i, len, record, commit;
if (me.locked) {
return;
}
records = !Ext.isArray(records) ? [records] : records;
len = records.length;
if (!keepExisting && selected.getCount() > 0) {
result = me.deselectDuringSelect(records, selected.getRange(), suppressEvent);
if (result[0]) {
me.maybeFireSelectionChange(result[1] > 0 && !suppressEvent);
return;
}
}
commit = function() {
selected.add(record);
change = true;
};
for (i = 0; i < len; i++) {
record = records[i];
if (me.isSelected(record)) {
continue;
}
me.lastSelected = record;
me.onSelectChange(record, true, suppressEvent, commit);
}
if (!me.preventFocus) {
me.setLastFocused(record, suppressEvent);
}
me.maybeFireSelectionChange(change && !suppressEvent);
},
deselectDuringSelect: function(toSelect, selected, suppressEvent) {
var me = this,
len = selected.length,
changed = 0,
failed = false,
item, i;
me.suspendChanges();
for (i = 0; i < len; ++i) {
item = selected[i];
if (!Ext.Array.contains(toSelect, item)) {
if (me.doDeselect(item, suppressEvent)) {
++changed;
} else {
failed = true;
}
}
}
me.resumeChanges();
return [failed, changed];
},
doDeselect: function(records, suppressEvent) {
var me = this,
selected = me.selected,
i = 0,
len, record,
attempted = 0,
accepted = 0,
commit;
if (me.locked || !me.store) {
return false;
}
if (typeof records === "number") {
record = me.store.getAt(records);
if (!record) {
return false;
}
records = [record];
} else if (!Ext.isArray(records)) {
records = [records];
}
commit = function() {
++accepted;
selected.remove(record);
};
len = records.length;
me.suspendChanges();
for (; i < len; i++) {
record = records[i];
if (me.isSelected(record)) {
if (me.lastSelected === record) {
me.lastSelected = selected.last();
if (me.lastFocused === record) {
me.setLastFocused(null);
}
}
++attempted;
me.onSelectChange(record, false, suppressEvent, commit);
}
}
me.resumeChanges();
me.maybeFireSelectionChange(accepted > 0 && !suppressEvent);
return accepted === attempted;
},
doSingleSelect: function(record, suppressEvent) {
var me = this,
changed = false,
selected = me.selected,
commit;
if (me.locked) {
return;
}
if (me.isSelected(record)) {
return;
}
if (selected.getCount()) {
me.suspendChanges();
if (!me.doDeselect(me.lastSelected, suppressEvent)) {
me.resumeChanges();
return;
}
me.resumeChanges();
}
commit = function() {
selected.add(record);
me.lastSelected = record;
changed = true;
};
me.onSelectChange(record, true, suppressEvent, commit);
if (changed) {
if (!suppressEvent && !me.preventFocus) {
me.setLastFocused(record);
}
me.maybeFireSelectionChange(!suppressEvent);
}
},
setLastFocused: function(record, supressFocus) {
var me = this,
recordBeforeLast = me.lastFocused;
if (record !== recordBeforeLast) {
me.lastFocused = record;
me.onLastFocusChanged(recordBeforeLast, record, supressFocus);
}
},
isFocused: function(record) {
return record === this.getLastFocused();
},
maybeFireSelectionChange: function(fireEvent) {
var me = this;
if (fireEvent && !me.suspendChange) {
me.fireEvent('selectionchange', me, me.getSelection());
}
},
getLastSelected: function() {
return this.lastSelected;
},
getLastFocused: function() {
return this.lastFocused;
},
getSelection: function() {
return this.selected.getRange();
},
getSelectionMode: function() {
return this.selectionMode;
},
setSelectionMode: function(selMode) {
selMode = selMode ? selMode.toUpperCase() : 'SINGLE';
this.selectionMode = this.modes[selMode] ? selMode : 'SINGLE';
},
isLocked: function() {
return this.locked;
},
setLocked: function(locked) {
this.locked = !!locked;
},
isRangeSelected: function(startRow, endRow) {
var me = this,
store = me.store,
i, result;
result = me.normalizeRowRange(startRow, endRow);
startRow = result[0];
endRow = result[1];
for (i = startRow; i <= endRow; i++) {
if (!me.isSelected(store.getAt(i))) {
return false;
}
}
return true;
},
isSelected: function(record) {
record = Ext.isNumber(record) ? this.store.getAt(record) : record;
return this.selected.contains(record);
},
hasSelection: function() {
return this.selected.getCount() > 0;
},
getSelectionId: function(record){
return record.internalId;
},
pruneIf: function() {
var me = this,
selected = me.selected,
toRemove = [],
len = selected.length,
i, item;
if (me.pruneRemoved) {
for (i = 0; i < len; i++) {
item = selected.getAt(i);
if (!this.storeHasSelected(item)) {
toRemove.push(item);
}
}
if (toRemove.length) {
for (i = 0, len = toRemove.length; i < len; i++) {
selected.remove(toRemove[i]);
}
me.maybeFireSelectionChange(true);
}
}
},
storeHasSelected: function(record) {
var store = this.store,
records,
len, id, i;
if (record.hasId() && store.getById(record.getId())) {
return true;
} else {
records = store.data.items;
len = records.length;
id = record.internalId;
for (i = 0; i < len; ++i) {
if (id === records[i].internalId) {
return true;
}
}
}
return false;
},
refresh: function() {
var me = this,
store = me.store,
rec,
toBeSelected = [],
toBeReAdded = [],
oldSelections = me.getSelection(),
len = oldSelections.length,
selection,
change,
i = 0,
lastFocused = me.getLastFocused();
if (!store) {
return;
}
for (; i < len; i++) {
selection = oldSelections[i];
if (store.indexOf(selection) !== -1) {
toBeSelected.push(selection);
}
else if (!me.pruneRemoved) {
rec = store.getById(selection.getId());
if (rec) {
toBeSelected.push(rec);
}
else {
toBeReAdded.push(selection)
}
}
if (me.mode === 'SINGLE' && toBeReAdded.length) {
break;
}
}
if (me.selected.getCount() != (toBeSelected.length + toBeReAdded.length)) {
change = true;
}
me.clearSelections();
if (store.indexOf(lastFocused) !== -1) {
me.setLastFocused(lastFocused, true);
}
if (toBeSelected.length) {
me.doSelect(toBeSelected, false, true);
}
if (toBeReAdded.length) {
me.selected.addAll(toBeReAdded);
if (!me.lastSelected) {
me.lastSelected = toBeReAdded[toBeReAdded.length - 1];
}
}
me.maybeFireSelectionChange(change);
},
clearSelections: function() {
this.selected.clear();
this.lastSelected = null;
this.setLastFocused(null);
},
onStoreAdd: Ext.emptyFn,
onStoreClear: function() {
if (this.selected.getCount() > 0) {
this.clearSelections();
this.maybeFireSelectionChange(true);
}
},
onStoreRemove: function(store, records, indexes, isMove) {
var me = this;
if (me.selectionStart && Ext.Array.contains(records, me.selectionStart)) {
me.selectionStart = null;
}
if (isMove || me.locked || !me.pruneRemoved) {
return;
}
me.deselectDeletedRecords(records);
},
deselectDeletedRecords: function(records) {
var me = this,
selected = me.selected,
i, length = records.length,
removed = 0,
record;
for (i = 0; i < length; i++) {
record = records[i];
if (selected.remove(record)) {
if (me.lastSelected == record) {
me.lastSelected = null;
}
if (me.getLastFocused() == record) {
me.setLastFocused(null);
}
++removed;
}
}
if (removed) {
me.maybeFireSelectionChange(true);
}
},
getCount: function() {
return this.selected.getCount();
},
onUpdate: Ext.emptyFn,
destroy: function(){
this.clearListeners();    
},
onStoreUpdate: Ext.emptyFn,
onStoreRefresh: Ext.emptyFn,
onStoreLoad: Ext.emptyFn,
onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
var me = this,
eventName = isSelected ? 'select' : 'deselect';
if ((suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false &&
commitFn() !== false) {
if (!suppressEvent) {
me.fireEvent(eventName, me, record);
}
}   
},
onLastFocusChanged: function(oldFocused, newFocused) {
this.fireEvent('focuschange', this, oldFocused, newFocused);
},
onEditorKey: Ext.emptyFn,
beforeViewRender: function(view) {
this.views = this.views || [];
this.views.push(view);
this.bindStore(view.getStore(), true);
},
bindComponent: Ext.emptyFn
});
Ext.define('Ext.selection.DataViewModel', {
extend:  Ext.selection.Model ,
deselectOnContainerClick: true,
enableKeyNav: true,
constructor: function(cfg){
this.addEvents(
'beforedeselect',
'beforeselect',
'deselect',
'select'
);
this.callParent(arguments);
},
bindComponent: function(view) {
var me = this,
eventListeners = {
refresh: me.refresh,
scope: me
};
me.view = view;
me.bindStore(view.getStore());
eventListeners[view.triggerEvent] = me.onItemClick;
eventListeners[view.triggerCtEvent] = me.onContainerClick;
view.on(eventListeners);
if (me.enableKeyNav) {
me.initKeyNav(view);
}
},
onUpdate: function(record){
var view = this.view;
if (view && this.isSelected(record)) {
view.onItemSelect(record);
}
},
onItemClick: function(view, record, item, index, e) {
this.selectWithEvent(record, e);
},
onContainerClick: function() {
if (this.deselectOnContainerClick) {
this.deselectAll();
}
},
initKeyNav: function(view) {
var me = this;
if (!view.rendered) {
view.on({
render: Ext.Function.bind(me.initKeyNav, me, [view]),
single: true
});
return;
}
view.el.set({
tabIndex: -1
});
me.keyNav = new Ext.util.KeyNav({
target: view.el,
ignoreInputFields: true,
down: Ext.pass(me.onNavKey, [1], me),
right: Ext.pass(me.onNavKey, [1], me),
left: Ext.pass(me.onNavKey, [-1], me),
up: Ext.pass(me.onNavKey, [-1], me),
scope: me
});
},
onNavKey: function(step) {
step = step || 1;
var me = this,
view = me.view,
selected = me.getSelection()[0],
numRecords = me.view.store.getCount(),
idx;
if (selected) {
idx = view.indexOf(view.getNode(selected)) + step;
} else {
idx = 0;
}
if (idx < 0) {
idx = numRecords - 1;
} else if (idx >= numRecords) {
idx = 0;
}
me.select(idx);
},
onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
var me = this,
view = me.view,
eventName = isSelected ? 'select' : 'deselect';
if ((suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false &&
commitFn() !== false) {
if (view) {
if (isSelected) {
view.onItemSelect(record);
} else {
view.onItemDeselect(record);
}
}
if (!suppressEvent) {
me.fireEvent(eventName, me, record);
}
}
},
onLastFocusChanged: function(oldFocus, newFocus, suppressFocus){
var view = this.view;
if (view && !suppressFocus && newFocus) {
view.focusNode(newFocus);
this.fireEvent('focuschange', this, oldFocus, newFocus);
}
},
destroy: function(){
Ext.destroy(this.keyNav);
this.callParent();
}
});
Ext.define('Ext.view.AbstractView', {
extend:  Ext.Component ,
mixins: {
bindable:  Ext.util.Bindable 
},
inheritableStatics: {
getRecord: function(node) {
return this.getBoundView(node).getRecord(node);
},
getBoundView: function(node) {
return Ext.getCmp(node.boundView);
}
},
deferInitialRefresh: true,
itemCls: Ext.baseCSSPrefix + 'dataview-item',
loadingText: 'Loading...',
loadMask: true,
loadingUseMsg: true,
selectedItemCls: Ext.baseCSSPrefix + 'item-selected',
emptyText: "",
deferEmptyText: true,
trackOver: false,
blockRefresh: false,
preserveScrollOnRefresh: false,
ariaRole: 'listbox',
itemAriaRole: 'option',
last: false,
triggerEvent: 'itemclick',
triggerCtEvent: 'containerclick',
addCmpEvents: function() {
},
initComponent : function(){
var me = this,
isDef = Ext.isDefined,
itemTpl = me.itemTpl,
memberFn = {};
if (itemTpl) {
if (Ext.isArray(itemTpl)) {
itemTpl = itemTpl.join('');
} else if (Ext.isObject(itemTpl)) {
memberFn = Ext.apply(memberFn, itemTpl.initialConfig);
itemTpl = itemTpl.html;
}
if (!me.itemSelector) {
me.itemSelector = '.' + me.itemCls;
}
itemTpl = Ext.String.format('<tpl for="."><div class="{0}" role="{2}">{1}</div></tpl>', me.itemCls, itemTpl, me.itemAriaRole);
me.tpl = new Ext.XTemplate(itemTpl, memberFn);
}
me.callParent();
me.tpl = me.getTpl('tpl');
if (me.overItemCls) {
me.trackOver = true;
}
me.addEvents(
'beforerefresh',
'refresh',
'viewready',
'itemupdate',
'itemadd',
'itemremove'
);
me.addCmpEvents();
me.store = Ext.data.StoreManager.lookup(me.store || 'ext-empty-store');
if (!me.dataSource) {
me.dataSource = me.store;
}
me.bindStore(me.dataSource, true, 'dataSource');
if (!me.all) {
me.all = new Ext.CompositeElementLite();
}
me.scrollState = {
top: 0,
left: 0
};
me.on({
scroll: me.onViewScroll,
element: 'el',
scope: me
});
},
onRender: function() {
var me = this,
mask = me.loadMask,
maskStore = me.getMaskStore(),
cfg = {
target: me,
msg: me.loadingText,
msgCls: me.loadingCls,
useMsg: me.loadingUseMsg,
store: maskStore
};
me.callParent(arguments);
if (mask && !maskStore.proxy.isSynchronous) {
if (Ext.isObject(mask)) {
cfg = Ext.apply(cfg, mask);
}
me.loadMask = new Ext.LoadMask(cfg);
me.loadMask.on({
scope: me,
beforeshow: me.onMaskBeforeShow,
hide: me.onMaskHide
});
}
},
finishRender: function() {
var me = this;
me.callParent(arguments);
if (!me.up('[collapsed],[hidden]')) {
me.doFirstRefresh(me.dataSource);
}
},
onBoxReady: function() {
var me = this;
me.callParent(arguments);
if (!me.firstRefreshDone) {
me.doFirstRefresh(me.dataSource);
}
},
getMaskStore: function(){
return this.store;    
},
onMaskBeforeShow: function(){
var me = this,
loadingHeight = me.loadingHeight;
if (loadingHeight && loadingHeight > me.getHeight()) {
me.hasLoadingHeight = true;
me.oldMinHeight = me.minHeight;
me.minHeight = loadingHeight;
me.updateLayout();
}
},
onMaskHide: function(){
var me = this;
if (!me.destroying && me.hasLoadingHeight) {
me.minHeight = me.oldMinHeight;
me.updateLayout();
delete me.hasLoadingHeight;
}
},
beforeRender: function() {
this.callParent(arguments);
this.getSelectionModel().beforeViewRender(this);
},
afterRender: function() {
this.callParent(arguments);
this.getSelectionModel().bindComponent(this);
},
getSelectionModel: function(){
var me = this,
mode = 'SINGLE';
if (me.simpleSelect) {
mode = 'SIMPLE';
} else if (me.multiSelect) {
mode = 'MULTI';
}
if (!me.selModel || !me.selModel.events) {
me.selModel = new Ext.selection.DataViewModel(Ext.apply({
allowDeselect: me.allowDeselect,
mode: mode
}, me.selModel));
}
if (!me.selModel.hasRelaySetup) {
me.relayEvents(me.selModel, [
'selectionchange', 'beforeselect', 'beforedeselect', 'select', 'deselect', 'focuschange'
]);
me.selModel.hasRelaySetup = true;
}
if (me.disableSelection) {
me.selModel.locked = true;
}
return me.selModel;
},
refresh: function() {
var me = this,
targetEl,
targetParent,
oldDisplay,
nextSibling,
dom,
records;
if (!me.rendered || me.isDestroyed) {
return;
}
if (!me.hasListeners.beforerefresh || me.fireEvent('beforerefresh', me) !== false) {
targetEl = me.getTargetEl();
records = me.getViewRange();
dom = targetEl.dom;
if (!me.preserveScrollOnRefresh) {
targetParent = dom.parentNode;
oldDisplay = dom.style.display;
dom.style.display = 'none';
nextSibling = dom.nextSibling;
targetParent.removeChild(dom);
}
if (me.refreshCounter) {
me.clearViewEl();
} else {
me.fixedNodes = targetEl.dom.childNodes.length;
me.refreshCounter = 1;
}
me.tpl.append(targetEl, me.collectData(records, me.all.startIndex));
if (records.length < 1) {
if (!this.store.loading && (!me.deferEmptyText || me.hasFirstRefresh)) {
Ext.core.DomHelper.insertHtml('beforeEnd', targetEl.dom, me.emptyText);
}
me.all.clear();
} else {
me.collectNodes(targetEl.dom);
me.updateIndexes(0);
}
if (me.hasFirstRefresh) {
if (me.refreshSelmodelOnRefresh !== false) {
me.selModel.refresh();
} else {
me.selModel.pruneIf();
}
}
me.hasFirstRefresh = true;
if (!me.preserveScrollOnRefresh) {
targetParent.insertBefore(dom, nextSibling);
dom.style.display = oldDisplay;
}
this.refreshSize();
me.fireEvent('refresh', me);
if (!me.viewReady) {
me.viewReady = true;
me.fireEvent('viewready', me);
}
}
},
collectNodes: function(targetEl) {
this.all.fill(Ext.query(this.getItemSelector(), Ext.getDom(targetEl)), this.all.startIndex);
},
getViewRange: function() {
return this.dataSource.getRange();
},
refreshSize: function() {
var sizeModel = this.getSizeModel();
if (sizeModel.height.shrinkWrap || sizeModel.width.shrinkWrap) {
this.updateLayout();
}
},
clearViewEl: function(){
var me = this,
el = me.getTargetEl();
if (me.fixedNodes) {
while (el.dom.childNodes[me.fixedNodes]) {
el.dom.removeChild(el.dom.childNodes[me.fixedNodes]);
}
} else {
el.update('');
}
me.refreshCounter++;
},
onViewScroll: Ext.emptyFn,
onIdChanged: Ext.emptyFn,
saveScrollState: function() {
if (this.rendered) {
var dom = this.el.dom,
state = this.scrollState;
state.left = dom.scrollLeft;
state.top = dom.scrollTop;
}
},
restoreScrollState: function() {
if (this.rendered) {
var dom = this.el.dom, 
state = this.scrollState;
dom.scrollLeft = state.left;
dom.scrollTop = state.top;
}
},
prepareData: function(data, index, record) {
var associatedData, attr, hasCopied;
if (record) {
associatedData = record.getAssociatedData();
for (attr in associatedData) {
if (associatedData.hasOwnProperty(attr)) {
if (!hasCopied) {
data = Ext.Object.chain(data);
hasCopied = true;
}
data[attr] = associatedData[attr];
}
}
}
return data;
},
collectData: function(records, startIndex){
var data = [],
i = 0,
len = records.length,
record;
for (; i < len; i++) {
record = records[i];
data[i] = this.prepareData(record.data, startIndex + i, record);
}
return data;
},
bufferRender : function(records, index) {
var me = this,
div = me.renderBuffer || (me.renderBuffer = document.createElement('div'));
me.tpl.overwrite(div, me.collectData(records, index));
return  Ext.DomQuery.select(me.getItemSelector(), div);
},
getNodeContainer: function() {
return this.getTargetEl();
},
onUpdate : function(ds, record){
var me = this,
index,
node;
if (me.viewReady) {
index = me.dataSource.indexOf(record);
if (index > -1) {
node = me.bufferRender([record], index)[0];
if (me.getNode(record)) {
me.all.replaceElement(index, node, true);
me.updateIndexes(index, index);
me.selModel.onUpdate(record);
if (me.hasListeners.itemupdate) {
me.fireEvent('itemupdate', record, index, node);
}
return node;
}
}
}
},
onAdd : function(store, records, index) {
var me = this,
nodes;
if (me.rendered) {
if (me.all.getCount() === 0) {
me.refresh();
nodes = me.all.slice();
} else {
nodes = me.doAdd(records, index);
if (me.refreshSelmodelOnRefresh !== false) {
me.selModel.refresh();
}
me.updateIndexes(index);
me.refreshSize();
}
if (me.hasListeners.itemadd) {
me.fireEvent('itemadd', records, index, nodes);
}
}
},
doAdd: function(records, index) {
var me = this,
nodes = me.bufferRender(records, index, true),
all = me.all,
count = all.getCount(),
i, l, nodeContainer, fragment;
if (count === 0) {
nodeContainer = this.getNodeContainer();
fragment = document.createDocumentFragment();
for (i = 0, l = nodes.length; i < l; i++) {
fragment.appendChild(nodes[i]);
}
nodeContainer.appendChild(fragment);
} else if (index < count) {
if (index === 0) {
all.item(index).insertSibling(nodes, 'before', true);
} else {
all.item(index - 1).insertSibling(nodes, 'after', true);
}
} else {
all.last().insertSibling(nodes, 'after', true);
}
all.insert(index, nodes);
return nodes;
},
onRemove : function(ds, records, indexes) {
var me = this,
fireItemRemove = me.hasListeners.itemremove,
i,
record,
index;
if (me.all.getCount()) {
if (me.dataSource.getCount() === 0) {
if (fireItemRemove) {
for (i = indexes.length - 1; i >= 0; --i) {
me.fireEvent('itemremove', records[i], indexes[i]);
}
}
me.refresh();
} else {
for (i = indexes.length - 1; i >= 0; --i) {
record = records[i];
index = indexes[i];
me.doRemove(record, index);
if (fireItemRemove) {
me.fireEvent('itemremove', record, index);
}
}
me.updateIndexes(indexes[0]);
}
this.refreshSize();
}
},
doRemove: function(record, index) {
this.all.removeElement(index, true);
},
refreshNode : function(index) {
this.onUpdate(this.dataSource, this.dataSource.getAt(index));
},
updateIndexes : function(startIndex, endIndex) {
var nodes = this.all.elements,
records = this.getViewRange(),
i;
startIndex = startIndex || 0;
endIndex = endIndex || ((endIndex === 0) ? 0 : (nodes.length - 1));
for (i = startIndex; i <= endIndex; i++) {
nodes[i].viewIndex = i;
nodes[i].viewRecordId = records[i].internalId;
if (!nodes[i].boundView) {
nodes[i].boundView = this.id;
}
}
},
getStore : function() {
return this.store;
},
bindStore : function(store, initial, propName) {
var me = this;
me.mixins.bindable.bindStore.apply(me, arguments);
if (!initial) {
me.getSelectionModel().bindStore(store);
}
if (me.componentLayoutCounter) {
me.doFirstRefresh(store);
}
},
doFirstRefresh: function(store) {
var me = this;
me.firstRefreshDone = true;
if (store && !store.loading) {
if (me.deferInitialRefresh) {
me.applyFirstRefresh();
} else {
me.refresh();
}
}
},
applyFirstRefresh: function(){
var me = this;
if (me.isDestroyed) {
return;
}
if (me.up('[isCollapsingOrExpanding]')) {
Ext.Function.defer(me.applyFirstRefresh, 100, me);
} else {
Ext.Function.defer(function () {
if (!me.isDestroyed) {
me.refresh();
}
}, 1);
}
},
onUnbindStore: function(store) {
this.setMaskBind(null);
},
onBindStore: function(store, initial, propName) {
this.setMaskBind(store);
if (!initial && propName === 'store') {
this.bindStore(store, false, 'dataSource');
}
},
setMaskBind: function(store) {
var mask = this.loadMask;
if (mask && mask.bindStore) {
mask.bindStore(store);
}
},
getStoreListeners: function() {
var me = this;
return {
idchanged: me.onIdChanged,
refresh: me.onDataRefresh,
add: me.onAdd,
bulkremove: me.onRemove,
update: me.onUpdate,
clear: me.refresh
};
},
onDataRefresh: function() {
this.refreshView();
},
refreshView: function() {
var me = this,
blockedByAncestor = !me.firstRefreshDone && (!me.rendered || me.up('[collapsed],[isCollapsingOrExpanding],[hidden]'));
if (blockedByAncestor) {
me.deferInitialRefresh = false;
} else if (me.blockRefresh !== true) {
me.firstRefreshDone = true;
me.refresh();
}
},
findItemByChild: function(node){
return Ext.fly(node).findParent(this.getItemSelector(), this.getTargetEl());
},
findTargetByEvent: function(e) {
return e.getTarget(this.getItemSelector(), this.getTargetEl());
},
getSelectedNodes: function(){
var nodes   = [],
records = this.selModel.getSelection(),
ln = records.length,
i  = 0;
for (; i < ln; i++) {
nodes.push(this.getNode(records[i]));
}
return nodes;
},
getRecords: function(nodes) {
var records = [],
i = 0,
len = nodes.length,
data = this.dataSource.data;
for (; i < len; i++) {
records[records.length] = data.getByKey(nodes[i].viewRecordId);
}
return records;
},
getRecord: function(node){
return this.dataSource.data.getByKey(Ext.getDom(node).viewRecordId);
},
isSelected : function(node) {
var r = this.getRecord(node);
return this.selModel.isSelected(r);
},
select: function(records, keepExisting, suppressEvent) {
this.selModel.select(records, keepExisting, suppressEvent);
},
deselect: function(records, suppressEvent) {
this.selModel.deselect(records, suppressEvent);
},
getNode : function(nodeInfo) {
if ((!nodeInfo && nodeInfo !== 0) || !this.rendered) {
return null;
}
if (Ext.isString(nodeInfo)) {
return document.getElementById(nodeInfo);
}
if (Ext.isNumber(nodeInfo)) {
return this.all.elements[nodeInfo];
}
if (nodeInfo.isModel) {
return this.getNodeByRecord(nodeInfo);
}
return nodeInfo; 
},
getNodeByRecord: function(record) {
var ns = this.all.elements,
ln = ns.length,
i = 0;
for (; i < ln; i++) {
if (ns[i].viewRecordId === record.internalId) {
return ns[i];
}
}
return null;
},
getNodes: function(start, end) {
var all = this.all;
if (end === undefined) {
end = all.getCount();
} else {
end++;
}
return all.slice(start||0, end);
},
indexOf: function(node) {
node = this.getNode(node);
if (!node && node !== 0) {
return -1;
}
if (Ext.isNumber(node.viewIndex)) {
return node.viewIndex;
}
return this.all.indexOf(node);
},
onDestroy : function() {
var me = this;
me.all.clear();
me.callParent();
me.bindStore(null);
me.selModel.destroy();
},
onItemSelect: function(record) {
var node = this.getNode(record);
if (node) {
Ext.fly(node).addCls(this.selectedItemCls);
}
},
onItemDeselect: function(record) {
var node = this.getNode(record);
if (node) {
Ext.fly(node).removeCls(this.selectedItemCls);
}
},
getItemSelector: function() {
return this.itemSelector;
}
}, function() {
Ext.deprecate('extjs', '4.0', function() {
Ext.view.AbstractView.override({
getSelectionCount : function(){
if (Ext.global.console) {
Ext.global.console.warn("DataView: getSelectionCount will be removed, please interact with the Ext.selection.DataViewModel");
}
return this.selModel.getSelection().length;
},
getSelectedRecords : function(){
if (Ext.global.console) {
Ext.global.console.warn("DataView: getSelectedRecords will be removed, please interact with the Ext.selection.DataViewModel");
}
return this.selModel.getSelection();
},
select: function(records, keepExisting, supressEvents) {
if (Ext.global.console) {
Ext.global.console.warn("DataView: select will be removed, please access select through a DataView's SelectionModel, ie: view.getSelectionModel().select()");
}
var sm = this.getSelectionModel();
return sm.select.apply(sm, arguments);
},
clearSelections: function() {
if (Ext.global.console) {
Ext.global.console.warn("DataView: clearSelections will be removed, please access deselectAll through DataView's SelectionModel, ie: view.getSelectionModel().deselectAll()");
}
var sm = this.getSelectionModel();
return sm.deselectAll();
}
});
});
});
Ext.define('Ext.view.View', {
extend:  Ext.view.AbstractView ,
alternateClassName: 'Ext.DataView',
alias: 'widget.dataview',
deferHighlight: Ext.isIE7m ? 100 : 0,
mouseOverOutBuffer: 20,
inputTagRe: /^textarea$|^input$/i,
inheritableStatics: {
EventMap: {
mousedown: 'MouseDown',
mouseup: 'MouseUp',
click: 'Click',
dblclick: 'DblClick',
contextmenu: 'ContextMenu',
mouseover: 'MouseOver',
mouseout: 'MouseOut',
mouseenter: 'MouseEnter',
mouseleave: 'MouseLeave',
keydown: 'KeyDown',
focus: 'Focus'
}
},
initComponent: function() {
var me = this;
me.callParent();
if (me.mouseOverOutBuffer) {
me.handleMouseOver =
Ext.Function.createBuffered(me.handleMouseOver, me.mouseOverOutBuffer, me);
me.handleMouseOut =
Ext.Function.createBuffered(me.handleMouseOut, me.mouseOverOutBuffer, me);
me.lastMouseOverEvent = new Ext.EventObjectImpl();
me.lastMouseOutEvent = new Ext.EventObjectImpl();
}
else if (me.deferHighlight){
me.setHighlightedItem =
Ext.Function.createBuffered(me.setHighlightedItem, me.deferHighlight, me);
}
},
addCmpEvents: function() {
this.addEvents(
'beforeitemmousedown',
'beforeitemmouseup',
'beforeitemmouseenter',
'beforeitemmouseleave',
'beforeitemclick',
'beforeitemdblclick',
'beforeitemcontextmenu',
'beforeitemkeydown',
'itemmousedown',
'itemmouseup',
'itemmouseenter',
'itemmouseleave',
'itemclick',
'itemdblclick',
'itemcontextmenu',
'itemkeydown',
'beforecontainermousedown',
'beforecontainermouseup',
'beforecontainermouseover',
'beforecontainermouseout',
'beforecontainerclick',
'beforecontainerdblclick',
'beforecontainercontextmenu',
'beforecontainerkeydown',
'containermouseup',
'containermouseover',
'containermouseout',
'containerclick',
'containerdblclick',
'containercontextmenu',
'containerkeydown',
'selectionchange',
'beforeselect',
'beforedeselect',
'select',
'deselect',
'focuschange',
'highlightitem',
'unhighlightitem'
);
},
getFocusEl: function() {
return this.getTargetEl();
},
afterRender: function() {
var me = this,
buffer = me.mouseOverOutBuffer;
me.callParent();
me.mon(me.getTargetEl(), {
scope: me,
freezeEvent: true,
click: me.handleEvent,
mousedown: me.handleEvent,
mouseup: me.handleEvent,
dblclick: me.handleEvent,
contextmenu: me.handleEvent,
keydown: me.handleEvent,
mouseover: buffer ? me.onMouseOver : me.handleMouseOver,
mouseout:  buffer ? me.onMouseOut : me.handleMouseOut
});
},
onMouseOver: function(e) {
var me = this;
me.lastMouseOverEvent.setEvent(e.browserEvent, true);
me.handleMouseOver(me.lastMouseOverEvent);
},
onMouseOut: function(e) {
var me = this;
if (!me._mouseOutPending) {
me._mouseOutPending = true;
me.lastMouseOutEvent.setEvent(e.browserEvent, true);
me.handleMouseOut(me.lastMouseOutEvent);
}
},
handleMouseOver: function(e) {
var me = this,
itemSelector = me.dataRowSelector || me.itemSelector,
item = e.getTarget(itemSelector);
if (!me.isDestroyed) {
if (item) {
if (me.mouseOverItem !== item && me.el.contains(item)) {
me.mouseOverItem = e.item = item;
e.newType = 'mouseenter';
me.handleEvent(e);
}
} else {
e.item = e.newType = null;
me.handleEvent(e);
}
}
},
handleMouseOut: function(e) {
var me = this,
itemSelector = me.dataRowSelector || me.itemSelector,
item = e.getTarget(itemSelector),
sourceView;
if (!me.isDestroyed) {
me._mouseOutPending = false;
if (item) {
if (e.getRelatedTarget(itemSelector) !== item && me.mouseOverItem === item) {
sourceView = me.self.getBoundView(item);
e.item = item;
e.newType = 'mouseleave';
sourceView.handleEvent(e);
sourceView.mouseOverItem = null;
}
} else {
e.item = e.newType = null;
me.handleEvent(e);
}
}
e.newType = e.item = null;
},
handleEvent: function(e) {
var me = this,
key = e.type == 'keydown' && e.getKey();
if (me.processUIEvent(e) !== false) {
me.processSpecialEvent(e);
}
if (key === e.SPACE) {
if (!me.inputTagRe.test(e.getTarget().tagName)) {
e.stopEvent();
}
}
},
processItemEvent: Ext.emptyFn,
processContainerEvent: Ext.emptyFn,
processSpecialEvent: Ext.emptyFn,
processUIEvent: function(e) {
if (!Ext.getBody().isAncestor(e.target)) {
return;
}
var me = this,
item = e.getTarget(me.dataRowSelector || me.itemSelector, me.getTargetEl()),
map = me.statics().EventMap,
index, record,
type = e.type,
newType = e.type,
sm;
if (e.newType) {
newType = e.newType;
item = e.item;
}
if (!item && type == 'keydown') {
sm = me.getSelectionModel();
record = sm.lastFocused || sm.getLastSelected();
if (record) {
item = me.getNode(record, true);
}
}
if (item) {
if (!record) {
record = me.getRecord(item);
}
index = me.indexInStore ? me.indexInStore(record) : me.indexOf(item);
if (!record || me.processItemEvent(record, item, index, e) === false) {
return false;
}
if (
(me['onBeforeItem' + map[newType]](record, item, index, e) === false) ||
(me.fireEvent('beforeitem' + newType, me, record, item, index, e) === false) ||
(me['onItem' + map[newType]](record, item, index, e) === false)
) {
return false;
}
me.fireEvent('item' + newType, me, record, item, index, e);
}
else {
if (
(me.processContainerEvent(e) === false) ||
(me['onBeforeContainer' + map[type]](e) === false) ||
(me.fireEvent('beforecontainer' + type, me, e) === false) ||
(me['onContainer' + map[type]](e) === false)
) {
return false;
}
me.fireEvent('container' + type, me, e);
}
return true;
},
onItemMouseEnter: function(record, item, index, e) {
if (this.trackOver) {
this.highlightItem(item);
}
},
onItemMouseLeave : function(record, item, index, e) {
if (this.trackOver) {
this.clearHighlight();
}
},
onItemMouseDown: Ext.emptyFn,
onItemMouseUp: Ext.emptyFn,
onItemFocus: Ext.emptyFn,
onItemClick: Ext.emptyFn,
onItemDblClick: Ext.emptyFn,
onItemContextMenu: Ext.emptyFn,
onItemKeyDown: Ext.emptyFn,
onBeforeItemMouseDown: Ext.emptyFn,
onBeforeItemMouseUp: Ext.emptyFn,
onBeforeItemFocus: Ext.emptyFn,
onBeforeItemMouseEnter: Ext.emptyFn,
onBeforeItemMouseLeave: Ext.emptyFn,
onBeforeItemClick: Ext.emptyFn,
onBeforeItemDblClick: Ext.emptyFn,
onBeforeItemContextMenu: Ext.emptyFn,
onBeforeItemKeyDown: Ext.emptyFn,
onContainerMouseDown: Ext.emptyFn,
onContainerMouseUp: Ext.emptyFn,
onContainerMouseOver: Ext.emptyFn,
onContainerMouseOut: Ext.emptyFn,
onContainerClick: Ext.emptyFn,
onContainerDblClick: Ext.emptyFn,
onContainerContextMenu: Ext.emptyFn,
onContainerKeyDown: Ext.emptyFn,
onBeforeContainerMouseDown: Ext.emptyFn,
onBeforeContainerMouseUp: Ext.emptyFn,
onBeforeContainerMouseOver: Ext.emptyFn,
onBeforeContainerMouseOut: Ext.emptyFn,
onBeforeContainerClick: Ext.emptyFn,
onBeforeContainerDblClick: Ext.emptyFn,
onBeforeContainerContextMenu: Ext.emptyFn,
onBeforeContainerKeyDown: Ext.emptyFn,
setHighlightedItem: function(item){
var me = this,
highlighted = me.highlightedItem,
overItemCls = me.overItemCls,
beforeOverItemCls = me.beforeOverItemCls,
previous;
if (highlighted != item){
if (highlighted) {
Ext.fly(highlighted).removeCls(overItemCls);
previous = highlighted.previousSibling;
if (beforeOverItemCls && previous) {
Ext.fly(previous).removeCls(beforeOverItemCls);
}
me.fireEvent('unhighlightitem', me, highlighted);
}
me.highlightedItem = item;
if (item) {
Ext.fly(item).addCls(me.overItemCls);
previous = item.previousSibling;
if (beforeOverItemCls && previous) {
Ext.fly(previous).addCls(beforeOverItemCls);
}
me.fireEvent('highlightitem', me, item);
}
}
},
highlightItem: function(item) {
this.setHighlightedItem(item);
},
clearHighlight: function() {
this.setHighlightedItem(undefined);
},
onUpdate: function(store, record){
var me = this,
node,
newNode,
highlighted;
if (me.viewReady) {
node = me.getNode(record);
newNode = me.callParent(arguments);
highlighted = me.highlightedItem;
if (highlighted && highlighted === node) {
delete me.highlightedItem;
if (newNode) {
me.highlightItem(newNode);
}
}
}
},
refresh: function() {
this.clearHighlight();
this.callParent(arguments);
},
focusNode: function(rec){
var me          = this,
node        = me.getNode(rec, true),
el          = me.el,
adjustmentY = 0,
adjustmentX = 0,
elRegion    = el.getRegion(),
nodeRegion;
elRegion.bottom = elRegion.top + el.dom.clientHeight;
elRegion.right = elRegion.left + el.dom.clientWidth;
if (node) {
nodeRegion = Ext.fly(node).getRegion();
if (nodeRegion.top < elRegion.top) {
adjustmentY = nodeRegion.top - elRegion.top;
} else if (nodeRegion.bottom > elRegion.bottom) {
adjustmentY = nodeRegion.bottom - elRegion.bottom;
}
if (nodeRegion.left < elRegion.left) {
adjustmentX = nodeRegion.left - elRegion.left;
} else if (nodeRegion.right > elRegion.right) {
adjustmentX = nodeRegion.right - elRegion.right;
}
if (adjustmentX || adjustmentY) {
me.scrollBy(adjustmentX, adjustmentY, false);
}
el.focus();
}
},
bindStore: function (store, initial, propertyName) {
var dataSource = this[propertyName];
if (dataSource && dataSource.isFeatureStore) {
if (store.isFeatureStore) {
this.bindStoreListeners(store);
dataSource.bindStore(dataSource.store);
} else {
dataSource.bindStore(store);
}
} else {
this.callParent(arguments);
}
}
});
Ext.define('Ext.layout.component.BoundList', {
extend:  Ext.layout.component.Auto ,
alias: 'layout.boundlist',
type: 'component',
beginLayout: function(ownerContext) {
var me = this,
owner = me.owner,
toolbar = owner.pagingToolbar;
me.callParent(arguments);
if (owner.floating) {
ownerContext.savedXY = owner.getXY();
owner.setXY([0, -9999]);
}
if (toolbar) {
ownerContext.toolbarContext = ownerContext.context.getCmp(toolbar);
}
ownerContext.listContext = ownerContext.getEl('listEl');
},
beginLayoutCycle: function(ownerContext){
var owner = this.owner;
this.callParent(arguments);
if (ownerContext.heightModel.auto) {
owner.el.setHeight('auto');
owner.listEl.setHeight('auto');
}
},
getLayoutItems: function() {
var toolbar = this.owner.pagingToolbar;
return toolbar ? [toolbar] : [];
},
isValidParent: function() {
return true;
},
finishedLayout: function(ownerContext) {
var xy = ownerContext.savedXY;
this.callParent(arguments);
if (xy) {
this.owner.setXY(xy);
}
},
measureContentWidth: function(ownerContext) {
return this.owner.listEl.getWidth();
},
measureContentHeight: function(ownerContext) {
return this.owner.listEl.getHeight();
},
publishInnerHeight: function(ownerContext, height) {
var toolbar = ownerContext.toolbarContext,
toolbarHeight = 0;
if (toolbar) {
toolbarHeight = toolbar.getProp('height');
}
if (toolbarHeight === undefined) {
this.done = false;
} else {
ownerContext.listContext.setHeight(height - ownerContext.getFrameInfo().height - toolbarHeight);
}
},
calculateOwnerHeightFromContentHeight: function(ownerContext){
var height = this.callParent(arguments),
toolbar = ownerContext.toolbarContext;
if (toolbar) {
height += toolbar.getProp('height');
}
return height;
}
});
Ext.define('Ext.view.BoundList', {
extend:  Ext.view.View ,
alias: 'widget.boundlist',
alternateClassName: 'Ext.BoundList',
mixins: {
queryable:  Ext.Queryable 
},
pageSize: 0,
baseCls: Ext.baseCSSPrefix + 'boundlist',
itemCls: Ext.baseCSSPrefix + 'boundlist-item',
listItemCls: '',
shadow: false,
trackOver: true,
refreshed: 0,
deferInitialRefresh: false,
componentLayout: 'boundlist',
childEls: [
'listEl'
],
renderTpl: [
'<div id="{id}-listEl" role="presentation" class="{baseCls}-list-ct ', Ext.dom.Element.unselectableCls, '" style="overflow:auto"></div>',
'{%',
'var me=values.$comp, pagingToolbar=me.pagingToolbar;',
'if (pagingToolbar) {',
'pagingToolbar.ownerLayout = me.componentLayout;',
'Ext.DomHelper.generateMarkup(pagingToolbar.getRenderTree(), out);',
'}',
'%}',
{
disableFormats: true
}
],
initComponent: function() {
var me = this,
baseCls = me.baseCls,
itemCls = me.itemCls;
me.selectedItemCls = baseCls + '-selected';
if (me.trackOver) {
me.overItemCls = baseCls + '-item-over';
}
me.itemSelector = "." + itemCls;
if (me.floating) {
me.addCls(baseCls + '-floating');
}
if (!me.tpl) {
me.tpl = new Ext.XTemplate(
'<ul class="' + Ext.plainListCls + '"><tpl for=".">',
'<li role="option" unselectable="on" class="' + itemCls + '">' + me.getInnerTpl(me.displayField) + '</li>',
'</tpl></ul>'
);
} else if (!me.tpl.isTemplate) {
me.tpl = new Ext.XTemplate(me.tpl);
}
if (me.pageSize) {
me.pagingToolbar = me.createPagingToolbar();
}
me.callParent();
},
beforeRender: function() {
var me = this;
me.callParent(arguments);
if (me.up('menu')) {
me.addCls(Ext.baseCSSPrefix + 'menu');
}
},
getRefOwner: function() {
return this.pickerField || this.callParent();
},
getRefItems: function() {
return this.pagingToolbar ? [ this.pagingToolbar ] : [];
},
createPagingToolbar: function() {
return Ext.widget('pagingtoolbar', {
id: this.id + '-paging-toolbar',
pageSize: this.pageSize,
store: this.dataSource,
border: false,
ownerCt: this,
ownerLayout: this.getComponentLayout()
});
},
finishRenderChildren: function () {
var toolbar = this.pagingToolbar;
this.callParent(arguments);
if (toolbar) {
toolbar.finishRender();
}
},
refresh: function(){
var me = this,
tpl = me.tpl,
toolbar = me.pagingToolbar,
rendered = me.rendered;
tpl.field = me.pickerField;
tpl.store = me.store;
me.callParent();
tpl.field =  tpl.store = null;
if (rendered && toolbar && toolbar.rendered && !me.preserveScrollOnRefresh) {
me.el.appendChild(toolbar.el);
}
if (rendered && Ext.isIE6 && Ext.isStrict) {
me.listEl.repaint();
}
},
bindStore : function(store, initial) {
var toolbar = this.pagingToolbar;
this.callParent(arguments);
if (toolbar) {
toolbar.bindStore(store, initial);
}
},
getTargetEl: function() {
return this.listEl || this.el;
},
getInnerTpl: function(displayField) {
return '{' + displayField + '}';
},
onDestroy: function() {
Ext.destroyMembers(this, 'pagingToolbar', 'listEl');
this.callParent();
}
});
Ext.define('Ext.view.BoundListKeyNav', {
extend:  Ext.util.KeyNav ,
constructor: function(el, config) {
var me = this;
me.boundList = config.boundList;
me.callParent([el, Ext.apply({}, config, me.defaultHandlers)]);
},
defaultHandlers: {
up: function() {
var me = this,
boundList = me.boundList,
allItems = boundList.all,
oldItem = boundList.highlightedItem,
oldItemIdx = oldItem ? boundList.indexOf(oldItem) : -1,
newItemIdx = oldItemIdx > 0 ? oldItemIdx - 1 : allItems.getCount() - 1; 
me.highlightAt(newItemIdx);
},
down: function() {
var me = this,
boundList = me.boundList,
allItems = boundList.all,
oldItem = boundList.highlightedItem,
oldItemIdx = oldItem ? boundList.indexOf(oldItem) : -1,
newItemIdx = oldItemIdx < allItems.getCount() - 1 ? oldItemIdx + 1 : 0; 
me.highlightAt(newItemIdx);
},
pageup: function() {
},
pagedown: function() {
},
home: function() {
this.highlightAt(0);
},
end: function() {
var me = this;
me.highlightAt(me.boundList.all.getCount() - 1);
},
enter: function(e) {
this.selectHighlighted(e);
}
},
highlightAt: function(index) {
var boundList = this.boundList,
item = boundList.all.item(index);
if (item) {
item = item.dom;
boundList.highlightItem(item);
boundList.getTargetEl().scrollChildIntoView(item, false);
}
},
selectHighlighted: function(e) {
var boundList = this.boundList,
selModel = boundList.getSelectionModel(),
highlighted, highlightedRec;
highlighted = boundList.highlightedItem;
if (highlighted) {
highlightedRec = boundList.getRecord(highlighted);    
if (e.getKey() === e.ENTER || !selModel.isSelected(highlightedRec)) {
selModel.selectWithEvent(highlightedRec, e);
}
}
}
});
Ext.define('Ext.layout.component.field.ComboBox', {
extend:  Ext.layout.component.field.Trigger ,
alias: 'layout.combobox',
type: 'combobox',
startingWidth: null,
getTextWidth: function () {
var me = this,
owner = me.owner,
store = owner.store,
field = owner.displayField,
storeLn = store.data.length,
value = '',
i = 0, n = 0, ln, item, width;
for (; i < storeLn; i++) {
item = store.getAt(i).data[field];
ln = item.length;
if (ln > n) {
n = ln;
value = item;
}
}
width = Math.max(me.callParent(arguments), owner.inputEl.getTextWidth(value + owner.growAppend));
if (!me.startingWidth || owner.removingRecords) {
me.startingWidth = width;
if (width < owner.growMin) {
owner.defaultListConfig.minWidth = owner.growMin;
}
owner.removingRecords = false;
}
return (width < me.startingWidth) ? me.startingWidth : width;
}
});
Ext.define('Ext.form.field.ComboBox', {
extend: Ext.form.field.Picker ,
alternateClassName: 'Ext.form.ComboBox',
alias: ['widget.combobox', 'widget.combo'],
mixins: {
bindable:  Ext.util.Bindable     
},
componentLayout: 'combobox',
triggerCls: Ext.baseCSSPrefix + 'form-arrow-trigger',
hiddenName: '',
hiddenDataCls: Ext.baseCSSPrefix + 'hide-display ' + Ext.baseCSSPrefix + 'form-data-hidden',
ariaRole: 'combobox',
fieldSubTpl: [
'<div class="{hiddenDataCls}" role="presentation"></div>',
'<input id="{id}" type="{type}" role="{role}" {inputAttrTpl} class="{fieldCls} {typeCls} {editableCls}" autocomplete="off"',
'<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>',
'<tpl if="name"> name="{name}"</tpl>',
'<tpl if="placeholder"> placeholder="{placeholder}"</tpl>',
'<tpl if="size"> size="{size}"</tpl>',
'<tpl if="maxLength !== undefined"> maxlength="{maxLength}"</tpl>',
'<tpl if="readOnly"> readonly="readonly"</tpl>',
'<tpl if="disabled"> disabled="disabled"</tpl>',
'<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>',
'<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>',
'/>',
{
compiled: true,
disableFormats: true
}
],
getSubTplData: function(){
var me = this;
Ext.applyIf(me.subTplData, {
hiddenDataCls: me.hiddenDataCls
});
return me.callParent(arguments);
},
afterRender: function(){
var me = this;
me.callParent(arguments);
me.setHiddenValue(me.value);
},
multiSelect: false,
delimiter: ', ',
displayField: 'text',
triggerAction: 'all',
allQuery: '',
queryParam: 'query',
queryMode: 'remote',
queryCaching: true,
pageSize: 0,
anyMatch: false,
caseSensitive: false,
autoSelect: true,
typeAhead: false,
typeAheadDelay: 250,
selectOnTab: true,
forceSelection: false,
growToLongestValue: true,
clearFilterOnBlur: true,
defaultListConfig: {
loadingHeight: 70,
minWidth: 70,
maxHeight: 300,
shadow: 'sides'
},
transformInPlace: true,
ignoreSelection: 0,
removingRecords: null,
resizeComboToGrow: function () {
var me = this;
return me.grow && me.growToLongestValue;
},
initComponent: function() {
var me = this,
isDefined = Ext.isDefined,
store = me.store,
transform = me.transform,
displayTpl = me.displayTpl,
transformSelect, isLocalMode;
Ext.applyIf(me.renderSelectors, {
hiddenDataEl: '.' + me.hiddenDataCls.split(' ').join('.')
});
me.addEvents(
'beforequery',
'select',
'beforeselect',
'beforedeselect'
);
if (transform) {
transformSelect = Ext.getDom(transform);
if (transformSelect) {
if (!me.store) {
store = Ext.Array.map(Ext.Array.from(transformSelect.options), function(option){
return [option.value, option.text];
});
}
if (!me.name) {
me.name = transformSelect.name;
}
if (!('value' in me)) {
me.value = transformSelect.value;
}
}
}
me.bindStore(store || 'ext-empty-store', true);
store = me.store;
if (store.autoCreated) {
me.queryMode = 'local';
me.valueField = me.displayField = 'field1';
if (!store.expanded) {
me.displayField = 'field2';
}
}
if (!isDefined(me.valueField)) {
me.valueField = me.displayField;
}
isLocalMode = me.queryMode === 'local';
if (!isDefined(me.queryDelay)) {
me.queryDelay = isLocalMode ? 10 : 500;
}
if (!isDefined(me.minChars)) {
me.minChars = isLocalMode ? 0 : 4;
}
if (!displayTpl) {
me.displayTpl = new Ext.XTemplate(
'<tpl for=".">' +
'{[typeof values === "string" ? values : values["' + me.displayField + '"]]}' +
'<tpl if="xindex < xcount">' + me.delimiter + '</tpl>' +
'</tpl>'
);
} else if (!displayTpl.isTemplate) {
me.displayTpl = new Ext.XTemplate(displayTpl);
}
me.callParent();
me.doQueryTask = new Ext.util.DelayedTask(me.doRawQuery, me);
if (me.store.getCount() > 0) {
me.setValue(me.value);
}
if (transformSelect) {
if (me.transformInPlace) {
me.render(transformSelect.parentNode, transformSelect);
delete me.renderTo;
}
Ext.removeNode(transformSelect);
}
},
getStore : function(){
return this.store;
},
beforeBlur: function() {
var me = this,
filter = me.queryFilter;
me.doQueryTask.cancel();
me.assertValue();
if (filter && !filter.disabled && me.queryMode === 'local' && me.clearFilterOnBlur) {
filter.disabled = true;
me.store.filter();
}
},
onFocus: function() {
var me = this,
filter = me.queryFilter;
me.callParent(arguments);    
if (!me.duringTriggerClick && me.triggerAction !== 'all' && filter && filter.disabled && me.queryMode === 'local' && me.clearFilterOnBlur) {
delete me.lastQuery;
me.doRawQuery();
}
},
assertValue: function() {
var me = this,
value = me.getRawValue(),
rec, currentValue;
if (me.forceSelection) {
if (me.multiSelect) {
if (value !== me.getDisplayValue()) {
me.setValue(me.lastSelection);
}
} else {
rec = me.findRecordByDisplay(value);
if (rec) {
currentValue = me.value;
if (!me.findRecordByValue(currentValue)) {
me.select(rec, true);
}
} else {
me.setValue(me.lastSelection);
}
}
}
me.collapse();
},
onTypeAhead: function() {
var me = this,
displayField = me.displayField,
record = me.store.findRecord(displayField, me.getRawValue()),
boundList = me.getPicker(),
newValue, len, selStart;
if (record) {
newValue = record.get(displayField);
len = newValue.length;
selStart = me.getRawValue().length;
boundList.highlightItem(boundList.getNode(record));
if (selStart !== 0 && selStart !== len) {
me.setRawValue(newValue);
me.selectText(selStart, newValue.length);
}
}
},
resetToDefault: Ext.emptyFn,
beforeReset: function() {
var filter = this.queryFilter;
this.callParent();
if (filter && !filter.disabled) {
filter.disabled = true;
this.store.filter();
}
},
onUnbindStore: function(store) {
var me = this,
picker = me.picker,
filter = me.queryFilter;
if (filter) {
me.store.removeFilter(filter);
}
if (!store && picker) {
picker.bindStore(null);
}
},
onBindStore: function(store, initial) {
var picker = this.picker;
if (!initial) {
this.resetToDefault();
}
if (picker) {
picker.bindStore(store);
}
},
getStoreListeners: function() {
var me = this;
return {
beforeload: me.onBeforeLoad,
clear: me.onClear,
datachanged: me.onDataChanged,
load: me.onLoad,
exception: me.onException,
remove: me.onRemove
}; 
},
onBeforeLoad: function(){
++this.ignoreSelection;    
},
onDataChanged: function() {
var me = this;
if (me.resizeComboToGrow()) {
me.updateLayout();
}
},
onClear: function() {
var me = this;
if (me.resizeComboToGrow()) {
me.removingRecords = true;
me.onDataChanged();
}
},
onRemove: function() {
var me = this;
if (me.resizeComboToGrow()) {
me.removingRecords = true;
}
},
onException: function(){
if (this.ignoreSelection > 0) {
--this.ignoreSelection;
}
this.collapse();    
},
onLoad: function(store, records, success) {
var me = this;
if (me.ignoreSelection > 0) {
--me.ignoreSelection;
}
if (success && !store.lastOptions.rawQuery) {
if (me.value == null) {
if (me.store.getCount()) {
me.doAutoSelect();
} else {
me.setValue(me.value);
}
} else {
me.setValue(me.value);
}
}
},
doRawQuery: function() {
this.doQuery(this.getRawValue(), false, true);
},
doQuery: function(queryString, forceAll, rawQuery) {
var me = this,
queryPlan = me.beforeQuery({
query: queryString || '',
rawQuery: rawQuery,
forceAll: forceAll,
combo: me,
cancel: false
});
if (queryPlan === false || queryPlan.cancel) {
return false;
}
if (me.queryCaching && queryPlan.query === me.lastQuery) {
me.expand();
if (me.queryMode === 'local') {
me.doAutoSelect();
}
}
else {
me.lastQuery = queryPlan.query;
if (me.queryMode === 'local') {
me.doLocalQuery(queryPlan);
} else {
me.doRemoteQuery(queryPlan);
}
}
return true;
},
beforeQuery: function(queryPlan) {
var me = this;
if (me.fireEvent('beforequery', queryPlan) === false) {
queryPlan.cancel = true;
}
else if (!queryPlan.cancel) {
if (queryPlan.query.length < me.minChars && !queryPlan.forceAll) {
queryPlan.cancel = true;
}
}
return queryPlan;
},
doLocalQuery: function(queryPlan) {
var me = this,
queryString = queryPlan.query;
if (!me.queryFilter) {
me.queryFilter = new Ext.util.Filter({
id: me.id + '-query-filter',
anyMatch: me.anyMatch,
caseSensitive: me.caseSensitive,
root: 'data',
property: me.displayField
});
me.store.addFilter(me.queryFilter, false);
}
if (queryString || !queryPlan.forceAll) {
me.queryFilter.disabled = false;
me.queryFilter.setValue(me.enableRegEx ? new RegExp(queryString) : queryString);
}
else {
me.queryFilter.disabled = true;
}
me.store.filter();
if (me.store.getCount()) {
me.expand();
} else {
me.collapse();
}
me.afterQuery(queryPlan);
},
doRemoteQuery: function(queryPlan) {
var me = this,
loadCallback = function() {
me.afterQuery(queryPlan);
};
me.expand();
if (me.pageSize) {
me.loadPage(1, {
rawQuery: queryPlan.rawQuery,
callback: loadCallback
});
} else {
me.store.load({
params: me.getParams(queryPlan.query),
rawQuery: queryPlan.rawQuery,
callback: loadCallback
});
}
},
afterQuery: function(queryPlan) {
var me = this;
if (me.store.getCount()) {
if (me.typeAhead) {
me.doTypeAhead();
}
if (me.getRawValue() !== me.getDisplayValue()) {
me.ignoreSelection++;
me.picker.getSelectionModel().deselectAll();
me.ignoreSelection--;
}
if (queryPlan.rawQuery) {
me.syncSelection();
if (me.picker && !me.picker.getSelectionModel().hasSelection()) {
me.doAutoSelect();
}
} else {
me.doAutoSelect();
}
}
},
loadPage: function(pageNum, options) {
this.store.loadPage(pageNum, Ext.apply({
params: this.getParams(this.lastQuery)
}, options));
},
onPageChange: function(toolbar, newPage){
this.loadPage(newPage);
return false;
},
getParams: function(queryString) {
var params = {},
param = this.queryParam;
if (param) {
params[param] = queryString;
}
return params;
},
doAutoSelect: function() {
var me = this,
picker = me.picker,
lastSelected, itemNode;
if (picker && me.autoSelect && me.store.getCount() > 0) {
lastSelected = picker.getSelectionModel().lastSelected;
itemNode = picker.getNode(lastSelected || 0);
if (itemNode) {
picker.highlightItem(itemNode);
picker.listEl.scrollChildIntoView(itemNode, false);
}
}
},
doTypeAhead: function() {
var me = this;
if (!me.typeAheadTask) {
me.typeAheadTask = new Ext.util.DelayedTask(me.onTypeAhead, me);
}
if (me.lastKey != Ext.EventObject.BACKSPACE && me.lastKey != Ext.EventObject.DELETE) {
me.typeAheadTask.delay(me.typeAheadDelay);
}
},
onTriggerClick: function() {
var me = this;
me.duringTriggerClick = true;
if (!me.readOnly && !me.disabled) {
if (me.isExpanded) {
me.collapse();
} else {
me.onFocus({});
if (me.triggerAction === 'all') {
me.doQuery(me.allQuery, true);
} else if (me.triggerAction === 'last') {
me.doQuery(me.lastQuery, true);
} else {
me.doQuery(me.getRawValue(), false, true);
}
}
me.inputEl.focus();
}
delete me.duringTriggerClick;
},
onPaste: function(){
var me = this;
if (!me.readOnly && !me.disabled && me.editable) {
me.doQueryTask.delay(me.queryDelay);
}
},
onKeyUp: function(e, t) {
var me = this,
key = e.getKey();
if (!me.readOnly && !me.disabled && me.editable) {
me.lastKey = key;
if (!e.isSpecialKey() || key == e.BACKSPACE || key == e.DELETE) {
me.doQueryTask.delay(me.queryDelay);
}
}
if (me.enableKeyEvents) {
me.callParent(arguments);
}
},
initEvents: function() {
var me = this;
me.callParent();
if (!me.enableKeyEvents) {
me.mon(me.inputEl, 'keyup', me.onKeyUp, me);
}
me.mon(me.inputEl, 'paste', me.onPaste, me);
},
onDestroy: function() {
var me = this
if (me.typeAheadTask) {
me.typeAheadTask.cancel();
me.typeAheadTask = null;
}
Ext.destroy(me.listKeyNav);
me.bindStore(null);
me.callParent();
},
onAdded: function() {
var me = this;
me.callParent(arguments);
if (me.picker) {
me.picker.ownerCt = me.up('[floating]');
me.picker.registerWithOwnerCt();
}
},
createPicker: function() {
var me = this,
picker,
pickerCfg = Ext.apply({
xtype: 'boundlist',
pickerField: me,
selModel: {
mode: me.multiSelect ? 'SIMPLE' : 'SINGLE'
},
floating: true,
hidden: true,
store: me.store,
displayField: me.displayField,
focusOnToFront: false,
pageSize: me.pageSize,
tpl: me.tpl
}, me.listConfig, me.defaultListConfig);
picker = me.picker = Ext.widget(pickerCfg);
if (me.pageSize) {
picker.pagingToolbar.on('beforechange', me.onPageChange, me);
}
me.mon(picker, {
itemclick: me.onItemClick,
refresh: me.onListRefresh,
scope: me
});
me.mon(picker.getSelectionModel(), {
beforeselect: me.onBeforeSelect,
beforedeselect: me.onBeforeDeselect,
selectionchange: me.onListSelectionChange,
scope: me
});
return picker;
},
alignPicker: function(){
var me = this,
picker = me.getPicker(),
heightAbove = me.getPosition()[1] - Ext.getBody().getScroll().top,
heightBelow = Ext.Element.getViewHeight() - heightAbove - me.getHeight(),
space = Math.max(heightAbove, heightBelow);
if (picker.height) {
delete picker.height;
picker.updateLayout();
}
if (picker.getHeight() > space - 5) {
picker.setHeight(space - 5); 
}
me.callParent();
},
onListRefresh: function() {
if (!this.expanding) {
this.alignPicker();
}
this.syncSelection();
},
onItemClick: function(picker, record){
var me = this,
selection = me.picker.getSelectionModel().getSelection(),
valueField = me.valueField;
if (!me.multiSelect && selection.length) {
if (record.get(valueField) === selection[0].get(valueField)) {
me.displayTplData = [record.data];
me.setRawValue(me.getDisplayValue());
me.collapse();
}
}
},
onBeforeSelect: function(list, record) {
return this.fireEvent('beforeselect', this, record, record.index);
},
onBeforeDeselect: function(list, record) {
return this.fireEvent('beforedeselect', this, record, record.index);
},
onListSelectionChange: function(list, selectedRecords) {
var me = this,
isMulti = me.multiSelect,
hasRecords = selectedRecords.length > 0;
if (!me.ignoreSelection && me.isExpanded) {
if (!isMulti) {
Ext.defer(me.collapse, 1, me);
}
if (isMulti || hasRecords) {
me.setValue(selectedRecords, false);
}
if (hasRecords) {
me.fireEvent('select', me, selectedRecords);
}
me.inputEl.focus();
}
},
onExpand: function() {
var me = this,
keyNav = me.listKeyNav,
selectOnTab = me.selectOnTab,
picker = me.getPicker();
if (keyNav) {
keyNav.enable();
} else {
keyNav = me.listKeyNav = new Ext.view.BoundListKeyNav(me.inputEl, {
boundList: picker,
forceKeyDown: true,
tab: function(e) {
if (selectOnTab) {
this.selectHighlighted(e);
me.triggerBlur();
}
return true;
},
enter: function(e){
var selModel = picker.getSelectionModel(),
count = selModel.getCount();
this.selectHighlighted(e);
if (!me.multiSelect && count === selModel.getCount()) {
me.collapse();
}
}
});
}
if (selectOnTab) {
me.ignoreMonitorTab = true;
}
Ext.defer(keyNav.enable, 1, keyNav); 
me.inputEl.focus();
},
onCollapse: function() {
var me = this,
keyNav = me.listKeyNav;
if (keyNav) {
keyNav.disable();
me.ignoreMonitorTab = false;
}
},
select: function(r,  assert) {
var me = this,
picker = me.picker,
fireSelect;
if (r && r.isModel && assert === true && picker) {
fireSelect = !picker.getSelectionModel().isSelected(r);
}
me.setValue(r, true);
if (fireSelect) {
me.fireEvent('select', me, r);
}
},
findRecord: function(field, value) {
var ds = this.store,
idx = ds.findExact(field, value);
return idx !== -1 ? ds.getAt(idx) : false;
},
findRecordByValue: function(value) {
return this.findRecord(this.valueField, value);
},
findRecordByDisplay: function(value) {
return this.findRecord(this.displayField, value);
},
setValue: function(value, doSelect) {
var me = this,
valueNotFoundText = me.valueNotFoundText,
inputEl = me.inputEl,
i, len, record,
dataObj,
matchedRecords = [],
displayTplData = [],
processedValue = [];
if (me.store.loading) {
me.value = value;
me.setHiddenValue(me.value);
return me;
}
value = Ext.Array.from(value);
for (i = 0, len = value.length; i < len; i++) {
record = value[i];
if (!record || !record.isModel) {
record = me.findRecordByValue(record);
}
if (record) {
matchedRecords.push(record);
displayTplData.push(record.data);
processedValue.push(record.get(me.valueField));
}
else {
if (!me.forceSelection) {
processedValue.push(value[i]);
dataObj = {};
dataObj[me.displayField] = value[i];
displayTplData.push(dataObj);
}
else if (Ext.isDefined(valueNotFoundText)) {
displayTplData.push(valueNotFoundText);
}
}
}
me.setHiddenValue(processedValue);
me.value = me.multiSelect ? processedValue : processedValue[0];
if (!Ext.isDefined(me.value)) {
me.value = null;
}
me.displayTplData = displayTplData; 
me.lastSelection = me.valueModels = matchedRecords;
if (inputEl && me.emptyText && !Ext.isEmpty(value)) {
inputEl.removeCls(me.emptyCls);
}
me.setRawValue(me.getDisplayValue());
me.checkChange();
if (doSelect !== false) {
me.syncSelection();
}
me.applyEmptyText();
return me;
},
setHiddenValue: function(values){
var me = this,
name = me.hiddenName, 
i,
dom, childNodes, input, valueCount, childrenCount;
if (!me.hiddenDataEl || !name) {
return;
}
values = Ext.Array.from(values);
dom = me.hiddenDataEl.dom;
childNodes = dom.childNodes;
input = childNodes[0];
valueCount = values.length;
childrenCount = childNodes.length;
if (!input && valueCount > 0) {
me.hiddenDataEl.update(Ext.DomHelper.markup({
tag: 'input', 
type: 'hidden', 
name: name
}));
childrenCount = 1;
input = dom.firstChild;
}
while (childrenCount > valueCount) {
dom.removeChild(childNodes[0]);
-- childrenCount;
}
while (childrenCount < valueCount) {
dom.appendChild(input.cloneNode(true));
++ childrenCount;
}
for (i = 0; i < valueCount; i++) {
childNodes[i].value = values[i];
}
},
getDisplayValue: function() {
return this.displayTpl.apply(this.displayTplData);
},
getValue: function() {
var me = this,
picker = me.picker,
rawValue = me.getRawValue(), 
value = me.value; 
if (me.getDisplayValue() !== rawValue) {
value = rawValue;
me.value = me.displayTplData = me.valueModels = null;
if (picker) {
me.ignoreSelection++;
picker.getSelectionModel().deselectAll();
me.ignoreSelection--;
}
}
return value;
},
getSubmitValue: function() {
var value = this.getValue();
if (Ext.isEmpty(value)) {
value = '';
}
return value;
},
isEqual: function(v1, v2) {
var fromArray = Ext.Array.from,
i, len;
v1 = fromArray(v1);
v2 = fromArray(v2);
len = v1.length;
if (len !== v2.length) {
return false;
}
for(i = 0; i < len; i++) {
if (v2[i] !== v1[i]) {
return false;
}
}
return true;
},
clearValue: function() {
this.setValue([]);
},
syncSelection: function() {
var me = this,
picker = me.picker,
selection, selModel,
values = me.valueModels || [],
vLen  = values.length, v, value;
if (picker) {
selection = [];
for (v = 0; v < vLen; v++) {
value = values[v];
if (value && value.isModel && me.store.indexOf(value) >= 0) {
selection.push(value);
}
}
me.ignoreSelection++;
selModel = picker.getSelectionModel();
selModel.deselectAll();
if (selection.length) {
selModel.select(selection, undefined, true);
}
me.ignoreSelection--;
}
},
onEditorTab: function(e){
var keyNav = this.listKeyNav;
if (this.selectOnTab && keyNav) {
keyNav.selectHighlighted(e);
}
}
});
Ext.define('Ext.layout.container.Fit', {
extend:  Ext.layout.container.Container ,
alternateClassName: 'Ext.layout.FitLayout',
alias: 'layout.fit',
itemCls: Ext.baseCSSPrefix + 'fit-item',
targetCls: Ext.baseCSSPrefix + 'layout-fit',
type: 'fit',
defaultMargins: {
top: 0,
right: 0,
bottom: 0,
left: 0
},
manageMargins: true,
sizePolicies: {
0: { readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0 },
1: { readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0 },
2: { readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1 },
3: { readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1 }
},
getItemSizePolicy: function (item, ownerSizeModel) {
var sizeModel = ownerSizeModel || this.owner.getSizeModel(),
mode = (sizeModel.width.shrinkWrap ? 0 : 1) |
(sizeModel.height.shrinkWrap ? 0 : 2);
return this.sizePolicies[mode];
},
beginLayoutCycle: function (ownerContext, firstCycle) {
var me = this,
resetHeight = me.lastHeightModel && me.lastHeightModel.calculated,
resetWidth = me.lastWidthModel && me.lastWidthModel.calculated,
resetSizes = resetWidth || resetHeight,
maxChildMinHeight = 0, maxChildMinWidth = 0,
c, childItems, i, item, length, margins, minHeight, minWidth, style, undef;
me.callParent(arguments);
if (resetSizes && ownerContext.targetContext.el.dom.tagName.toUpperCase() != 'TD') {
resetSizes = resetWidth = resetHeight = false;
}
childItems = ownerContext.childItems;
length = childItems.length;
for (i = 0; i < length; ++i) {
item = childItems[i];
if (firstCycle) {
c = item.target;
minHeight = c.minHeight;
minWidth = c.minWidth;
if (minWidth || minHeight) {
margins = item.marginInfo || item.getMarginInfo();
minHeight += margins.height;
minWidth += margins.height;
if (maxChildMinHeight < minHeight) {
maxChildMinHeight = minHeight;
}
if (maxChildMinWidth < minWidth) {
maxChildMinWidth = minWidth;
}
}
}
if (resetSizes) {
style = item.el.dom.style;
if (resetHeight) {
style.height = '';
}
if (resetWidth) {
style.width = '';
}
}
}
if (firstCycle) {
ownerContext.maxChildMinHeight = maxChildMinHeight;
ownerContext.maxChildMinWidth = maxChildMinWidth;
}
c = ownerContext.target;
ownerContext.overflowX = (!ownerContext.widthModel.shrinkWrap && 
ownerContext.maxChildMinWidth &&
c.scrollFlags.x) || undef;
ownerContext.overflowY = (!ownerContext.heightModel.shrinkWrap &&
ownerContext.maxChildMinHeight &&
c.scrollFlags.y) || undef;
},
calculate : function (ownerContext) {
var me = this,
childItems = ownerContext.childItems,
length = childItems.length,
containerSize = me.getContainerSize(ownerContext),
info = {
length: length,
ownerContext: ownerContext,
targetSize: containerSize
},
shrinkWrapWidth = ownerContext.widthModel.shrinkWrap,
shrinkWrapHeight = ownerContext.heightModel.shrinkWrap,
overflowX = ownerContext.overflowX,
overflowY = ownerContext.overflowY,
scrollbars, scrollbarSize, padding, i, contentWidth, contentHeight;
if (overflowX || overflowY) {
scrollbars = me.getScrollbarsNeeded(
overflowX && containerSize.width, overflowY && containerSize.height,
ownerContext.maxChildMinWidth, ownerContext.maxChildMinHeight);
if (scrollbars) {
scrollbarSize = Ext.getScrollbarSize();
if (scrollbars & 1) { // if we need the hscrollbar, remove its height
containerSize.height -= scrollbarSize.height;
}
if (scrollbars & 2) { // if we need the vscrollbar, remove its width
containerSize.width -= scrollbarSize.width;
}
}
}
for (i = 0; i < length; ++i) {
info.index = i;
me.fitItem(childItems[i], info);
}
if (shrinkWrapHeight || shrinkWrapWidth) {
padding = ownerContext.targetContext.getPaddingInfo();
if (shrinkWrapWidth) {
if (overflowY && !containerSize.gotHeight) {
me.done = false;
} else {
contentWidth = info.contentWidth + padding.width;
if (scrollbars & 2) { // if we need the vscrollbar, add its width
contentWidth += scrollbarSize.width;
}
if (!ownerContext.setContentWidth(contentWidth)) {
me.done = false;
}
}
}
if (shrinkWrapHeight) {
if (overflowX && !containerSize.gotWidth) {
me.done = false;
} else {
contentHeight = info.contentHeight + padding.height;
if (scrollbars & 1) { // if we need the hscrollbar, add its height
contentHeight += scrollbarSize.height;
}
if (!ownerContext.setContentHeight(contentHeight)) {
me.done = false;
}
}
}
}
},
fitItem: function (itemContext, info) {
var me = this;
if (itemContext.invalid) {
me.done = false;
return;
}
info.margins = itemContext.getMarginInfo();
info.needed = info.got = 0;
me.fitItemWidth(itemContext, info);
me.fitItemHeight(itemContext, info);
if (info.got != info.needed) {
me.done = false;
}
},
fitItemWidth: function (itemContext, info) {
var contentWidth, width;
if (info.ownerContext.widthModel.shrinkWrap) {
width = itemContext.getProp('width') + info.margins.width;
contentWidth = info.contentWidth;
if (contentWidth === undefined) {
info.contentWidth = width;
} else {
info.contentWidth = Math.max(contentWidth, width);
}
} else if (itemContext.widthModel.calculated) {
++info.needed;
if (info.targetSize.gotWidth) {
++info.got;
this.setItemWidth(itemContext, info);
}
}
this.positionItemX(itemContext, info);
},
fitItemHeight: function (itemContext, info) {
var contentHeight, height;
if (info.ownerContext.heightModel.shrinkWrap) {
height = itemContext.getProp('height') + info.margins.height;
contentHeight = info.contentHeight;
if (contentHeight === undefined) {
info.contentHeight = height;
} else {
info.contentHeight = Math.max(contentHeight, height);
}
} else if (itemContext.heightModel.calculated) {
++info.needed;
if (info.targetSize.gotHeight) {
++info.got;
this.setItemHeight(itemContext, info);
}
}
this.positionItemY(itemContext, info);
},
positionItemX: function (itemContext, info) {
var margins = info.margins;
if (info.index || margins.left) {
itemContext.setProp('x', margins.left);
}
if (margins.width) {
itemContext.setProp('margin-right', margins.width);
}
},
positionItemY: function (itemContext, info) {
var margins = info.margins;
if (info.index || margins.top) {
itemContext.setProp('y', margins.top);
}
if (margins.height) {
itemContext.setProp('margin-bottom', margins.height);
}
},
setItemHeight: function (itemContext, info) {
itemContext.setHeight(info.targetSize.height - info.margins.height);
},
setItemWidth: function (itemContext, info) {
itemContext.setWidth(info.targetSize.width - info.margins.width);
}
});
Ext.define('Ext.view.NodeCache', {
constructor: function(view) {
this.view = view;
this.clear();
this.el = new Ext.dom.AbstractElement.Fly();
},
clear: function(removeDom) {
var me = this,
elements = this.elements,
i, el;
if (removeDom) {
for (i in elements) {
el = elements[i];
el.parentNode.removeChild(el);
}
}
me.elements = {};
me.count = me.startIndex = 0;
me.endIndex = -1;
},
fill: function(newElements, startIndex) {
var me = this,
elements = me.elements = {},
i,
len = newElements.length;
if (!startIndex) {
startIndex = 0;
}
for (i = 0; i < len; i++) {
elements[startIndex + i] = newElements[i];
}
me.startIndex = startIndex;
me.endIndex = startIndex + len - 1;
me.count = len;
return this;
},
insert: function(insertPoint, nodes) {
var me = this,
elements = me.elements,
i,
nodeCount = nodes.length;
if (me.count) {
if (insertPoint < me.count) {
for (i = me.endIndex + nodeCount; i >= insertPoint + nodeCount; i--) {
elements[i] = elements[i - nodeCount];
elements[i].setAttribute('data-recordIndex', i);
}
}
me.endIndex = me.endIndex + nodeCount;
}
else {
me.startIndex = insertPoint;
me.endIndex = insertPoint + nodeCount - 1;
}
for (i = 0; i < nodeCount; i++, insertPoint++) {
elements[insertPoint] = nodes[i];
elements[insertPoint].setAttribute('data-recordIndex', insertPoint);
}
me.count += nodeCount;
},
item: function(index, asDom) {
var el = this.elements[index],
result = null;
if (el) {
result = asDom ? this.elements[index] : this.el.attach(this.elements[index]);
}
return result;
},
first: function(asDom) {
return this.item(this.startIndex, asDom);
},
last: function(asDom) {
return this.item(this.endIndex, asDom);
},
getCount : function() {
return this.count;
},
slice: function(start, end) {
var elements = this.elements,
result = [],
i;
if (arguments.length < 2) {
end = this.endIndex;
} else {
end = Math.min(this.endIndex, end - 1);
}
for (i = start||this.startIndex; i <= end; i++) {
result.push(elements[i]);
}
return result;
},
replaceElement: function(el, replacement, domReplace) {
var elements = this.elements,
index = (typeof el === 'number') ? el : this.indexOf(el);
if (index > -1) {
replacement = Ext.getDom(replacement);
if (domReplace) {
el = elements[index];
el.parentNode.insertBefore(replacement, el);
Ext.removeNode(el);
replacement.setAttribute('data-recordIndex', index);
}
this.elements[index] = replacement;
}
return this;
},
indexOf: function(el) {
var elements = this.elements,
index;
el = Ext.getDom(el);
for (index = this.startIndex; index <= this.endIndex; index++) {
if (elements[index] === el) {
return index;
}
}
return -1;
},
removeRange: function(start, end, removeDom) {
var me = this,
elements = me.elements,
el,
i, removeCount, fromPos;
if (end === undefined) {
end = me.count;
} else {
end = Math.min(me.endIndex + 1, end + 1);
}
if (!start) {
start = 0;
}
removeCount = end - start;
for (i = start, fromPos = end; i < me.endIndex; i++, fromPos++) {
if (removeDom && i < end) {
Ext.removeNode(elements[i]);
}
if (fromPos <= me.endIndex) {
el = elements[i] = elements[fromPos];
el.setAttribute('data-recordIndex', i);
}
else {
delete elements[i];
}
}
me.count -= removeCount;
me.endIndex -= removeCount;
},
removeElement: function(keys, removeDom) {
var me = this,
inKeys,
key,
elements = me.elements,
el,
deleteCount,
keyIndex = 0, index,
fromIndex;
if (Ext.isArray(keys)) {
inKeys = keys;
keys = [];
deleteCount = inKeys.length;
for (keyIndex = 0; keyIndex < deleteCount; keyIndex++) {
key = inKeys[keyIndex];
if (typeof key !== 'number') {
key = me.indexOf(key);
}
if (key >= me.startIndex && key <= me.endIndex) {
keys[keys.length] = key;
}
}
Ext.Array.sort(keys);
deleteCount = keys.length;
} else {
if (keys < me.startIndex || keys > me.endIndex) {
return;
}
deleteCount = 1;
keys = [keys];
}
for (index = fromIndex = keys[0], keyIndex = 0; index <= me.endIndex; index++, fromIndex++) {
if (keyIndex < deleteCount && index === keys[keyIndex]) {
fromIndex++;
keyIndex++;
if (removeDom) {
Ext.removeNode(elements[index]);
}
}
if (fromIndex <= me.endIndex && fromIndex >= me.startIndex) {
el = elements[index] = elements[fromIndex];
el.setAttribute('data-recordIndex', index);
} else {
delete elements[index];
}
}
me.endIndex -= deleteCount;
me.count -= deleteCount;
},
scroll: function(newRecords, direction, removeCount) {
var me = this,
elements = me.elements,
recCount = newRecords.length,
i, el, removeEnd,
newNodes,
nodeContainer = me.view.getNodeContainer(),
frag = document.createDocumentFragment();
if (direction == -1) {
for (i = (me.endIndex - removeCount) + 1; i <= me.endIndex; i++) {
el = elements[i];
delete elements[i];
el.parentNode.removeChild(el);
}
me.endIndex -= removeCount;
newNodes = me.view.bufferRender(newRecords, me.startIndex -= recCount);
for (i = 0; i < recCount; i++) {
elements[me.startIndex + i] = newNodes[i];
frag.appendChild(newNodes[i]);
}
nodeContainer.insertBefore(frag, nodeContainer.firstChild);
}
else {
removeEnd = me.startIndex + removeCount;
for (i = me.startIndex; i < removeEnd; i++) {
el = elements[i];
delete elements[i];
el.parentNode.removeChild(el);
}
me.startIndex = i;
newNodes = me.view.bufferRender(newRecords, me.endIndex + 1);
for (i = 0; i < recCount; i++) {
elements[me.endIndex += 1] = newNodes[i];
frag.appendChild(newNodes[i]);
}
nodeContainer.appendChild(frag);
}
me.count = me.endIndex - me.startIndex + 1;
}
});
Ext.define('Ext.view.DropZone', {
extend:  Ext.dd.DropZone ,
indicatorCls: Ext.baseCSSPrefix + 'grid-drop-indicator',
indicatorHtml: [
'<div class="', Ext.baseCSSPrefix, 'grid-drop-indicator-left" role="presentation"></div>',
'<div class="' + Ext.baseCSSPrefix + 'grid-drop-indicator-right" role="presentation"></div>'
].join(''),
constructor: function(config) {
var me = this;
Ext.apply(me, config);
if (!me.ddGroup) {
me.ddGroup = 'view-dd-zone-' + me.view.id;
}
me.callParent([me.view.el]);
},
fireViewEvent: function() {
var me = this,
result;
me.lock();
result = me.view.fireEvent.apply(me.view, arguments);
me.unlock();
return result;
},
getTargetFromEvent : function(e) {
var node = e.getTarget(this.view.getItemSelector()),
mouseY, nodeList, testNode, i, len, box;
if (!node) {
mouseY = e.getPageY();
for (i = 0, nodeList = this.view.getNodes(), len = nodeList.length; i < len; i++) {
testNode = nodeList[i];
box = Ext.fly(testNode).getBox();
if (mouseY <= box.bottom) {
return testNode;
}
}
}
return node;
},
getIndicator: function() {
var me = this;
if (!me.indicator) {
me.indicator = new Ext.Component({
ariaRole: 'presentation',
html: me.indicatorHtml,
cls: me.indicatorCls,
ownerCt: me.view,
floating: true,
shadow: false
});
}
return me.indicator;
},
getPosition: function(e, node) {
var y      = e.getXY()[1],
region = Ext.fly(node).getRegion(),
pos;
if ((region.bottom - y) >= (region.bottom - region.top) / 2) {
pos = "before";
} else {
pos = "after";
}
return pos;
},
containsRecordAtOffset: function(records, record, offset) {
if (!record) {
return false;
}
var view = this.view,
recordIndex = view.indexOf(record),
nodeBefore = view.getNode(recordIndex + offset, true),
recordBefore = nodeBefore ? view.getRecord(nodeBefore) : null;
return recordBefore && Ext.Array.contains(records, recordBefore);
},
positionIndicator: function(node, data, e) {
var me = this,
view = me.view,
pos = me.getPosition(e, node),
overRecord = view.getRecord(node),
draggingRecords = data.records,
indicatorY;
if (!Ext.Array.contains(draggingRecords, overRecord) && (
pos == 'before' && !me.containsRecordAtOffset(draggingRecords, overRecord, -1) ||
pos == 'after' && !me.containsRecordAtOffset(draggingRecords, overRecord, 1)
)) {
me.valid = true;
if (me.overRecord != overRecord || me.currentPosition != pos) {
indicatorY = Ext.fly(node).getY() - view.el.getY() - 1;
if (pos == 'after') {
indicatorY += Ext.fly(node).getHeight();
}
me.getIndicator().setWidth(Ext.fly(view.el).getWidth()).showAt(0, indicatorY);
me.overRecord = overRecord;
me.currentPosition = pos;
}
} else {
me.invalidateDrop();
}
},
invalidateDrop: function() {
if (this.valid) {
this.valid = false;
this.getIndicator().hide();
}
},
onNodeOver: function(node, dragZone, e, data) {
var me = this;
if (!Ext.Array.contains(data.records, me.view.getRecord(node))) {
me.positionIndicator(node, data, e);
}
return me.valid ? me.dropAllowed : me.dropNotAllowed;
},
notifyOut: function(node, dragZone, e, data) {
var me = this;
me.callParent(arguments);
me.overRecord = me.currentPosition = null
me.valid = false;
if (me.indicator) {
me.indicator.hide();
}
},
onContainerOver : function(dd, e, data) {
var me = this,
view = me.view,
count = view.dataSource.getCount();
if (count) {
me.positionIndicator(view.all.last(), data, e);
}
else {
me.overRecord = me.currentPosition = null;
me.getIndicator().setWidth(Ext.fly(view.el).getWidth()).showAt(0, 0);
me.valid = true;
}
return me.dropAllowed;
},
onContainerDrop : function(dd, e, data) {
return this.onNodeDrop(dd, null, e, data);
},
onNodeDrop: function(targetNode, dragZone, e, data) {
var me = this,
dropHandled = false,
dropHandlers = {
wait: false,
processDrop: function () {
me.invalidateDrop();
me.handleNodeDrop(data, me.overRecord, me.currentPosition);
dropHandled = true;
me.fireViewEvent('drop', targetNode, data, me.overRecord, me.currentPosition);
},
cancelDrop: function() {
me.invalidateDrop();
dropHandled = true;
}
},
performOperation = false;
if (me.valid) {
performOperation = me.fireViewEvent('beforedrop', targetNode, data, me.overRecord, me.currentPosition, dropHandlers);
if (dropHandlers.wait) {
return;
}
if (performOperation !== false) {
if (!dropHandled) {
dropHandlers.processDrop();
}
}
}
return performOperation;
},
destroy: function(){
Ext.destroy(this.indicator);
delete this.indicator;
this.callParent();
}
});
Ext.define('Ext.layout.ClassList', (function () {
var splitWords = Ext.String.splitWords,
toMap = Ext.Array.toMap;
return {
dirty: false,
constructor: function (owner) {
this.owner = owner;
this.map = toMap(this.classes = splitWords(owner.el.className));
},
add: function (cls) {
var me = this;
if (!me.map[cls]) {
me.map[cls] = true;
me.classes.push(cls);
if (!me.dirty) {
me.dirty = true;
me.owner.markDirty();
}
}
},
addMany: function (classes) {
Ext.each(splitWords(classes), this.add, this);
},
contains: function (cls) {
return this.map[cls];
},
flush: function () {
this.owner.el.className = this.classes.join(' ');
this.dirty = false;
},
remove: function (cls) {
var me = this;
if (me.map[cls]) {
delete me.map[cls];
me.classes = Ext.Array.filter(me.classes, function (c) {
return c != cls;
});
if (!me.dirty) {
me.dirty = true;
me.owner.markDirty();
}
}
},
removeMany: function (classes) {
var me = this,
remove = toMap(splitWords(classes));
me.classes = Ext.Array.filter(me.classes, function (c) {
if (!remove[c]) {
return true;
}
delete me.map[c];
if (!me.dirty) {
me.dirty = true;
me.owner.markDirty();
}
return false;
});
}
};
}()));
Ext.define('Ext.util.Queue', {
constructor: function() {
this.clear();
},
add : function(obj) {
var me = this,
key = me.getKey(obj);
if (!me.map[key]) {
++me.length;
me.items.push(obj);
me.map[key] = obj;
}
return obj;
},
clear : function(){
var me = this,
items = me.items;
me.items = [];
me.map = {};
me.length = 0;
return items;
},
contains: function (obj) {
var key = this.getKey(obj);
return this.map.hasOwnProperty(key);
},
getCount : function(){
return this.length;
},
getKey : function(obj){
return obj.id;
},
remove : function(obj){
var me = this,
key = me.getKey(obj),
items = me.items,
index;
if (me.map[key]) {
index = Ext.Array.indexOf(items, obj);
Ext.Array.erase(items, index, 1);
delete me.map[key];
--me.length;
}
return obj;
}
});
Ext.define('Ext.layout.ContextItem', {
heightModel: null,
widthModel: null,
sizeModel: null,
optOut: false,
ownerSizePolicy: null, 
boxChildren: null,
boxParent: null,
isBorderBoxValue: null,
children: [],
dirty: null,
dirtyCount: 0,
hasRawContent: true,
isContextItem: true,
isTopLevel: false,
consumersContentHeight: 0,
consumersContentWidth: 0,
consumersContainerHeight: 0,
consumersContainerWidth: 0,
consumersHeight: 0,
consumersWidth: 0,
ownerCtContext: null,
remainingChildDimensions: 0,
props: null,
state: null,
wrapsComponent: false,
constructor: function (config) {
var me = this,
sizeModels = Ext.layout.SizeModel.sizeModels,
configured = sizeModels.configured,
shrinkWrap = sizeModels.shrinkWrap,
el, lastBox, ownerCt, ownerCtContext, props, sizeModel, target,
lastWidth, lastHeight, sameWidth, sameHeight, widthModel, heightModel, optOut;
Ext.apply(me, config);
el = me.el;
me.id = el.id;
me.flushedProps = {};
me.props = props = {};
me.styles = {};
target = me.target;
if (!target.isComponent) {
lastBox = el.lastBox;
} else {
me.wrapsComponent = true;
me.framing = target.frameSize || null;
me.isComponentChild = target.ownerLayout && target.ownerLayout.isComponentLayout;
lastBox = target.lastBox;
ownerCt = target.ownerCt;
if (ownerCt && (ownerCtContext = ownerCt.el && me.context.items[ownerCt.el.id])) {
me.ownerCtContext = ownerCtContext;
}
me.sizeModel = sizeModel = target.getSizeModel(ownerCtContext &&
ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
me.widthModel = widthModel = sizeModel.width;
me.heightModel = heightModel = sizeModel.height;
if (lastBox && lastBox.invalid === false) {
sameWidth = (target.width === (lastWidth = lastBox.width));
sameHeight = (target.height === (lastHeight = lastBox.height));
if (widthModel === shrinkWrap && heightModel === shrinkWrap) {
optOut = true;
} else if (widthModel === configured && sameWidth) {
optOut = heightModel === shrinkWrap ||
(heightModel === configured && sameHeight);
}
if (optOut) {
me.optOut = true;
props.width = lastWidth;
props.height = lastHeight;
}
}
}
me.lastBox = lastBox;
},
init: function (full, options) {
var me = this,
oldProps = me.props,
oldDirty = me.dirty,
ownerCtContext = me.ownerCtContext,
ownerLayout = me.target.ownerLayout,
firstTime = !me.state,
ret = full || firstTime,
children, i, n, ownerCt, sizeModel, target,
oldHeightModel = me.heightModel,
oldWidthModel = me.widthModel,
newHeightModel, newWidthModel,
remainingCount = 0;
me.dirty = me.invalid = false;
me.props = {};
me.remainingChildDimensions = 0;
if (me.boxChildren) {
me.boxChildren.length = 0; 
}
if (!firstTime) {
me.clearAllBlocks('blocks');
me.clearAllBlocks('domBlocks');
}
if (!me.wrapsComponent) {
return ret;
}
target = me.target;
me.state = {}; 
if (firstTime) {
if (target.beforeLayout && target.beforeLayout !== Ext.emptyFn) {
target.beforeLayout();
}
if (!ownerCtContext && (ownerCt = target.ownerCt)) {
ownerCtContext = me.context.items[ownerCt.el.id];
}
if (ownerCtContext) {
me.ownerCtContext = ownerCtContext;
me.isBoxParent = target.ownerLayout.isItemBoxParent(me);
} else {
me.isTopLevel = true; 
}
me.frameBodyContext = me.getEl('frameBody');
} else {
ownerCtContext = me.ownerCtContext;
me.isTopLevel = !ownerCtContext;
children = me.children;
for (i = 0, n = children.length; i < n; ++i) {
children[i].init(true);
}
}
me.hasRawContent = !(target.isContainer && target.items.items.length > 0);
if (full) {
me.widthModel = me.heightModel = null;
sizeModel = target.getSizeModel(ownerCtContext && 
ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
if (firstTime) {
me.sizeModel = sizeModel;
}
me.widthModel = sizeModel.width;
me.heightModel = sizeModel.height;
if (ownerCtContext && !me.isComponentChild) {
ownerCtContext.remainingChildDimensions += 2;
}
} else if (oldProps) {
me.recoverProp('x', oldProps, oldDirty);
me.recoverProp('y', oldProps, oldDirty);
if (me.widthModel.calculated) {
me.recoverProp('width', oldProps, oldDirty);
} else if ('width' in oldProps) {
++remainingCount;
}
if (me.heightModel.calculated) {
me.recoverProp('height', oldProps, oldDirty);
} else if ('height' in oldProps) {
++remainingCount;
}
if (ownerCtContext && !me.isComponentChild) {
ownerCtContext.remainingChildDimensions += remainingCount;
}
}
if (oldProps && ownerLayout && ownerLayout.manageMargins) {
me.recoverProp('margin-top', oldProps, oldDirty);
me.recoverProp('margin-right', oldProps, oldDirty);
me.recoverProp('margin-bottom', oldProps, oldDirty);
me.recoverProp('margin-left', oldProps, oldDirty);
}
if (options) {
newHeightModel = options.heightModel;
newWidthModel = options.widthModel;
if (newWidthModel && newHeightModel && oldWidthModel && oldHeightModel) {
if (oldWidthModel.shrinkWrap && oldHeightModel.shrinkWrap) {
if (newWidthModel.constrainedMax && newHeightModel.constrainedMin) {
newHeightModel = null;
}
}
}
if (newWidthModel) {
me.widthModel = newWidthModel;
}
if (newHeightModel) {
me.heightModel = newHeightModel;
}
if (options.state) {
Ext.apply(me.state, options.state);
}
}
return ret;
},
initContinue: function (full) {
var me = this,
ownerCtContext = me.ownerCtContext,
comp = me.target,
widthModel = me.widthModel,
hierarchyState = comp.getHierarchyState(),
boxParent;
if (widthModel.fixed) { 
hierarchyState.inShrinkWrapTable = false;
} else {
delete hierarchyState.inShrinkWrapTable;
}
if (full) {
if (ownerCtContext && widthModel.shrinkWrap) {
boxParent = ownerCtContext.isBoxParent ? ownerCtContext : ownerCtContext.boxParent;
if (boxParent) {
boxParent.addBoxChild(me);
}
} else if (widthModel.natural) {
me.boxParent = ownerCtContext;
}
}
return full;
},
initDone: function(containerLayoutDone) {
var me = this,
props = me.props,
state = me.state;
if (me.remainingChildDimensions === 0) {
props.containerChildrenSizeDone = true;
}
if (containerLayoutDone) {
props.containerLayoutDone = true;
}
if (me.boxChildren && me.boxChildren.length && me.widthModel.shrinkWrap) {
me.el.setWidth(10000);
state.blocks = (state.blocks || 0) + 1;
}
},
initAnimation: function() {
var me = this,
target = me.target,
ownerCtContext = me.ownerCtContext;
if (ownerCtContext && ownerCtContext.isTopLevel) {
me.animatePolicy = target.ownerLayout.getAnimatePolicy(me);
} else if (!ownerCtContext && target.isCollapsingOrExpanding && target.animCollapse) {
me.animatePolicy = target.componentLayout.getAnimatePolicy(me);
}
if (me.animatePolicy) {
me.context.queueAnimation(me);
}
},
addCls: function(newCls) {
this.getClassList().addMany(newCls);
},
removeCls: function(removeCls) {
this.getClassList().removeMany(removeCls);
},
addBlock: function (name, layout, propName) {
var me = this,
collection = me[name] || (me[name] = {}),
blockedLayouts = collection[propName] || (collection[propName] = {});
if (!blockedLayouts[layout.id]) {
blockedLayouts[layout.id] = layout;
++layout.blockCount;
++me.context.blockCount;
}
},
addBoxChild: function (boxChildItem) {
var me = this,
children,
widthModel = boxChildItem.widthModel;
boxChildItem.boxParent = this;
boxChildItem.measuresBox = widthModel.shrinkWrap ? boxChildItem.hasRawContent : widthModel.natural;
if (boxChildItem.measuresBox) {
children = me.boxChildren;
if (children) {
children.push(boxChildItem);
} else {
me.boxChildren = [ boxChildItem ];
}
}
},
addPositionStyles: function(styles, props) {
var x = props.x,
y = props.y,
count = 0;
if (x !== undefined) {
styles.left = x + 'px';
++count;
}
if (y !== undefined) {
styles.top = y + 'px';
++count;
}
return count;
},
addTrigger: function (propName, inDom) {
var me = this,
name = inDom ? 'domTriggers' : 'triggers',
collection = me[name] || (me[name] = {}),
context = me.context,
layout = context.currentLayout,
triggers = collection[propName] || (collection[propName] = {});
if (!triggers[layout.id]) {
triggers[layout.id] = layout;
++layout.triggerCount;
triggers = context.triggers[inDom ? 'dom' : 'data'];
(triggers[layout.id] || (triggers[layout.id] = [])).push({
item: this,
prop: propName
});
if (me.props[propName] !== undefined) {
if (!inDom || !(me.dirty && (propName in me.dirty))) {
++layout.firedTriggers;
}
}
}
},
boxChildMeasured: function () {
var me = this,
state = me.state,
count = (state.boxesMeasured = (state.boxesMeasured || 0) + 1);
if (count == me.boxChildren.length) {
state.clearBoxWidth = 1;
++me.context.progressCount;
me.markDirty();
}
},
borderNames: [ 'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'],
marginNames: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ],
paddingNames: [ 'padding-top', 'padding-right', 'padding-bottom', 'padding-left' ],
trblNames: [ 'top', 'right', 'bottom', 'left' ],
cacheMissHandlers: {
borderInfo: function (me) {
var info = me.getStyles(me.borderNames, me.trblNames);
info.width = info.left + info.right;
info.height = info.top + info.bottom;
return info;
},
marginInfo: function (me) {
var info = me.getStyles(me.marginNames, me.trblNames);
info.width = info.left + info.right;
info.height = info.top + info.bottom;
return info;
},
paddingInfo: function (me) {
var item = me.frameBodyContext || me,
info = item.getStyles(me.paddingNames, me.trblNames);
info.width = info.left + info.right;
info.height = info.top + info.bottom;
return info;
}
},
checkCache: function (entry) {
return this.cacheMissHandlers[entry](this);
},
clearAllBlocks: function (name) {
var collection = this[name],
propName;
if (collection) {
for (propName in collection) {
this.clearBlocks(name, propName);
}
}
},
clearBlocks: function (name, propName) {
var collection = this[name],
blockedLayouts = collection && collection[propName],
context, layout, layoutId;
if (blockedLayouts) {
delete collection[propName];
context = this.context;
for (layoutId in blockedLayouts) {
layout = blockedLayouts[layoutId];
--context.blockCount;
if (! --layout.blockCount && !layout.pending && !layout.done) {
context.queueLayout(layout);
}
}
}
},
block: function (layout, propName) {
this.addBlock('blocks', layout, propName);
},
domBlock: function (layout, propName) {
this.addBlock('domBlocks', layout, propName);
},
fireTriggers: function (name, propName) {
var collection = this[name],
triggers = collection && collection[propName],
context = this.context,
layout, layoutId;
if (triggers) {
for (layoutId in triggers) {
layout = triggers[layoutId];
++layout.firedTriggers;
if (!layout.done && !layout.blockCount && !layout.pending) {
context.queueLayout(layout);
}
}
}
},
flush: function () {
var me = this,
dirty = me.dirty,
state = me.state,
targetEl = me.el;
me.dirtyCount = 0;
if (me.classList && me.classList.dirty) {
me.classList.flush();
}
if ('attributes' in me) {
targetEl.set(me.attributes);
delete me.attributes;
}
if ('innerHTML' in me) {
targetEl.innerHTML = me.innerHTML;
delete me.innerHTML;
}
if (state && state.clearBoxWidth) {
state.clearBoxWidth = 0;
me.el.setStyle('width', null);
if (! --state.blocks) {
me.context.queueItemLayouts(me);
}
}
if (dirty) {
delete me.dirty;
me.writeProps(dirty, true);
}
},
flushAnimations: function() {
var me = this,
animateFrom = me.previousSize,
target, targetAnim, duration, animateProps, anim,
changeCount, j, propsLen, propName, oldValue, newValue;
if (animateFrom) {
target = me.target;
targetAnim = target.layout && target.layout.animate;
if (targetAnim) {
duration = Ext.isNumber(targetAnim) ? targetAnim : targetAnim.duration;
}
animateProps = Ext.Object.getKeys(me.animatePolicy);
anim = Ext.apply({}, {
from: {},
to: {},
duration: duration || Ext.fx.Anim.prototype.duration
}, targetAnim);
for (changeCount = 0, j = 0, propsLen = animateProps.length; j < propsLen; j++) {
propName = animateProps[j];
oldValue = animateFrom[propName];
newValue = me.peek(propName);
if (oldValue != newValue) {
propName = me.translateProps[propName]||propName;
anim.from[propName] = oldValue;
anim.to[propName] = newValue;
++changeCount;
}
}
if (changeCount) {
if (me.isCollapsingOrExpanding === 1) {
target.componentLayout.undoLayout(me);
}
else {
me.writeProps(anim.from);
}
me.el.animate(anim);
Ext.fx.Manager.getFxQueue(me.el.id)[0].on({
afteranimate: function() {
if (me.isCollapsingOrExpanding === 1) {
target.componentLayout.redoLayout(me);
target.afterCollapse(true);
} else if (me.isCollapsingOrExpanding === 2) {
target.afterExpand(true);
}
}
});
}
}
},
getBorderInfo: function () {
var me = this,
info = me.borderInfo;
if (!info) {
me.borderInfo = info = me.checkCache('borderInfo');
}
return info;
},
getClassList: function () {
return this.classList || (this.classList = new Ext.layout.ClassList(this));
},
getEl: function (nameOrEl, owner) {
var me = this,
src, el, elContext;
if (nameOrEl) {
if (nameOrEl.dom) {
el = nameOrEl;
} else {
src = me.target;
if (owner) {
src = owner;
}
el = src[nameOrEl];
if (typeof el == 'function') { 
el = el.call(src);
if (el === me.el) {
return this; 
}
}
}
if (el) {
elContext = me.context.getEl(me, el);
}
}
return elContext || null;
},
getFrameInfo: function () {
var me = this,
info = me.frameInfo,
framing, border;
if (!info) {
framing = me.framing;
border = me.getBorderInfo();
me.frameInfo = info = 
framing ? {
top   : framing.top    + border.top,
right : framing.right  + border.right,
bottom: framing.bottom + border.bottom,
left  : framing.left   + border.left,
width : framing.width  + border.width,
height: framing.height + border.height
} : border;
}
return info;
},
getMarginInfo: function () {
var me = this,
info = me.marginInfo,
comp, manageMargins, margins, ownerLayout, ownerLayoutId;
if (!info) {
if (!me.wrapsComponent) {
info = me.checkCache('marginInfo');
} else {
comp = me.target;
ownerLayout = comp.ownerLayout;
ownerLayoutId = ownerLayout ? ownerLayout.id : null;
manageMargins = ownerLayout && ownerLayout.manageMargins;
info = comp.margin$;
if (info && info.ownerId !== ownerLayoutId) {
info = null;
}
if (!info) { 
info = me.parseMargins(comp, comp.margin) || me.checkCache('marginInfo');
if (manageMargins) {
margins = me.parseMargins(comp, comp.margins, ownerLayout.defaultMargins);
if (margins) { 
info = {
top:    info.top    + margins.top,
right:  info.right  + margins.right,
bottom: info.bottom + margins.bottom,
left:   info.left   + margins.left
};
}
me.setProp('margin-top', 0);
me.setProp('margin-right', 0);
me.setProp('margin-bottom', 0);
me.setProp('margin-left', 0);
}
info.ownerId = ownerLayoutId;
comp.margin$ = info;
}
info.width  = info.left + info.right;
info.height = info.top  + info.bottom;
}
me.marginInfo = info;
}
return info;
},
clearMarginCache: function() {
delete this.marginInfo;
delete this.target.margin$;
},
getPaddingInfo: function () {
var me = this,
info = me.paddingInfo;
if (!info) {
me.paddingInfo = info = me.checkCache('paddingInfo');
}
return info;
},
getProp: function (propName) {
var me = this,
result = me.props[propName];
me.addTrigger(propName);
return result;
},
getDomProp: function (propName) {
var me = this,
result = (me.dirty && (propName in me.dirty)) ? undefined : me.props[propName];
me.addTrigger(propName, true);
return result;
},
getStyle: function (styleName) {
var me = this,
styles = me.styles,
info, value;
if (styleName in styles) {
value = styles[styleName];
} else {
info = me.styleInfo[styleName];
value = me.el.getStyle(styleName);
if (info && info.parseInt) {
value = parseInt(value, 10) || 0;
}
styles[styleName] = value;
}
return value;
},
getStyles: function (styleNames, altNames) {
var me = this,
styleCache = me.styles,
values = {},
hits = 0,
n = styleNames.length,
i, missing, missingAltNames, name, info, styleInfo, styles, value;
altNames = altNames || styleNames;
for (i = 0; i < n; ++i) {
name = styleNames[i];
if (name in styleCache) {
values[altNames[i]] = styleCache[name];
++hits;
if (i && hits==1) { 
missing = styleNames.slice(0, i);
missingAltNames = altNames.slice(0, i);
}
} else if (hits) {
(missing || (missing = [])).push(name);
(missingAltNames || (missingAltNames = [])).push(altNames[i]);
}
}
if (hits < n) {
missing = missing || styleNames;
missingAltNames = missingAltNames || altNames;
styleInfo = me.styleInfo;
styles = me.el.getStyle(missing);
for (i = missing.length; i--; ) {
name = missing[i];
info = styleInfo[name];
value = styles[name];
if (info && info.parseInt) {
value = parseInt(value, 10) || 0;
}
values[missingAltNames[i]] = value;
styleCache[name] = value;
}
}
return values;
},
hasProp: function (propName) {
return this.getProp(propName) != null;
},
hasDomProp: function (propName) {
return this.getDomProp(propName) != null;
},
invalidate: function (options) {
this.context.queueInvalidate(this, options);
},
markDirty: function () {
if (++this.dirtyCount == 1) {
this.context.queueFlush(this);
}
},
onBoxMeasured: function () {
var boxParent = this.boxParent,
state = this.state;
if (boxParent && boxParent.widthModel.shrinkWrap && !state.boxMeasured && this.measuresBox) {
state.boxMeasured = 1; 
boxParent.boxChildMeasured();
}
},
parseMargins: function (comp, margins, defaultMargins) {
if (margins === true) {
margins = 5;
}
var type = typeof margins,
ret;
if (type == 'string' || type == 'number') {
ret = comp.parseBox(margins);
} else if (margins || defaultMargins) {
ret = { top: 0, right: 0, bottom: 0, left: 0 }; 
if (defaultMargins) {
Ext.apply(ret, this.parseMargins(comp, defaultMargins)); 
}
if (margins) {
margins = Ext.apply(ret, comp.parseBox(margins)); 
}
}
return ret;
},
peek: function (propName) {
return this.props[propName];
},
recoverProp: function (propName, oldProps, oldDirty) {
var me = this,
props = me.props,
dirty;
if (propName in oldProps) {
props[propName] = oldProps[propName];
if (oldDirty && propName in oldDirty) {
dirty = me.dirty || (me.dirty = {});
dirty[propName] = oldDirty[propName];
}
}
},
redo: function(deep) {
var me = this,
items, len, i;
me.revertProps(me.props);
if (deep && me.wrapsComponent) {
if (me.childItems) {
for (i = 0, items = me.childItems, len = items.length; i < len; i++) {
items[i].redo(deep);
}
}
for (i = 0, items = me.children, len = items.length; i < len; i++) {
items[i].redo();
}
}
},
removeEl: function(nameOrEl, owner) {
var me = this,
src, el;
if (nameOrEl) {
if (nameOrEl.dom) {
el = nameOrEl;
} else {
src = me.target;
if (owner) {
src = owner;
}
el = src[nameOrEl];
if (typeof el == 'function') { 
el = el.call(src);
if (el === me.el) {
return this; 
}
}
}
if (el) {
me.context.removeEl(me, el);
}
}
},
revertProps: function (props) {
var name,
flushed = this.flushedProps,
reverted = {};
for (name in props) {
if (flushed.hasOwnProperty(name)) {
reverted[name] = props[name];
}
}
this.writeProps(reverted);
},
setAttribute: function(name, value) {
var me = this;
if (!me.attributes) {
me.attributes = {};
}
me.attributes[name] = value;
me.markDirty();
},
setBox: function (box) {
var me = this;
if ('left' in box) {
me.setProp('x', box.left);
}
if ('top' in box) {
me.setProp('y', box.top);
}
me.setSize(box.width, box.height);
},
setContentHeight: function (height, measured) {
if (!measured && this.hasRawContent) {
return 1;
}
return this.setProp('contentHeight', height);
},
setContentWidth: function (width, measured) {
if (!measured && this.hasRawContent) {
return 1;
}
return this.setProp('contentWidth', width);
},
setContentSize: function (width, height, measured) {
return this.setContentWidth(width, measured) +
this.setContentHeight(height, measured) == 2;
},
setProp: function (propName, value, dirty) {
var me = this,
valueType = typeof value,
borderBox, info;
if (valueType == 'undefined' || (valueType === 'number' && isNaN(value))) {
return 0;
}
if (me.props[propName] === value) {
return 1;
}
me.props[propName] = value;
++me.context.progressCount;
if (dirty === false) {
me.fireTriggers('domTriggers', propName);
me.clearBlocks('domBlocks', propName);
} else {
info = me.styleInfo[propName];
if (info) {
if (!me.dirty) {
me.dirty = {};
}
if (propName == 'width' || propName == 'height') {
borderBox = me.isBorderBoxValue;
if (borderBox === null) {
me.isBorderBoxValue = borderBox = !!me.el.isBorderBox();
}
if (!borderBox) {
me.borderInfo || me.getBorderInfo();
me.paddingInfo || me.getPaddingInfo();
}
}
me.dirty[propName] = value;
me.markDirty();
}
}
me.fireTriggers('triggers', propName);
me.clearBlocks('blocks', propName);
return 1;
},
setHeight: function (height, dirty ) {
var me = this,
comp = me.target,
ownerCtContext = me.ownerCtContext,
frameBody, frameInfo, min, oldHeight, rem;
if (height < 0) {
height = 0;
}
if (!me.wrapsComponent) {
if (!me.setProp('height', height, dirty)) {
return NaN;
}
} else {
min = me.collapsedVert ? 0 : (comp.minHeight || 0);
height = Ext.Number.constrain(height, min, comp.maxHeight);
oldHeight = me.props.height;
if (!me.setProp('height', height, dirty)) {
return NaN;
}
if (ownerCtContext && !me.isComponentChild && isNaN(oldHeight)) {
rem = --ownerCtContext.remainingChildDimensions;
if (!rem) {
ownerCtContext.setProp('containerChildrenSizeDone', true);
}
}
frameBody = me.frameBodyContext;
if (frameBody){
frameInfo = me.getFrameInfo();
frameBody.setHeight(height - frameInfo.height, dirty);
}
}
return height;
},
setWidth: function (width, dirty ) {
var me = this,
comp = me.target,
ownerCtContext = me.ownerCtContext,
frameBody, frameInfo, min, oldWidth, rem;
if (width < 0) {
width = 0;
}
if (!me.wrapsComponent) {
if (!me.setProp('width', width, dirty)) {
return NaN;
}
} else {
min = me.collapsedHorz ? 0 : (comp.minWidth || 0);
width = Ext.Number.constrain(width, min, comp.maxWidth);
oldWidth = me.props.width
if (!me.setProp('width', width, dirty)) {
return NaN;
}
if (ownerCtContext && !me.isComponentChild && isNaN(oldWidth)) {
rem = --ownerCtContext.remainingChildDimensions;
if (!rem) {
ownerCtContext.setProp('containerChildrenSizeDone', true);
}
}
frameBody = me.frameBodyContext;
if (frameBody) {
frameInfo = me.getFrameInfo();
frameBody.setWidth(width - frameInfo.width, dirty);
}
}
return width;
},
setSize: function (width, height, dirty) {
this.setWidth(width, dirty);
this.setHeight(height, dirty);
},
translateProps: {
x: 'left',
y: 'top'
},
undo: function(deep) {
var me = this,
items, len, i;
me.revertProps(me.lastBox);
if (deep && me.wrapsComponent) {
if (me.childItems) {
for (i = 0, items = me.childItems, len = items.length; i < len; i++) {
items[i].undo(deep);
}
}
for (i = 0, items = me.children, len = items.length; i < len; i++) {
items[i].undo();
}
}
},
unsetProp: function (propName) {
var dirty = this.dirty;
delete this.props[propName];
if (dirty) {
delete dirty[propName];
}
},
writeProps: function(dirtyProps, flushing) {
if (!(dirtyProps && typeof dirtyProps == 'object')) {
return;
}
var me = this,
el = me.el,
styles = {},
styleCount = 0, 
styleInfo = me.styleInfo,
info,
propName,
numericValue,
width = dirtyProps.width,
height = dirtyProps.height,
isBorderBox = me.isBorderBoxValue,
target = me.target,
max = Math.max,
paddingWidth = 0,
paddingHeight = 0,
hasWidth, hasHeight, isAbsolute, scrollbarSize, style, targetEl;
if ('displayed' in dirtyProps) {
el.setDisplayed(dirtyProps.displayed);
}
for (propName in dirtyProps) {
if (flushing) {
me.fireTriggers('domTriggers', propName);
me.clearBlocks('domBlocks', propName);
me.flushedProps[propName] = 1;
}
info = styleInfo[propName];
if (info && info.dom) {
if (info.suffix && (numericValue = parseInt(dirtyProps[propName], 10))) {
styles[propName] = numericValue + info.suffix;
}
else {
styles[propName] = dirtyProps[propName];
}
++styleCount;
}
}
if ('x' in dirtyProps || 'y' in dirtyProps) {
if (target.isComponent) {
target.setPosition(dirtyProps.x, dirtyProps.y);
} else {
styleCount += me.addPositionStyles(styles, dirtyProps);
}
}
if (!isBorderBox && (width > 0 || height > 0)) { 
if(!me.frameBodyContext) {
paddingWidth = me.paddingInfo.width;
paddingHeight = me.paddingInfo.height;
}
if (width) {
width = max(parseInt(width, 10) - (me.borderInfo.width + paddingWidth), 0);
styles.width = width + 'px';
++styleCount;
}
if (height) {
height = max(parseInt(height, 10) - (me.borderInfo.height + paddingHeight), 0);
styles.height = height + 'px';
++styleCount;
}
}
if (me.wrapsComponent && Ext.isIE9 && Ext.isStrict) {
if ((hasWidth = width !== undefined && me.hasOverflowY) ||
(hasHeight = height !== undefined && me.hasOverflowX)) {
isAbsolute = me.isAbsolute;
if (isAbsolute === undefined) {
isAbsolute = false;
targetEl = me.target.getTargetEl();
style = targetEl.getStyle('position');
if (style == 'absolute') {
style = targetEl.getStyle('box-sizing');
isAbsolute = (style == 'border-box');
}
me.isAbsolute = isAbsolute; 
}
if (isAbsolute) {
scrollbarSize = Ext.getScrollbarSize();
if (hasWidth) {
width = parseInt(width, 10) + scrollbarSize.width;
styles.width = width + 'px';
++styleCount;
}
if (hasHeight) {
height = parseInt(height, 10) + scrollbarSize.height;
styles.height = height + 'px';
++styleCount;
}
}
}
}
if (styleCount) {
el.setStyle(styles);
}
}
}, function () {
var px =    { dom: true, parseInt: true, suffix: 'px' },
isDom = { dom: true },
faux =  { dom: false };
this.prototype.styleInfo = {
containerChildrenSizeDone:  faux,
containerLayoutDone:    faux,
displayed:              faux,
done:                   faux,
x:                      faux,
y:                      faux,
columnWidthsDone:       faux,
left:                   px,
top:                    px,
right:                  px,
bottom:                 px,
width:                  px,
height:                 px,
'border-top-width':     px,
'border-right-width':   px,
'border-bottom-width':  px,
'border-left-width':    px,
'margin-top':           px,
'margin-right':         px,
'margin-bottom':        px,
'margin-left':          px,
'padding-top':          px,
'padding-right':        px,
'padding-bottom':       px,
'padding-left':         px,
'line-height':          isDom,
display:                isDom
};
});
Ext.define('Ext.layout.Context', {
remainingLayouts: 0,
state: 0,
constructor: function (config) {
var me = this;
Ext.apply(me, config);
me.items = {};
me.layouts = {};
me.blockCount = 0;
me.cycleCount = 0;
me.flushCount = 0;
me.calcCount = 0;
me.animateQueue = me.newQueue();
me.completionQueue = me.newQueue();
me.finalizeQueue = me.newQueue();
me.finishQueue = me.newQueue();
me.flushQueue = me.newQueue();
me.invalidateData = {};
me.layoutQueue = me.newQueue();
me.invalidQueue = [];
me.triggers = {
data: {
},
dom: {}
};
},
callLayout: function (layout, methodName) {
this.currentLayout = layout;
layout[methodName](this.getCmp(layout.owner));
},
cancelComponent: function (comp, isChild, isDestroying) {
var me = this,
components = comp,
isArray = !comp.isComponent,
length = isArray ? components.length : 1,
i, k, klen, items, layout, newQueue, oldQueue, entry, temp,
ownerCtContext;
for (i = 0; i < length; ++i) {
if (isArray) {
comp = components[i];
}
if (isDestroying && comp.ownerCt) {
ownerCtContext = this.items[comp.ownerCt.el.id];
if (ownerCtContext) {
Ext.Array.remove(ownerCtContext.childItems, me.getCmp(comp));
}
}
if (!isChild) {
oldQueue = me.invalidQueue;
klen = oldQueue.length;
if (klen) {
me.invalidQueue = newQueue = [];
for (k = 0; k < klen; ++k) {
entry = oldQueue[k];
temp = entry.item.target;
if (temp != comp && !temp.isDescendant(comp)) {
newQueue.push(entry);
}
}
}
}
layout = comp.componentLayout;
me.cancelLayout(layout);
if (layout.getLayoutItems) {
items = layout.getLayoutItems();
if (items.length) {
me.cancelComponent(items, true);
}
}
if (comp.isContainer && !comp.collapsed) {
layout = comp.layout;
me.cancelLayout(layout);
items = layout.getVisibleItems();
if (items.length) {
me.cancelComponent(items, true);
}
}
}
},
cancelLayout: function (layout) {
var me = this;
me.completionQueue.remove(layout);
me.finalizeQueue.remove(layout);
me.finishQueue.remove(layout);
me.layoutQueue.remove(layout);
if (layout.running) {
me.layoutDone(layout);
}
layout.ownerContext = null;
},
clearTriggers: function (layout, inDom) {
var id = layout.id,
collection = this.triggers[inDom ? 'dom' : 'data'],
triggers = collection && collection[id],
length = (triggers && triggers.length) || 0,
i, item, trigger;
for (i = 0; i < length; ++i) {
trigger = triggers[i];
item = trigger.item;
collection = inDom ? item.domTriggers : item.triggers;
delete collection[trigger.prop][id];
}
},
flush: function () {
var me = this,
items = me.flushQueue.clear(),
length = items.length, i;
if (length) {
++me.flushCount;
for (i = 0; i < length; ++i) {
items[i].flush();
}
}
},
flushAnimations: function() {
var me = this,
items = me.animateQueue.clear(),
len = items.length,
i;
if (len) {
for (i = 0; i < len; i++) {
if (items[i].target.animate !== false) {
items[i].flushAnimations();
}
}
Ext.fx.Manager.runner();
}
},
flushInvalidates: function () {
var me = this,
queue = me.invalidQueue,
length = queue && queue.length,
comp, components, entry, i;
me.invalidQueue = [];
if (length) {
components = [];
for (i = 0; i < length; ++i) {
comp = (entry = queue[i]).item.target;
if (!comp.container.isDetachedBody) {
components.push(comp);
if (entry.options) {
me.invalidateData[comp.id] = entry.options;
}
}
}
me.invalidate(components, null);
}
},
flushLayouts: function (queueName, methodName, dontClear) {
var me = this,
layouts = dontClear ? me[queueName].items : me[queueName].clear(),
length = layouts.length,
i, layout;
if (length) {
for (i = 0; i < length; ++i) {
layout = layouts[i];
if (!layout.running) {
me.callLayout(layout, methodName);
}
}
me.currentLayout = null;
}
},
getCmp: function (cmp) {
return this.getItem(cmp, cmp.el);
},
getEl: function (parent, el) {
var item = this.getItem(el, el);
if (!item.parent) {
item.parent = parent;
if (parent.children.length) {
parent.children.push(item);
} else {
parent.children = [ item ]; 
}
}
return item;
},
getItem: function (target, el) {
var id = el.id,
items = this.items,
item = items[id] ||
(items[id] = new Ext.layout.ContextItem({
context: this,
target: target,
el: el
}));
return item;
},
handleFailure: function () {
var layouts = this.layouts,
layout, key;
Ext.failedLayouts = (Ext.failedLayouts || 0) + 1;
for (key in layouts) {
layout = layouts[key];
if (layouts.hasOwnProperty(key)) {
layout.running      = false;
layout.ownerContext = null;
}
}
},
invalidate: function (components, full) {
var me = this,
isArray = !components.isComponent,
containerLayoutDone,
firstTime, i, comp, item, items, length, componentLayout, layout,
invalidateOptions, token;
for (i = 0, length = isArray ? components.length : 1; i < length; ++i) {
comp = isArray ? components[i] : components;
if (comp.rendered && !comp.hidden) {
item = me.getCmp(comp);
componentLayout = comp.componentLayout;
firstTime = !componentLayout.ownerContext;
layout = (comp.isContainer && !comp.collapsed) ? comp.layout : null;
invalidateOptions = me.invalidateData[item.id];
delete me.invalidateData[item.id];
token = item.init(full, invalidateOptions);
if (invalidateOptions) {
me.processInvalidate(invalidateOptions, item, 'before');
}
if (componentLayout.beforeLayoutCycle) {
componentLayout.beforeLayoutCycle(item);
}
if (layout && layout.beforeLayoutCycle) {
layout.beforeLayoutCycle(item);
}
token = item.initContinue(token);
containerLayoutDone = true;
if (componentLayout.getLayoutItems) {
componentLayout.renderChildren();
items = componentLayout.getLayoutItems();
if (items.length) {
me.invalidate(items, true);
}
}
if (layout) {
containerLayoutDone = false;
layout.renderChildren();
items = layout.getVisibleItems();
if (items.length) {
me.invalidate(items, true);
}
}
item.initDone(containerLayoutDone);
me.resetLayout(componentLayout, item, firstTime);
if (layout) {
me.resetLayout(layout, item, firstTime);
}
item.initAnimation();
if (invalidateOptions) {
me.processInvalidate(invalidateOptions, item, 'after');
}
}
}
me.currentLayout = null;
},
layoutDone: function (layout) {
var ownerContext = layout.ownerContext;
layout.running = false;
if (ownerContext) {
if (layout.isComponentLayout) {
if (ownerContext.measuresBox) {
ownerContext.onBoxMeasured(); 
}
ownerContext.setProp('done', true);
} else {
ownerContext.setProp('containerLayoutDone', true);
}
}
--this.remainingLayouts;
++this.progressCount; 
},
newQueue: function () {
return new Ext.util.Queue();
},
processInvalidate: function (options, item, name) {
if (options[name]) {
var me = this,
currentLayout = me.currentLayout;
me.currentLayout = options.layout || null;
options[name](item, options);
me.currentLayout = currentLayout;
}
},
queueAnimation: function (item) {
this.animateQueue.add(item);
},
queueCompletion: function (layout) {
this.completionQueue.add(layout);
},
queueFinalize: function (layout) {
this.finalizeQueue.add(layout);
},
queueFlush: function (item) {
this.flushQueue.add(item);
},
chainFns: function (oldOptions, newOptions, funcName) {
var me = this,
oldLayout = oldOptions.layout,
newLayout = newOptions.layout,
oldFn = oldOptions[funcName],
newFn = newOptions[funcName];
return function (contextItem) {
var prev = me.currentLayout;
if (oldFn) {
me.currentLayout = oldLayout;
oldFn.call(oldOptions.scope || oldOptions, contextItem, oldOptions);
}
me.currentLayout = newLayout;
newFn.call(newOptions.scope || newOptions, contextItem, newOptions);
me.currentLayout = prev;
};
},
queueInvalidate: function (item, options) {
var me = this,
newQueue = [],
oldQueue = me.invalidQueue,
index = oldQueue.length,
comp, old, oldComp, oldOptions, oldState;
if (item.isComponent) {
item = me.getCmp(comp = item);
} else {
comp = item.target;
}
item.invalid = true;
while (index--) {
old = oldQueue[index];
oldComp = old.item.target;
if (comp.isDescendant(oldComp)) {
return; 
}
if (oldComp == comp) {
if (!(oldOptions = old.options)) {
old.options = options;
} else if (options) {
if (options.widthModel) {
oldOptions.widthModel = options.widthModel;
}
if (options.heightModel) {
oldOptions.heightModel = options.heightModel;
}
if (!(oldState = oldOptions.state)) {
oldOptions.state = options.state;
} else if (options.state) {
Ext.apply(oldState, options.state);
}
if (options.before) {
oldOptions.before = me.chainFns(oldOptions, options, 'before');
}
if (options.after) {
oldOptions.after = me.chainFns(oldOptions, options, 'after');
}
}
return;
}
if (!oldComp.isDescendant(comp)) {
newQueue.push(old); 
}
}
newQueue.push({ item: item, options: options });
me.invalidQueue = newQueue;
},
queueItemLayouts: function (item) {
var comp = item.isComponent ? item : item.target,
layout = comp.componentLayout;
if (!layout.pending && !layout.invalid && !layout.done) {
this.queueLayout(layout);
}
layout = comp.layout;
if (layout && !layout.pending && !layout.invalid && !layout.done) {
this.queueLayout(layout);
}
},
queueLayout: function (layout) {
this.layoutQueue.add(layout);
layout.pending = true;
},
removeEl: function (parent, el) {
var id = el.id,
children = parent.children,
items = this.items;
if(children) {
Ext.Array.remove(children, items[id]);
}
delete items[id];
},
resetLayout: function (layout, ownerContext, firstTime) {
var me = this;
me.currentLayout = layout;
layout.done = false;
layout.pending = true;
layout.firedTriggers = 0;
me.layoutQueue.add(layout);
if (firstTime) {
me.layouts[layout.id] = layout; 
layout.running = true;
if (layout.finishedLayout) {
me.finishQueue.add(layout);
}
++me.remainingLayouts;
++layout.layoutCount; 
layout.ownerContext = ownerContext;
layout.beginCount = 0; 
layout.blockCount = 0; 
layout.calcCount = 0; 
layout.triggerCount = 0; 
if (!layout.initialized) {
layout.initLayout();
}
layout.beginLayout(ownerContext);
} else {
++layout.beginCount;
if (!layout.running) {
++me.remainingLayouts;
layout.running = true;
if (layout.isComponentLayout) {
ownerContext.unsetProp('done');
}
me.completionQueue.remove(layout);
me.finalizeQueue.remove(layout);
}
}
layout.beginLayoutCycle(ownerContext, firstTime);
},
run: function () {
var me = this,
flushed = false,
watchDog = 100;
me.flushInvalidates();
me.state = 1;
me.totalCount = me.layoutQueue.getCount();
me.flush();
while ((me.remainingLayouts || me.invalidQueue.length) && watchDog--) {
if (me.invalidQueue.length) {
me.flushInvalidates();
}
if (me.runCycle()) {
flushed = false; 
} else if (!flushed) {
me.flush();
flushed = true; 
me.flushLayouts('completionQueue', 'completeLayout');
} else if (!me.invalidQueue.length) {
me.state = 2;
break;
}
if (!(me.remainingLayouts || me.invalidQueue.length)) {
me.flush();
me.flushLayouts('completionQueue', 'completeLayout');
me.flushLayouts('finalizeQueue', 'finalizeLayout');
}
}
return me.runComplete();
},
runComplete: function () {
var me = this;
me.state = 2;
if (me.remainingLayouts) {
me.handleFailure();
return false;
}
me.flush();
me.flushLayouts('finishQueue', 'finishedLayout', true);
me.flushLayouts('finishQueue', 'notifyOwner');
me.flush(); 
me.flushAnimations();
return true;
},
runCycle: function () {
var me = this,
layouts = me.layoutQueue.clear(),
length = layouts.length,
i;
++me.cycleCount;
me.progressCount = 0;
for (i = 0; i < length; ++i) {
me.runLayout(me.currentLayout = layouts[i]);
}
me.currentLayout = null;
return me.progressCount > 0;
},
runLayout: function (layout) {
var me = this,
ownerContext = me.getCmp(layout.owner);
layout.pending = false;
if (ownerContext.state.blocks) {
return;
}
layout.done = true;
++layout.calcCount;
++me.calcCount;
layout.calculate(ownerContext);
if (layout.done) {
me.layoutDone(layout);
if (layout.completeLayout) {
me.queueCompletion(layout);
}
if (layout.finalizeLayout) {
me.queueFinalize(layout);
}
} else if (!layout.pending && !layout.invalid && !(layout.blockCount + layout.triggerCount - layout.firedTriggers)) {
me.queueLayout(layout);
}
},
setItemSize: function(item, width, height) {
var items = item,
len = 1,
contextItem, i;
if (item.isComposite) {
items = item.elements;
len = items.length;
item = items[0];
} else if (!item.dom && !item.el) { 
len = items.length;
item = items[0];
}
for (i = 0; i < len; ) {
contextItem = this.get(item);
contextItem.setSize(width, height);
item = items[++i]; 
}
}
});
Ext.define('Ext.util.Point', {
extend:  Ext.util.Region ,
statics: {
fromEvent: function(e) {
e = e.browserEvent || e;
e = (e.changedTouches && e.changedTouches.length > 0) ? e.changedTouches[0] : e;
return new this(e.pageX, e.pageY);
}
},
constructor: function(x, y) {
this.callParent([y, x, y, x]);
},
toString: function() {
return "Point[" + this.x + "," + this.y + "]";
},
equals: function(p) {
return (this.x == p.x && this.y == p.y);
},
isWithin: function(p, threshold) {
if (!Ext.isObject(threshold)) {
threshold = {
x: threshold,
y: threshold
};
}
return (this.x <= p.x + threshold.x && this.x >= p.x - threshold.x &&
this.y <= p.y + threshold.y && this.y >= p.y - threshold.y);
},
isContainedBy: function(region) {
if (!(region instanceof Ext.util.Region)) {
region = Ext.get(region.el || region).getRegion();
}
return region.contains(this);
},
roundedEquals: function(p) {
return (Math.round(this.x) == Math.round(p.x) && Math.round(this.y) == Math.round(p.y));
}
}, function() {
this.prototype.translate = Ext.util.Region.prototype.translateBy;
});
Ext.define('Ext.view.DragZone', {
extend:  Ext.dd.DragZone ,
containerScroll: false,
constructor: function(config) {
var me = this,
view,
ownerCt,
el;
Ext.apply(me, config);
if (!me.ddGroup) {
me.ddGroup = 'view-dd-zone-' + me.view.id;
}
view = me.view;
ownerCt = view.ownerCt;
if (ownerCt) {
el = ownerCt.getTargetEl().dom;
} else {
el = view.el.dom.parentNode;
}
me.callParent([el]);
me.ddel = Ext.get(document.createElement('div'));
me.ddel.addCls(Ext.baseCSSPrefix + 'grid-dd-wrap');
},
init: function(id, sGroup, config) {
var me = this;
me.initTarget(id, sGroup, config);
me.view.on('itemmousedown', me.onItemMouseDown, me);
},
onValidDrop: function(target, e, id) {
this.callParent();
target.el.focus();
},
onItemMouseDown: function(view, record, item, index, e) {
if (!this.isPreventDrag(e, record, item, index)) {
if (view.focusRow) {
view.focusRow(record);
}
this.handleMouseDown(e);
}
},
isPreventDrag: function(e) {
return false;
},
getDragData: function(e) {
var view = this.view,
item = e.getTarget(view.getItemSelector());
if (item) {
return {
copy: view.copy || (view.allowCopy && e.ctrlKey),
event: new Ext.EventObjectImpl(e),
view: view,
ddel: this.ddel,
item: item,
records: view.getSelectionModel().getSelection(),
fromPosition: Ext.fly(item).getXY()
};
}
},
onInitDrag: function(x, y) {
var me = this,
data = me.dragData,
view = data.view,
selectionModel = view.getSelectionModel(),
record = view.getRecord(data.item);
if (!selectionModel.isSelected(record)) {
selectionModel.selectWithEvent(record, me.DDMInstance.mousedownEvent);
}
data.records = selectionModel.getSelection();
me.ddel.update(me.getDragText());
me.proxy.update(me.ddel.dom);
me.onStartDrag(x, y);
return true;
},
getDragText: function() {
var count = this.dragData.records.length;
return Ext.String.format(this.dragText, count, count == 1 ? '' : 's');
},
getRepairXY : function(e, data){
return data ? data.fromPosition : false;
}
});
Ext.define('Ext.util.Grouper', {
extend:  Ext.util.Sorter ,
isGrouper: true,
getGroupString: function(instance) {
return instance.get(this.property);
}
});
var App
;(function gc_wrapper(doc, w, l10n, con){
App || (App = {
cfg:{
extjs: null,
modules: null,
backend: null
},
mod:{ btn: void 0, wnd: void 0 },
backendURL: '',
User: void 0,
view: { },
model: { },
store: { },
sts: add_app_status,
undefine: sub_app_undefine,
create: sub_app_create,
unload: sub_app_unload,
reload: sub_app_reload_devel_view,
getHelpAbstract: get_help_abstract,
extjs_helper: extjs_load
})
return
function Ext_application(){
Ext.application({
name: 'App',
appFolder: App.cfg.extjs.appFolder,
enableQuickTips: true,// true by default but this is not loaded in 'lite'
controllers:[ 'Main' ],// loads `App.controller.Main`
launch: launchApp
})
}
function Ext_Error_handle(err){
con.warn(err)
err && err.msg && Ext.Msg.show({
title: l10n.errun_title,
buttons: Ext.Msg.OK,
icon: Ext.Msg.ERROR,
msg: '<b>' +
err.msg.slice(0, 177) + '...</b><br><br>sourceClass: <b>' +
err.sourceClass + '</b><br>sourceMethod: <b>' +
err.sourceMethod + '</b>'
})
return true
}
function launchApp(){
var tmp
con.log('Ext.application.launch: OK\nCreating Viewport...')
tmp = App.cfg.backend
App.sts(tmp.op, tmp.msg, l10n.stsOK, tmp.time)
tmp.op = tmp.msg = tmp.time = void 0// GC
if(App.cfg.extjs.fading){
tmp = Ext.getBody()
tmp.fadeOut({duration: 777 ,callback:
function fadingViewport(){
Ext.fly('startup').remove()
tmp.show()
Ext.create('App.view.Viewport')
tmp.fadeIn({
easing: 'easeIn',
duration: 1024
})
tmp = void 0
}
})
} else {
Ext.fly('startup').remove()
Ext.create('App.view.Viewport')
}
if('developer.local' != App.User.can.__name &&
'admin.local'      != App.User.can.__name){
return
}
if(App.um && App.um.wes){
check_uncaughtExceptions()
} else {//check periodically without `wes`
setInterval(check_uncaughtExceptions, 2048)
}
}
function extjs_load(){
var path, extjs, el, f
if(App.cfg.backend.url){// `nw` context`
App.backendURL = 'http://127.0.0.1:' + App.cfg.backend.job_port
}
App.extjs_helper = void 0// GC
extjs = App.cfg.extjs
path = extjs.path
el = doc.createElement('link')
el.setAttribute('rel', 'stylesheet')
el.setAttribute('href', path + 'resources/css/ext-all.css')
doc.head.appendChild(el)
if(extjs.launch && extjs.launch.css){
for(f = 0; f < extjs.launch.css.length; ++f){
el = doc.createElement('link')
el.setAttribute('rel', 'stylesheet')
el.setAttribute('href', App.backendURL + extjs.launch.css[f])
doc.head.appendChild(el)
}
}
con.log('config.extjs.load: "' + extjs.load + '"')
if(!w.Ext){// ExtJS is not available yet (this is not a fast loading)
el = doc.createElement('script')
el.setAttribute('type', 'application/javascript')
el.setAttribute('charset', 'utf-8')
el.setAttribute('src', App.backendURL + extjs.load)// see `load_config_then_check_ExtJS()`
doc.head.appendChild(el), el = void 0
f = setInterval(wait_and_setup_extjs, 128)
con.log('extjs_load: done, waiting for ExtJS')
return
}
con.log('extjs_load: done, fast load')
wait_and_setup_extjs()
return
function wait_and_setup_extjs(){
if(!w.Ext) return
f && clearInterval(f)
if(App.backendURL){// `nw` context`
Ext.Loader._getPath = Ext.Loader.getPath
Ext.Loader.getPath = function getPath(className){
return '/' == className[0] ?
App.backendURL + className + '.js' :
Ext.Loader._getPath(className)
}
}
Ext.Error.handle = Ext_Error_handle;// by Ext.Error.raise()
(Ext.encode = JSON.stringify) && con.log(
'ExtJS Ext.encode: always native `JSON.stringify()`'
)
Ext.Loader.setConfig({
enabled: true,
garbageCollect: !!App.cfg.extjs.loadMiniInit,// fast load mini || true,
preserveScripts: !App.cfg.extjs.loadMiniInit,// fast load mini || false
disableCaching: true,// don't change; backend parsing uses '?' in `qs`
scriptCharset: 'utf8',
paths:{
'Ext.uxo': App.cfg.extjs.appFolder + '/uxo',// todo: fix overrides
'Ext.ux': path + 'examples/ux',
'App': App.cfg.extjs.appFolder
}
})
con.log(
'ExtJS version: ' + Ext.getVersion('extjs') + '\n ' +
'ExtJS locale: ' + l10n.lang + '\n ' +
'ExtJS is at <' + path + '>'
)
var i, tmp, js2load
tmp = l10n
l10n = w.l10n = l10n_provider
l10n._ns = ''
Ext.apply(l10n, tmp)
tmp = path + 'locale/ext-lang-' + l10n.lang + '.js'
Ext.Loader.loadScript({
url: tmp,
onError: function fail_load_locale(){
throw new Error('Error loading locale file:\n' + tmp)
}
})
js2load = App.cfg.extjs.launch.js
if(App.cfg.extjs.loadMiniInit){
js2load.splice(0)// GC
extjs_launch()// no need to load anything
return
}
js2load.unshift('App.backend.Connection')// `req`<->`res` with backend
i = 0
tmp = Ext.fly('startup').dom.lastChild
loadInitScripts()
return
function loadInitScripts(){
var file
tmp.innerHTML += '<br>' + (file = js2load[i++])// show progress
file = Ext.Loader.getPath(file)
con.log(file)
Ext.Loader.loadScript({
url: file,
onLoad: onLoad,
onError: onError
})
}
function onLoad(){
if(i >= js2load.length){// all is done
tmp = void 0
js2load.splice(0)// GC
return extjs_launch()
}
return loadInitScripts()
}
function onError(){
con.error('Error loading a file required by configuration!')
if(i >= js2load.length){// all is done
tmp = void 0
js2load.splice(0)// GC
return extjs_launch()
}
return loadInitScripts()
}
}
function extjs_launch(){
con.log(
'_readyTime - _startTime: ' + (new Date().getTime() - _startTime) + '\n' +
'ExtJS + App launch: OK'
)
localStorage.devSUPRO && new Ext.util.KeyMap(Ext.getBody(),{
key: Ext.EventObject.F2,
handler: function(keycode, e){
console.warn('dev: F2')
e.stopEvent()
App.reload(Ext.WindowManager.getActive())
}
})
if(App.User){
App.User.loginView(extjs_rest)
return
}
App.User = { can: { }}// dummy auth object
extjs_rest()
}
function extjs_rest(elp){// load per user modules (if any) create Viewport finally
var defLoad, files, el, i
con.log('Load the rest...')// load the rest of js and classes
defLoad = [ ]
if(App.cfg.extjs.loadMiniInit){// fast load mini
defLoad.push(path + 'ext-rest-nw')// ->'/extjs/ext-rest-nw.js'
} else defLoad.push(
'App.proxy.CRUD',
'App.model.Base',          // loading Models manually, then [M]VC
'App.model.Status',
'App.store.Status',
'App.store.CRUD',          // our CRUD for `Ext.data.*`
'App.view.Window',         // provide core View Class(es)
'App.view.Viewport'        // provide view.Desktop with status
)
if(App.User.modules){// per user/role UI module setup
if((files = App.User.modules.css)) for(i = 0; i < files.length; ++i){
el = doc.createElement('link')
el.setAttribute('rel', 'stylesheet')
el.setAttribute('href', App.backendURL + files[i])
doc.head.appendChild(el)
}
el = App.User.modules.js
if(el && el.length){
files = defLoad.concat(el)
el.splice(0)// GC
}
}
if(files.length){
i = 0
el = App.cfg.extjs.loadMiniInit
el && Ext.Loader.setConfig({ disableCaching: false })
loadRestScripts()
el && Ext.Loader.setConfig({ disableCaching: true })
el = void 0
} else {
Ext_application()
}
return
function loadRestScripts(elp){
var file
file = files[i++]
elp && (elp.innerHTML = file)// show progress in passed in element
file = Ext.Loader.getPath(file)
con.log(file)
Ext.Loader.loadScript({
url: file,
onLoad: onLoad,
onError: onError
})
}
function onLoad(){
if(i >= files.length){// all is done
el = void 0
return Ext_application()
}
return loadRestScripts()
}
function onError(){
con.error('Error loading a file required by configuration!')
if(i >= files.length){// all is done
el = void 0
return Ext_application()
}
return loadRestScripts()
}
}
}// extjs_load
function l10n_provider(msg){
var me, m, idx, tail
me = (me = l10n._ns) ? l10n[me] : l10n
idx = msg.indexOf(':')
if(idx > 0){
tail = msg.slice(idx + 1)
msg = msg.slice(0, idx)
return me && (m = me[msg]) ?
m + '<br><br><div style="color:red;">' + tail + '</div>' :
msg
}
return me && (m = me[msg]) ? m : msg
}
function sub_app_undefine(className){
Ext.undefine(className)
if(Ext.Boot){// ExtJS 5
Ext.Boot.scripts[w.location.protocol + '//' + w.location.host + '/' +
Ext.Loader.getPath(className)] = void 0
} else {// ExtJS 4
Ext.Loader.isFileLoaded[Ext.Loader.getPath(className)] = void 0
delete Ext.Loader.isClassFileLoaded[className]
}
}
function sub_app_create(ns, btn, cfg){
btn && (App.mod.btn = btn).setLoading(true)
if(!(~ns.indexOf('.app.'))){
ns = 'App.' + ns// if class name from "App" (this) namespace
if(btn){// normal load && launch via button (not dev reload)
if(Ext.ClassManager.classes[ns]){
return run_module()
}
return Ext.Loader.require(ns, continueLoading)// initial loading
}
}
return continueLoading()
function continueLoading(){
if(~ns.indexOf('.controller.')){
App.getApplication().getController(ns)
btn && btn.setLoading(false)
return
}
if(App.cfg[ns]){
btn || Ext.undefine(ns)// no button -- development reload
Ext.define(ns, App.cfg[ns], run_module)
App.cfg[ns] = null// GC
return
}
Ext.Msg.show({
title: l10n.errun_title,
buttons: Ext.Msg.OK,
icon: Ext.Msg.ERROR,
msg:
"Can't do <b style='color:#FF0000'>`App.create('" + ns + "')`</b>!<br><br>" +
"<b>`App.create()` is only used with `App.cfg['Class.name']` definitions<br>" +
"in app modules for fast initial App loading.</b>"
})
btn && btn.setLoading(false)
return
}
function run_module(){
if(~ns.indexOf('.app.')){
Ext.application(ns)
} else if(~ns.indexOf('.controller.')){
App.getApplication().getController(ns)
} else {// usually plain views
Ext.create(ns, cfg)
}
btn && btn.setLoading(false)
}
}
function sub_app_unload(panel){
var ai
try {
panel.destroy && panel.destroy()// models, stores and backend can be reloaded there
if(panel.__ctl){// in case of failed init manual destroying of controller
ai = App.getApplication()
ai.eventbus.unlisten(panel.__ctl)
ai.controllers.removeAtKey(panel.__ctl)
App.undefine(panel.__ctl)
}
App.undefine(panel.$className)
} catch(ex){ }
}
function sub_app_reload_devel_view(panel, tool, event){
var url, url_l10n, wmId
if(!panel.wmId){
con.warn(url = "window doesn't support development mode")
Ext.Msg.show({
title: l10n.errun_title,
buttons: Ext.Msg.OK,
icon: Ext.Msg.ERROR,
msg: url
})
return
}
wmId = panel.wmId
con.warn('trying to reload "' + panel.$className + '";\nuse `App.reloadFailed()` to redo a failed run.' )
App.reloadFailed = (function(panel){
return function(){
con.warn('redo App.reload("' + panel.$className + '")')
App.reloadFailed = void 0
sub_app_reload_devel_view(panel)
}
})(panel)
App.unload(panel)
url_l10n = App.backendURL + '/l10n/' + wmId
.replace(/([^.]+)[.].*$/, l10n.lang + '_$1.js')
Ext.Loader.loadScript({
url: url_l10n
,onLoad: function l10n_reloaded(){
url = App.backendURL + '/' + wmId.replace(/[.]/g, '/') + '.js'
Ext.Loader.loadScript({
url: url
,onLoad: view_loaded
,onError: function(){
con.error('view was not loaded')
}
})
}
,onError: function() {
con.error('l10n was not loaded')
}
})
return
function view_loaded(){
var cfg
if((cfg = App.cfg['App.' + wmId]) && cfg.__noctl){
ctl_not_loaded()
return
}
Ext.Loader.loadScript({
url: url = url.replace(/[/]view[/]/, '/controller/')
,onLoad: ctl_loaded
,onError: ctl_not_loaded
})
}
function ctl_loaded(){
App.create(wmId.replace(/view[.]/, 'controller.'))
App.reloadFailed = void 0
}
function ctl_not_loaded(){
App.create(wmId, null,{
constrainTo: Ext.getCmp('desk').getEl()
})
App.reloadFailed = void 0
}
}
function get_help_abstract(panel, tool, event){
con.warn('abstract method')
}
function add_app_status(op, args, res, time){
op = {
created: time ? time : new Date,
op: op, args: args, res: res
}
if(App.store.Status){
App.store.Status.insert(0, new App.model.Status(op))
} else {
con.log('App.sts', op)
}
}
function check_uncaughtExceptions(){
App.backend.req('/uncaughtExceptions',{/* dummy hash to get JSON */},
function(err, data){
con.log('uncaughtExceptions err: ', err)
if(data && data.length){
Ext.Msg.alert({
buttons: Ext.Msg.OK,
icon: Ext.Msg.ERROR,
title: 'uncaught@global on start',
msg: Ext.encode(data).replace(/\\n/g, '<br>'),
fn: function(btn){
con.log(btn)
}
})
con.table(data)
}
})
}
})(document, window, l10n, window.console);
Ext.define('App.backend.Connection',{
extend: Ext.data.Connection,
method: 'POST',
url: App.backendURL,
defaultHeaders:{
'Content-Type': 'text/plain; charset=utf-8'
}
})
App.backend.req = (
function create_backend_request(conn){
return function backend_request(url, data, options){
var callback = Ext.emptyFn
if(url && (0 != url.indexOf('http'))){
url = conn.url + url
}
if(!options || 'function' == typeof options){
options && (callback = options)
options = {
url: url,
callback: null,
params: null,
jsonData: null,
headers: null
}
} else {
options.url = url
options.callback && (callback = options.callback)
}
options.callback = callbackExtAjax
if('string' == typeof data){
options.params = data// plain text or JavaScript for `App.backend.JS`
} else {
if('function' == typeof data){
callback = data
} else {// default data is JSON
options.jsonData = data
}
options.headers = {
'Content-Type': 'application/json; charset=utf-8'
}
}
return conn.request(options)
function callbackExtAjax(opts, success, xhr){
var json = (xhr.getResponseHeader &&
~String(xhr.getResponseHeader('Content-Type'))
.indexOf('application/json')
? Ext.decode(xhr.responseText) : xhr.responseText
)
if(!success && !xhr.responseText){
json = {
err: xhr.timedout ? 'timedout':
xhr.timedout ? 'aborted' : xhr.status
}
console.error(json, xhr)
}
return callback(!success || !json, json, xhr)
}
}
}
)(Ext.create(App.backend.Connection))
Ext.define('App.um.crypto.SHA1', {
singleton: true,
f: function(s, x, y, z) {
switch (s) {
case 0: return (x & y) ^ (~x & z);           // Ch()
case 1: return x ^ y ^ z;                    // Parity()
case 2: return (x & y) ^ (x & z) ^ (y & z);  // Maj()
case 3: return x ^ y ^ z;                    // Parity()
}
},
ROTL: function(x, n) {
return (x<<n) | (x>>>(32-n));
},
hash: function(msg) {
var me = this;
var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
msg += String.fromCharCode(0x80); // add trailing '1' bit to string [5.1.1]
var l = Math.ceil(msg.length/4) + 2;  // long enough to contain msg plus 2-word length
var N = Math.ceil(l/16);              // in N 16-int blocks
var a, b, c, d, e, t, i;
var W = new Array(80);
var M = new Array(N);
for (i=0; i<N; i++) {
M[i] = new Array(16);
for (t=0; t<16; t++) {  // encode 4 chars per integer, big-endian encoding
M[i][t] = (msg.charCodeAt(i*64+t*4)<<24) | (msg.charCodeAt(i*64+t*4+1)<<16) | (msg.charCodeAt(i*64+t*4+2)<<8) | (msg.charCodeAt(i*64+t*4+3));
}
}
M[N-1][14] = ((msg.length-1)*8) / Math.pow(2, 32); M[N-1][14] = Math.floor(M[N-1][14]);
M[N-1][15] = ((msg.length-1)*8) & 0xffffffff;
var H0 = 0x67452301;
var H1 = 0xefcdab89;
var H2 = 0x98badcfe;
var H3 = 0x10325476;
var H4 = 0xc3d2e1f0;
for (i=0; i<N; i++) {
for (t=0;  t<16; t++) W[t] = M[i][t];
for (t=16; t<80; t++) W[t] = me.ROTL(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16], 1);
a = H0; b = H1; c = H2; d = H3; e = H4;
for (t=0; t<80; t++) {
var s = Math.floor(t/20); // seq for blocks of 'f' functions and 'K' constants
var T = (me.ROTL(a,5) + me.f(s,b,c,d) + e + K[s] + W[t]) & 0xffffffff;
e = d;
d = c;
c = me.ROTL(b, 30);
b = a;
a = T;
}
H0 = (H0+a) & 0xffffffff;  // note 'addition modulo 2^32'
H1 = (H1+b) & 0xffffffff;
H2 = (H2+c) & 0xffffffff;
H3 = (H3+d) & 0xffffffff;
H4 = (H4+e) & 0xffffffff;
}
return me.toHexStr( H0 )+ me.toHexStr( H1 ) + me.toHexStr( H2 ) + me.toHexStr( H3 ) + me.toHexStr( H4 );
},
toHexStr : function( val ){
var s = '', v, i;
for(i = 7; i >= 0; i--) {
v = (val >>> (i * 4)) & 0xf;
s += v.toString(16);
}
return s;
}
});
;(function module_Login(App, l10n){
!l10n.um && Ext.syncRequire('/l10n/' + l10n.lang + '_um')
var callbackApp
App.view.items_Bar = Ext.Array.push(App.view.items_Bar || [ ],[
'-'
,{
iconCls: 'appbar-user-onli',// initial in backend by `App.um.wes()`
id: 'um.usts'
,height: 28
,tooltip: '', text: ''// filled by controller after auth
,menu:{
xtype: 'menu',
plain: true,
items:{
xtype: 'buttongroup',
title: l10n.userStatusMenu,
columns: 1,
items:(
function mk_status_list(){
var s = new Array(5) ,l = [ 'onli', 'away', 'busy', 'offl' ]
for(var i = 0; i < 4; i++)  s[i] = {
text: l10n.um.userStatuses[l[i]]
,itemId: l[i]
,width: '100%'
,iconCls: 'appbar-user-' + l[i]
,handler: onStatusItemClick
}
s[i] = {
text: l10n.um.users ,scale: 'large' ,iconCls: 'userman'
,handler:
function open_userman_from_bar(){
var tb
if(!App.User.can['App.um.controller.Userman']) return App.denyMsg()
if((tb = Ext.getCmp('wm').items.getByKey('um.view.Userman'))){
tb.toggle(true)//???? window activation
} else {
App.create('um.controller.Userman')//XXX view creation
}
return this.up('button').hideMenu()
}
}
return s
function onStatusItemClick(item){
item.up('button').setIconCls(item.iconCls).hideMenu()
Ext.globalEvents.fireEventArgs('usts@UI',[ item.iconCls.slice(12)])
}
}
)()// buttongroup.items
}// menu.items
}// menu
}// tbutton
,{
iconCls: 'appbar-shutdown'
,height: 28 ,width: 28
,tooltip: l10n.um.shutdown
,handler: function(){
Ext.globalEvents.fireEventArgs('logout')
}
}
])
var view, user, role, pass, auth
App.User = {
can: null,// permissions; usage: `App.User.can['App.backend.JS'] && (run_that())`
modules: null,// setup modules this role can use
internalId: '',
id: '',
name: '',
Roles: null,
set: function(json){
var me = App.User
me.modules = json.modules
me.can = json.can
me.id = json.user.id
me.name = json.user.name
me.Roles = json.user.roles
},
reset: function (){
var me = App.User
me.can = me.modules = me.Roles = null
me.internalId = me.id = me.name = ''
},
loginView: function(callback){
view = new App.um.view.Login(callback)
},
login: function login(newUserId, get_session_info){
App.backend.req('/login', newUserId,{
autoAbort: true,// multiple requests will cancel previouse one(s)
callback: get_session_info// controller (i.e. caller) updates UI
})
},
auth: function auth(user, role, pass, callback){
App.backend.req('/auth',
user + '\n' + role + '\n' + App.um.crypto.SHA1.hash(pass),
function auth_cb(err, ret, res){
var me = App.User, opt
if(!err){
for(opt in ret.modules.extjs){// short and no auth cfg
App.cfg.modules[opt] = { extjs: ret.modules.extjs[opt]}
}
me.set(ret)
}
callback && callback(err, ret, res)// controller updates UI
}
)
},
logoutUI: logout,// switch for event handlers
logout: logout
}
function logout(cb){
App.backend.req('/logout', null, cb)
}
var themeLogin = {
width: 354,
height: 304
}
Ext.define('App.um.view.Login',{
extend: Ext.container.Container,
xtype: 'app-login',
id: 'login',
layout: 'fit',
constrain: true, floating: true,
shadow: false,// mini: no extjs shadow, use CSS
modal: false,
form: null, dd: null,
style: ''
+'opacity: 0; background-color: #FFFFFF;'
+'padding: 14px;'
+'width: ' + themeLogin.width + 'px; height: ' + themeLogin.height + 'px;'
+'box-shadow:0px 10px 20px #111;'
,items: [{
xtype: 'component'
,style: 'width: 100%; height: 100%;'
,html:''
+'<div id="progress-bar"'
+'  style="background: url(css/progress-bar.gif) no-repeat center 33px;'
+'          opacity: 0;'
+'          text-align: center;'
+'          width: 100%;'
+'          height: 50px;">'
+'  <div style="text-shadow: #CCC 2px 3px 0;font: 2.2em serif; margin-bottom:22px;">'
+     l10n.um.auth
+'  </div>'
+'  <a href="/">' + l10n.reload + '</a>'
+'</div>'
+'<div id="login-view"'// background is in CSS (for correct and easy image path)
+'  style="position: relative; top: -50px; height: 244px;">'
+'  <div id="login-dd"'
+'    style="cursor: move; text-shadow: #CCC 2px 3px 0; font: 3em serif;">'
+     l10n.app
+'  </div>'
+   l10n.welcome
+'  <div id="login-form">'
+'  </div>'
+   l10n.um.loginInfo
+'  <br/><br/>&copy; 2014 olecom@gmail.com<br/>'
+'  <div id="l10n" style="background-color: #D3D3D3; padding-top: 4px; margin-top: 4px;">'
+'    &nbsp;<span class="ru">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>'
+'    &nbsp;<span class="en">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>'
+'    &nbsp;<span class="l10n-reset"><abbr title="' + l10n.um.l10nReset + '">&nbsp;&nbsp;&nbsp;</abbr></span>'
+'  </div>'
+'</div>'// login-view
}],
constructor: function constructorLogin(callback){
var me = this, ddId
me.callParent([callback ? void 0 : { modal: true }])
ddId = '#login-dd'
me.dd = new Ext.util.ComponentDragger(me,{
id: ddId.slice(1),
el: me.el,
constrain: me.constrain,
constrainTo: me.constrainTo,
delegate: ddId
})
me.relayEvents(me.dd,['dragstart', 'drag', 'dragend'])
callbackApp = callback// if undefined do `relogin()` in `controllerLogin()`
controllerLogin()
},
destroy: function(){
Ext.destroy(this.dd, this.form)
callbackApp = this.dd = this.form = void 0
this.callParent()
},
showUp: void 0,
fadeOut: void 0,
fadeInProgress: void 0,
fadeOutProgress: void 0,
initComponent: function initLoginView(){
var me, form
,d = { duration: 1234, callback: void 0 }
,t = { duration: d.duration }
,a = { duration: t.duration, height: 99, callback: void 0 }
view = me = this
me.callParent()
me.render(Ext.getBody())// 'cos `floating: true`
me.showUp = function(){
setTimeout(function(){// wait view layout a bit after form addition
me.getEl().fadeIn(d)// the fancy show up
}, 16)
}
me.fadeOut = function(cb){
if(cb) d.callback = cb
me.getEl().fadeOut(d)
d.callback = void 0
}
me.fadeInProgress = function(cb){
Ext.get('progress-bar').fadeIn(t)
Ext.get('login-view').fadeOut(t)
a.height = 99
if(cb) a.callback = cb
Ext.get('login').animate(a)
a.callback = void 0
}
me.fadeOutProgress = function(cb){
Ext.get('progress-bar').fadeOut(t)
Ext.get('login-view').fadeIn(t)
a.height = 297// <-> themeLogin.height
if(cb) a.callback = cb
Ext.get('login').animate(a)
a.callback = void 0
}
form = me.form = Ext.widget({
renderTo: 'login-form',
itemId: 'login-form',
xtype: 'container',// mini: no need of `basicForm`, `panel`, etc.
width: '100%',
margin: '20px 0 0 0',
items:[{
xtype: 'triggerfield',
triggerCls: 'login-shutdown',
name: 'user',
msgTarget: 'none',// mini: prevent default 'qtip'
emptyText: l10n.um.loginUserBlank,
width: 177,
allowBlank: true,
enableKeyEvents: true,
hideTrigger: true
},{
xtype: 'combo',
name: 'role',
width: 177,
queryMode: 'local',
msgTarget: 'none',// mini: prevent default 'qtip'
value: l10n.um.role,
triggerAction: 'all',
editable: false,
displayField: 'role',
valueField: '=',
listConfig:{
shadow: false// mini: prevent default 'shadow'
},
store: Ext.create(Ext.data.Store,{
fields:[ 'role', '=' ]
}),
disabled: true
},{
xtype: 'textfield',
name: 'pass',
emptyText: '*******',
width: 133,
inputType: 'password',
msgTarget: 'none',// mini: prevent default 'qtip'
allowBlank: false,
disabled: true
},{
xtype: 'button',
width: 133,
iconCls: 'ok',
itemId: 'ok',
text: l10n.um.loginOk,
disabled: true
}]
})
user = form.down('field[name=user]')
role = form.down('field[name=role]')
pass = form.down('field[name=pass]')
auth = form.down('#ok')
}
})
function controllerLogin(){
var l10nel
l10nel = view.el
l10nel.select('#l10n > span').each(l10nChangers)
l10nel.select('#l10n').addListener('click', l10nLangClick)
l10nel = void 0
if(!callbackApp) return relogin()
App.User.internalId = ''// reset to be used as User.id copy while offline
user.disable()// mark to check existing session
user.onTriggerClick = onSessionShutdownClick
user.on({
specialkey: gotoRoles,
change: reqRole
})
role.on({
change: enablePass
})
pass.on({
specialkey: authenticate// one ENTER keypress auth in password
,change: enableAuth
})
auth.on({
click: authenticate
})
Ext.globalEvents.on({
'initwes@UI': handleInitBackendWaitEvents,
'usts@UI': changeUserStatus,
'wes4UI': backendEventsCtlLogin,
logout: logoutCtl
})// == analogous controller's sugar: `App.app.listen({ global:{`
view.showUp()
return App.User.login('?', getSessionInfo)// ask backend is a session there?
}
function l10nChangers(el){
if(!callbackApp){// relogin: disable all
el.dom.style.opacity = 0.5
el.dom.style.cursor = 'not-allowed'
} else {// login: set current
if(0 == el.dom.className.indexOf(l10n.lang)){
el.dom.style.opacity = 0.5// fade out current flag
el.dom.style.cursor = 'not-allowed'
}
}
}
function l10nLangClick(evt, el, o){
o = el.className
if('l10n-reset' !== o){
localStorage.l10n = o.slice(0, 2)// first two
reload()
return
}
if(localStorage.l10n){
delete localStorage.l10n
Ext.Msg.alert({
icon: Ext.Msg.INFO,
buttons: Ext.Msg.OK,
title: l10n.um.l10n,
msg: l10n.um.l10nReset,
callback: reload
})
}
}
function getSessionInfo(err, ret){
if(err) return
user.enable()// mark as ready
user.focus()
if(ret.can){
App.User.set(ret)
user.emptyText = ret.user.id
user.applyEmptyText()
user.setHideTrigger(false)
role.suspendEvents()// prevent e.g. pass.enable()
role.setValue(l10n.um.roles[ret.can.__name] || ret.can.__name)
role.resumeEvents()
if('developer.local' == ret.can.__name){//!!!devel helper
console.log('[supro devel] fast pass for existing session')
authenticate()// fast pass in
return
}
auth.setText(l10n.um.loginCurrentSession)
auth.enable()// auth is ok in this session
auth.focus()// wait user to click
}
}
function onSessionShutdownClick(ev){
App.User.logout()
ev && Ext.Msg.alert({
icon: Ext.Msg.INFO,
buttons: Ext.Msg.OK,
title: l10n.um.logoutTitle,
msg: l10n.um.logoutMsg(App.User.name, App.User.can.__name, true),
fn: function(){
user.focus()
}
})
App.User.reset()
auth.disable()
auth.setText(l10n.um.loginOk)
user.emptyText = l10n.um.loginUserBlank
user.reset()
user.setHideTrigger(true)
role.store.removeAll(true)
role.reset()
}
function reqRole(field, newUserId){
var defer
if(defer) clearTimeout(defer)
if(newUserId){
if(!auth.disabled && newUserId != user.emptyText){
onSessionShutdownClick()
}
defer = setTimeout(function deferReqRoles(){
defer = 0
if(!role.eventsSuspended) role.suspendEvents()
role.reset()
App.User.login(newUserId, function getSessionInfo(err, ret){
if(err) return
if(ret.can){
view.fadeOut(finishAuth)
return// auth is ok in this session
}
if(!ret.roles.length){// no user or roles
if(!role.disabled){// if UI has something already
auth.disable()
role.store.removeAll(true)
role.reset()
role.disable()
pass.reset()
pass.disable()
}
return
}
var models = new Array(ret.roles.length)
,Role = role.store.model
,i = 0, r
for(; i < ret.roles.length; i++){
r = ret.roles[i]
models[i] = new Role({
role: l10n.um.roles[r] || r,
'=': r
})
}
role.store.loadRecords(models, false)
role.resumeEvents()
if(role.disabled){
role.enable()
}
})
}, 512)
return
}
if(!role.disabled){// empty user id
auth.disable()
role.store.removeAll(true)
role.reset()
role.disable()
pass.reset()
pass.disable()
}
}
function authenticate(field, ev){
if(ev && 'keydown' == ev.type && ev.getKey() != ev.ENTER) return
Ext.EventManager.onWindowUnload(doLogout)// `browser`
if(App.backendURL){// `nw`
App.w.on('close', function nw_close(){
App.User.logoutUI()
this.close(true)
})
}
if(field){// from button call arguments: `field, ev`
auth.eventsSuspended = 1// prevent multiple auth calls to backend
auth.focus()
view.fadeInProgress(doAuth)
} else {// from direct call
App.cfg.extjs.fading = false
doAuth()// fast `developer.local`
}
}
function doLogout(){
App.User.logoutUI()
}
function doAuth(){
App.User.auth(
user.getValue(),
role.getValue(),
pass.getValue(),
callbackAuth
)
}
function callbackAuth(err, json, res){
if(!view) return
if(!err){
return view.fadeOut(finishAuth)
} else {
App.User.logoutUI = Ext.emptyFn// prevent shutdown
if(res.status && 402 === res.status) location.reload(true)
if(res.status && 409 === res.status){// race inside session
auth.setText(l10n.um.loginConflict)
auth.disable()
role.disable()
pass.disable()
user.disable()
user.setHideTrigger(true)
user.addCls('redwhite')
} else {// continue (e.g. wrong password)
auth.eventsSuspended = 0
user.selectText()
}
return view.fadeOutProgress()
}
}
function finishAuth(){
var bar = App.view.items_Bar, i, f
callbackApp()// continue App start/loading
destroy()// Login is done
for(i = 0; i < bar.length; ++i){// search user status item
f = bar[i]
if('um.usts' == f.id){
f.tooltip = l10n.um.userStatus + ':<br><b>' + App.User.id + '</b>'
f.text = (
'<i>' + App.User.name + '</i> (<b>' + App.User.can.__name + '</b>)'
)
break
}
}
App.User.logoutUI = Ext.emptyFn
}
function gotoRoles(_, ev){
var key = ev.getKey()
if(key == ev.ENTER || key == ev.DOWN || key == ev.RIGHT){
if(role.disabled){
auth.focus()
} else {
role.focus().expand()
setTimeout(function(){
role.picker.highlightItem(role.picker.getNode(0));
}, 32)
}
}
}
function enablePass(_, value){
pass.enable()
setTimeout(function(){
pass.focus()}, 256)// defer focus after combo is collapsed
}
function enableAuth(_, value){
value ? auth.enable() : auth.disable()
}
function relogin(){
user.onTriggerClick = destroy
user.emptyText = App.User.id.replace(/....([^ ]+) .*/, '$1')
user.applyEmptyText()
user.enable()
user.setHideTrigger(false)
role.setValue(l10n.um.roles[App.User.can.__name] || App.User.can.__name)
pass.on({ specialkey: reloginUser, change: enableAuth })
auth.on({ click: reloginUser })
enablePass()
Ext.WindowManager.bringToFront(view)
view.showUp()
}
function reloginUser(_, ev){
if(ev && 'keydown' == ev.type && ev.getKey() != ev.ENTER) return
auth.eventsSuspended = 1// prevent multiple auth calls to backend
auth.focus()
view.fadeInProgress(function reloginTry(){
App.User.login(App.User.id, function(err, ret){
enablePass()// focus pass after failed login
return err ? setTimeout(reloginTry, 1024) :// if backend isn't ready yet
App.User.auth(// get user 'offldev@::ffff:127.0.0.1 lhY1caqLsTBYirLR9EJMRFji'
App.User.id.slice(4, App.User.id.indexOf('@')),// user == 'dev'
App.User.can.__name,
pass.getValue(), function(err, json, res){
if(err){
if(res.status && 402 === res.status){
App.denyMsg()
} else if(res.status && 409 === res.status){
auth.disable()
auth.setText(l10n.um.loginConflict)
user.setHideTrigger(false)
role.disable()
pass.disable()
}
auth.eventsSuspended = 0
return view.fadeOutProgress()
}
App.um.wes(App.User.internalId.slice(0,4))// saved status
return view.fadeOut(destroy)
}
)})})
}
function destroy(){
view.el.select('#l10n').removeAllListeners()
view = view.destroy()// assign `undefined` to `view` for GC
}
function backendEventsCtlLogin(success, data){
var evn, cmp, s, uncaught
if('string' == typeof data) switch (data){// simple event
case 'Disconnect':
case 'Unauthorized':
case 'Payment Required':
if(view) return// event is firing again (still no login)
(cmp = Ext.getCmp('um.usts')) && cmp.setIconCls('appbar-user-offl')
view = new App.um.view.Login
return
default:return
}
for(evn = 0; evn < data.length; ++evn) switch (data[evn].ev){
case 'Usts@um': if((cmp = Ext.getCmp('um.usts'))){
if(cmp.iconCls.slice(12) != (s = data[evn].json.slice(0, 4))){
cmp.setIconCls('appbar-user-' + s)
}
}
break
case 'uncaught@global':
if(App.User.can[uncaught = 'uncaught@global'] && Ext.Msg.hidden) Ext.Msg.alert(
{
buttons: Ext.Msg.OK,
icon: Ext.Msg.ERROR,
title: uncaught,
msg: data[evn].json,
fn: function(btn){
}
}
)
break
case 'Disconnect':
(cmp = Ext.getCmp('um.usts')) && cmp.setIconCls('appbar-user-offl')
break
case 'Unauthorized':
view && view.destroy()
view = new App.um.view.Login({ modal: true })
Ext.WindowManager.bringToFront(view)
break
default:break
}
App.sts(
'backend events',
success ? data.length : data,// data || res.statusText
success && !uncaught ? l10n.stsOK : l10n.stsHE,
s = new Date
)
console.log('wes: ' + s, data)
console.table(data)
}
function handleInitBackendWaitEvents(msg){
App.sts(
msg,
'init backend Wait EventS',
l10n.stsOK,
new Date
)
}
function changeUserStatus(status){
App.um.wes(status)
}
function logoutCtl(){
Ext.Msg.alert({
buttons: Ext.Msg.YESNO,
icon: Ext.Msg.QUESTION,
title: l10n.um.logoutTitle,
msg: l10n.um.logoutMsg(
App.User.name,
l10n.um.roles[App.User.can.__name] || App.User.can.__name
),
fn: function(btn){
if('yes' == btn){
App.app && App.app.suspendEvents(false)
Ext.globalEvents.suspendEvents(false)
App.User.logout(reload)
}
}
})
}
function reload(){
location.reload(true)
}
App.denyMsg = function denyMsg(){
Ext.Msg.alert({
icon: Ext.Msg.WARNING,
buttons: Ext.Msg.OK,
title: l10n.um.auth,
msg: l10n.um.deny,
fn: function(){ }
})
}
})(App, l10n);
